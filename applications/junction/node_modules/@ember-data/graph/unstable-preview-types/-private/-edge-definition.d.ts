declare module '@ember-data/graph/-private/-edge-definition' {
  import type { StableRecordIdentifier } from '@warp-drive/core-types';
  import type { CollectionField, FieldSchema, LegacyBelongsToField, LegacyHasManyField, ResourceField } from '@warp-drive/core-types/schema/fields';
  import type { Graph } from '@ember-data/graph/-private/graph';
  export type EdgeCache = Record<string, Record<string, EdgeDefinition | null>>;
  export type RelationshipField = LegacyBelongsToField | LegacyHasManyField | ResourceField | CollectionField;
  export type RelationshipFieldKind = RelationshipField['kind'];
  export type CollectionKind = 'hasMany' | 'collection';
  export type ResourceKind = 'belongsTo' | 'resource';
  export const RELATIONSHIP_KINDS: string[];
  export function isLegacyField(field: FieldSchema): field is LegacyBelongsToField | LegacyHasManyField;
  export function isRelationshipField(field: FieldSchema): field is RelationshipField;
  export function temporaryConvertToLegacy(field: ResourceField | CollectionField): LegacyBelongsToField | LegacyHasManyField;
  /**
   *
   * Given RHS (Right Hand Side)
   *
   * ```ts
   * class User extends Model {
   *   @hasMany('animal', { async: false, inverse: 'owner' }) pets;
   * }
   * ```
   *
   * Given LHS (Left Hand Side)
   *
   * ```ts
   * class Animal extends Model {
   *  @belongsTo('user', { async: false, inverse: 'pets' }) owner;
   * }
   * ```
   *
   * The UpgradedMeta for the RHS would be:
   *
   * ```ts
   * {
   *   kind: 'hasMany',
   *   key: 'pets',
   *   type: 'animal',
   *   isAsync: false,
   *   isImplicit: false,
   *   isCollection: true,
   *   isPolymorphic: false,
   *   inverseKind: 'belongsTo',
   *   inverseKey: 'owner',
   *   inverseType: 'user',
   *   inverseIsAsync: false,
   *   inverseIsImplicit: false,
   *   inverseIsCollection: false,
   *   inverseIsPolymorphic: false,
   * }
   * ```
   *
   * The UpgradeMeta for the LHS would be:
   *
   * ```ts
   * {
   *   kind: 'belongsTo',
   *   key: 'owner',
   *   type: 'user',
   *   isAsync: false,
   *   isImplicit: false,
   *   isCollection: false,
   *   isPolymorphic: false,
   *   inverseKind: 'hasMany',
   *   inverseKey: 'pets',
   *   inverseType: 'animal',
   *   inverseIsAsync: false,
   *   inverseIsImplicit: false,
   *   inverseIsCollection: true,
   *   inverseIsPolymorphic: false,
   * }
   * ```
   *
   *
   * @class UpgradedMeta
   * @internal
   */
  export interface UpgradedMeta {
      kind: 'implicit' | RelationshipFieldKind;
      /**
       * The field name on `this` record
       *
       * @internal
       */
      key: string;
      /**
       * The `type` of the related record
       *
       * @internal
       */
      type: string;
      isAsync: boolean;
      isImplicit: boolean;
      isCollection: boolean;
      isPolymorphic: boolean;
      resetOnRemoteUpdate: boolean;
      inverseKind: 'implicit' | RelationshipFieldKind;
      /**
       * The field name on the opposing record
       * @internal
       */
      inverseKey: string;
      /**
       * The `type` of `this` record
       * @internal
       */
      inverseType: string;
      inverseIsAsync: boolean;
      inverseIsImplicit: boolean;
      inverseIsCollection: boolean;
      inverseIsPolymorphic: boolean;
  }
  export interface EdgeDefinition {
      lhs_key: string;
      lhs_modelNames: string[];
      lhs_baseModelName: string;
      lhs_relationshipName: string;
      lhs_definition: UpgradedMeta;
      lhs_isPolymorphic: boolean;
      rhs_key: string;
      rhs_modelNames: string[];
      rhs_baseModelName: string;
      rhs_relationshipName: string;
      rhs_definition: UpgradedMeta | null;
      rhs_isPolymorphic: boolean;
      hasInverse: boolean;
      /**
       * Whether this relationship points back at the same type.
       *
       * If the relationship is polymorphic, this will be true if
       * it points back at the same abstract type.
       *
       * @internal
       */
      isSelfReferential: boolean;
      /**
       * If this is a reflexive relationship, this is true
       * if the relationship also points back at the same
       * field.
       *
       * @internal
       */
      isReflexive: boolean;
  }
  export function isLHS(info: EdgeDefinition, type: string, key: string): boolean;
  export function isRHS(info: EdgeDefinition, type: string, key: string): boolean;
  export function upgradeDefinition(graph: Graph, identifier: StableRecordIdentifier, propertyName: string, isImplicit?: boolean): EdgeDefinition | null;
}
//# sourceMappingURL=-edge-definition.d.ts.map