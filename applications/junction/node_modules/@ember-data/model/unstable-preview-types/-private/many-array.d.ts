declare module '@ember-data/model/-private/many-array' {
  import type Store from '@ember-data/store';
  import type { CreateRecordProperties, NativeProxy } from '@ember-data/store/-private';
  import { LiveArray, MUTATE } from '@ember-data/store/-private';
  import type { BaseFinderOptions, ModelSchema } from '@ember-data/store/types';
  import type { Signal } from '@ember-data/tracking/-private';
  import type { StableRecordIdentifier } from '@warp-drive/core-types';
  import type { Cache } from '@warp-drive/core-types/cache';
  import type { TypedRecordInstance, TypeFromInstance, TypeFromInstanceOrString } from '@warp-drive/core-types/record';
  import type { Links, PaginationLinks } from '@warp-drive/core-types/spec/json-api-raw';
  import type { LegacySupport } from '@ember-data/model/-private/legacy-relationships-support';
  export interface ManyArrayCreateArgs<T> {
      identifiers: StableRecordIdentifier<TypeFromInstanceOrString<T>>[];
      type: TypeFromInstanceOrString<T>;
      store: Store;
      allowMutation: boolean;
      manager: LegacySupport;
      identifier: StableRecordIdentifier;
      cache: Cache;
      meta: Record<string, unknown> | null;
      links: Links | PaginationLinks | null;
      key: string;
      isPolymorphic: boolean;
      isAsync: boolean;
      _inverseIsAsync: boolean;
      isLoaded: boolean;
  }
  /**
    A `ManyArray` is a `MutableArray` that represents the contents of a has-many
    relationship.
  
    The `ManyArray` is instantiated lazily the first time the relationship is
    requested.
  
    This class is not intended to be directly instantiated by consuming applications.
  
    ### Inverses
  
    Often, the relationships in Ember Data applications will have
    an inverse. For example, imagine the following models are
    defined:
  
    ```app/models/post.js
    import Model, { hasMany } from '@ember-data/model';
  
    export default class PostModel extends Model {
      @hasMany('comment') comments;
    }
    ```
  
    ```app/models/comment.js
    import Model, { belongsTo } from '@ember-data/model';
  
    export default class CommentModel extends Model {
      @belongsTo('post') post;
    }
    ```
  
    If you created a new instance of `Post` and added
    a `Comment` record to its `comments` has-many
    relationship, you would expect the comment's `post`
    property to be set to the post that contained
    the has-many.
  
    We call the record to which a relationship belongs-to the
    relationship's _owner_.
  
    @class ManyArray
    @public
  */
  export class RelatedCollection<T = unknown> extends LiveArray<T> {
      isAsync: boolean;
      /**
        The loading state of this array
    
        @property {Boolean} isLoaded
        @public
        */
      isLoaded: boolean;
      /**
        `true` if the relationship is polymorphic, `false` otherwise.
    
        @property {Boolean} isPolymorphic
        @private
        */
      isPolymorphic: boolean;
      _inverseIsAsync: boolean;
      /**
        Metadata associated with the request for async hasMany relationships.
    
        Example
    
        Given that the server returns the following JSON payload when fetching a
        hasMany relationship:
    
        ```js
        {
          "comments": [{
            "id": 1,
            "comment": "This is the first comment",
          }, {
        // ...
          }],
    
          "meta": {
            "page": 1,
            "total": 5
          }
        }
        ```
    
        You can then access the meta data via the `meta` property:
    
        ```js
        let comments = await post.comments;
        let meta = comments.meta;
    
        // meta.page => 1
        // meta.total => 5
        ```
    
        @property {Object | null} meta
        @public
        */
      meta: Record<string, unknown> | null;
      /**
         * Retrieve the links for this relationship
         *
         @property {Object | null} links
         @public
         */
      links: Links | PaginationLinks | null;
      identifier: StableRecordIdentifier;
      cache: Cache;
      _manager: LegacySupport;
      store: Store;
      key: string;
      type: ModelSchema;
      modelName: T extends TypedRecordInstance ? TypeFromInstance<T> : string;
      constructor(options: ManyArrayCreateArgs<T>);
      [MUTATE](target: StableRecordIdentifier[], receiver: typeof NativeProxy<StableRecordIdentifier[], T[]>, prop: string, args: unknown[], _SIGNAL: Signal): unknown;
      notify(): void;
      /**
        Reloads all of the records in the manyArray. If the manyArray
        holds a relationship that was originally fetched using a links url
        EmberData will revisit the original links url to repopulate the
        relationship.
    
        If the ManyArray holds the result of a `store.query()` reload will
        re-run the original query.
    
        Example
    
        ```javascript
        let user = store.peekRecord('user', '1')
        await login(user);
    
        let permissions = await user.permissions;
        await permissions.reload();
        ```
    
        @method reload
        @public
      */
      reload(options?: BaseFinderOptions): Promise<this>;
      /**
        Saves all of the records in the `ManyArray`.
    
        Example
    
        ```javascript
        let inbox = await store.findRecord('inbox', '1');
        let messages = await inbox.messages;
        messages.forEach((message) => {
          message.isRead = true;
        });
        messages.save();
        ```
    
        @method save
        @public
        @return {PromiseArray} promise
      */
      /**
        Create a child record within the owner
    
        @method createRecord
        @public
        @param {Object} hash
        @return {Model} record
      */
      createRecord(hash: CreateRecordProperties<T>): T;
      destroy(): void;
  }
}
//# sourceMappingURL=many-array.d.ts.map