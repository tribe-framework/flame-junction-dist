declare module '@ember-data/model/-private/record-state' {
  import type Store from '@ember-data/store';
  import type { RequestState, RequestStateService } from '@ember-data/store/-private';
  import type { StableRecordIdentifier } from '@warp-drive/core-types';
  import type { Cache } from '@warp-drive/core-types/cache';
  import type { Errors } from '@ember-data/model/-private/errors';
  import type { MinimalLegacyRecord } from '@ember-data/model/-private/model-methods';
  /**
   * A decorator that caches a getter while
   * providing the ability to bust that cache
   * when we so choose in a way that notifies
   * tracking systems.
   *
   * @internal
   */
  export function tagged<T extends object, K extends keyof T & string>(_target: T, key: K, desc: PropertyDescriptor): PropertyDescriptor;
  export function notifySignal<T extends object, K extends keyof T & string>(obj: T, key: K): void;
  /**
  Historically EmberData managed a state machine
  for each record, the localState for which
  was reflected onto Model.
  
  This implements the flags and stateName for backwards compat
  with the state tree that used to be possible (listed below).
  
  stateName and dirtyType are candidates for deprecation.
  
  root
    empty
      deleted    // hidden from stateName
      preloaded  // hidden from stateName
  
    loading
       empty     // hidden from stateName
       preloaded // hidden from stateName
  
    loaded
      saved
      updated
        uncommitted
        invalid
        inFlight
      created
        uncommitted
        invalid
        inFlight
  
    deleted
      saved
        new      // hidden from stateName
      uncommitted
      invalid
      inFlight
  
    @internal
  */
  export default class RecordState {
      store: Store;
      identifier: StableRecordIdentifier;
      record: MinimalLegacyRecord;
      rs: RequestStateService;
      pendingCount: number;
      fulfilledCount: number;
      rejectedCount: number;
      cache: Cache;
      _errorRequests: RequestState[];
      _lastError: RequestState | null;
      handler: object;
      constructor(record: MinimalLegacyRecord);
      destroy(): void;
      notify(key: keyof this & string): void;
      updateInvalidErrors(errors: Errors): void;
      cleanErrorRequests(): void;
      isSaving: boolean;
      get isLoading(): boolean;
      get isLoaded(): boolean;
      get isSaved(): boolean;
      get isEmpty(): boolean;
      get isNew(): boolean;
      get isDeleted(): boolean;
      get isValid(): boolean;
      get isDirty(): boolean;
      get isError(): boolean;
      get adapterError(): unknown;
      get isPreloaded(): boolean;
      get stateName(): "root.loading" | "root.empty" | "root.deleted.inFlight" | "root.deleted.saved" | "root.deleted.invalid" | "root.deleted.uncommitted" | "root.loaded.created.inFlight" | "root.loaded.created.invalid" | "root.loaded.created.uncommitted" | "root.loaded.updated.inFlight" | "root.loaded.updated.invalid" | "root.loaded.updated.uncommitted" | "root.loaded.saved";
      get dirtyType(): "" | "updated" | "deleted" | "created";
  }
}
//# sourceMappingURL=record-state.d.ts.map