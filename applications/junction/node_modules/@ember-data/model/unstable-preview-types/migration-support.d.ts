declare module '@ember-data/model/migration-support' {
  import type Store from '@ember-data/store';
  import type { SchemaService } from '@ember-data/store/types';
  import type { StableRecordIdentifier } from '@warp-drive/core-types';
  import type { ObjectValue } from '@warp-drive/core-types/json/raw';
  import type { TypedRecordInstance } from '@warp-drive/core-types/record';
  import type { Derivation, HashFn, Transformation } from '@warp-drive/core-types/schema/concepts';
  import type { ArrayField, DerivedField, FieldSchema, GenericField, HashField, ObjectField, ObjectSchema, ResourceSchema } from '@warp-drive/core-types/schema/fields';
  import type { WithPartial } from '@warp-drive/core-types/utils';
  import type { MinimalLegacyRecord } from '@ember-data/model/-private/model-methods';
  import { belongsTo, hasMany } from '@ember-data/model/-private/model-methods';
  export type WithLegacyDerivations<T extends TypedRecordInstance> = T & MinimalLegacyRecord & {
      belongsTo: typeof belongsTo;
      hasMany: typeof hasMany;
  };
  type AttributesSchema = ReturnType<Exclude<SchemaService['attributesDefinitionFor'], undefined>>;
  type RelationshipsSchema = ReturnType<Exclude<SchemaService['relationshipsDefinitionFor'], undefined>>;
  export function withDefaults(schema: WithPartial<ResourceSchema, 'legacy' | 'identity'>): ResourceSchema;
  export function registerDerivations(schema: SchemaService): void;
  export interface DelegatingSchemaService {
      attributesDefinitionFor?(resource: StableRecordIdentifier | {
          type: string;
      }): AttributesSchema;
      relationshipsDefinitionFor?(resource: StableRecordIdentifier | {
          type: string;
      }): RelationshipsSchema;
      doesTypeExist?(type: string): boolean;
  }
  export class DelegatingSchemaService implements SchemaService {
      _preferred: SchemaService;
      _secondary: SchemaService;
      constructor(store: Store, schema: SchemaService);
      resourceTypes(): Readonly<string[]>;
      hasResource(resource: StableRecordIdentifier | {
          type: string;
      }): boolean;
      hasTrait(type: string): boolean;
      resourceHasTrait(resource: StableRecordIdentifier | {
          type: string;
      }, trait: string): boolean;
      fields(resource: StableRecordIdentifier | {
          type: string;
      }): Map<string, FieldSchema>;
      transformation(field: GenericField | ObjectField | ArrayField | {
          type: string;
      }): Transformation;
      hashFn(field: HashField | {
          type: string;
      }): HashFn;
      derivation(field: DerivedField | {
          type: string;
      }): Derivation;
      resource(resource: StableRecordIdentifier | {
          type: string;
      }): ResourceSchema | ObjectSchema;
      registerResources(schemas: Array<ResourceSchema | ObjectSchema>): void;
      registerResource(schema: ResourceSchema | ObjectSchema): void;
      registerTransformation(transform: Transformation): void;
      registerDerivation<R, T, FM extends ObjectValue | null>(derivation: Derivation<R, T, FM>): void;
      registerHashFn(hashFn: HashFn): void;
  }
  export {};
}
//# sourceMappingURL=migration-support.d.ts.map