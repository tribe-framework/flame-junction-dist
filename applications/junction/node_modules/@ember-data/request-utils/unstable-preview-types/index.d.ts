/// <reference path="./deprecation-support.d.ts" />
/// <reference path="./string.d.ts" />
/// <reference path="./-private/string/inflect.d.ts" />
/// <reference path="./-private/string/transform.d.ts" />
/// <reference path="./-private/string/inflections.d.ts" />
declare module '@ember-data/request-utils' {
  import type { StableRecordIdentifier } from '@warp-drive/core-types';
  import type { Cache } from '@warp-drive/core-types/cache';
  import type { StableDocumentIdentifier } from '@warp-drive/core-types/identifier';
  import type { QueryParamsSerializationOptions, QueryParamsSource, Serializable } from '@warp-drive/core-types/params';
  import type { ImmutableRequestInfo, ResponseInfo } from '@warp-drive/core-types/request';
  type UnsubscribeToken = object;
  type CacheOperation = 'added' | 'removed' | 'updated' | 'state';
  type DocumentCacheOperation = 'invalidated' | 'added' | 'removed' | 'updated' | 'state';
  export interface NotificationCallback {
      (identifier: StableRecordIdentifier, notificationType: 'attributes' | 'relationships', key?: string): void;
      (identifier: StableRecordIdentifier, notificationType: 'errors' | 'meta' | 'identity' | 'state'): void;
  }
  interface ResourceOperationCallback {
      (identifier: StableRecordIdentifier, notificationType: CacheOperation): void;
  }
  interface DocumentOperationCallback {
      (identifier: StableDocumentIdentifier, notificationType: DocumentCacheOperation): void;
  }
  type NotificationManager = {
      subscribe(identifier: StableRecordIdentifier, callback: NotificationCallback): UnsubscribeToken;
      subscribe(identifier: 'resource', callback: ResourceOperationCallback): UnsubscribeToken;
      subscribe(identifier: 'document' | StableDocumentIdentifier, callback: DocumentOperationCallback): UnsubscribeToken;
      notify(identifier: StableRecordIdentifier, value: 'attributes' | 'relationships', key?: string): boolean;
      notify(identifier: StableRecordIdentifier, value: 'errors' | 'meta' | 'identity' | 'state'): boolean;
      notify(identifier: StableRecordIdentifier, value: CacheOperation): boolean;
      notify(identifier: StableDocumentIdentifier, value: DocumentCacheOperation): boolean;
  };
  type Store = {
      cache: Cache;
      notifications: NotificationManager;
  };
  /**
   * Simple utility function to assist in url building,
   * query params, and other common request operations.
   *
   * These primitives may be used directly or composed
   * by request builders to provide a consistent interface
   * for building requests.
   *
   * For instance:
   *
   * ```ts
   * import { buildBaseURL, buildQueryParams } from '@ember-data/request-utils';
   *
   * const baseURL = buildBaseURL({
   *   host: 'https://api.example.com',
   *   namespace: 'api/v1',
   *   resourcePath: 'emberDevelopers',
   *   op: 'query',
   *   identifier: { type: 'ember-developer' }
   * });
   * const url = `${baseURL}?${buildQueryParams({ name: 'Chris', include:['pets'] })}`;
   * // => 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris'
   * ```
   *
   * This is useful, but not as useful as the REST request builder for query which is sugar
   * over this (and more!):
   *
   * ```ts
   * import { query } from '@ember-data/rest/request';
   *
   * const options = query('ember-developer', { name: 'Chris', include:['pets'] });
   * // => { url: 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris' }
   * // Note: options will also include other request options like headers, method, etc.
   * ```
   *
   * @module @ember-data/request-utils
   * @main @ember-data/request-utils
   * @public
   */
  export interface BuildURLConfig {
      host: string | null;
      namespace: string | null;
  }
  /**
   * Sets the global configuration for `buildBaseURL`
   * for host and namespace values for the application.
   *
   * These values may still be overridden by passing
   * them to buildBaseURL directly.
   *
   * This method may be called as many times as needed.
   * host values of `''` or `'/'` are equivalent.
   *
   * Except for the value of `/` as host, host should not
   * end with `/`.
   *
   * namespace should not start or end with a `/`.
   *
   * ```ts
   * type BuildURLConfig = {
   *   host: string;
   *   namespace: string'
   * }
   * ```
   *
   * Example:
   *
   * ```ts
   * import { setBuildURLConfig } from '@ember-data/request-utils';
   *
   * setBuildURLConfig({
   *   host: 'https://api.example.com',
   *   namespace: 'api/v1'
   * });
   * ```
   *
   * @method setBuildURLConfig
   * @static
   * @public
   * @for @ember-data/request-utils
   * @param {BuildURLConfig} config
   * @return void
   */
  export function setBuildURLConfig(config: BuildURLConfig): void;
  export interface FindRecordUrlOptions {
      op: 'findRecord';
      identifier: {
          type: string;
          id: string;
      };
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface QueryUrlOptions {
      op: 'query';
      identifier: {
          type: string;
      };
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface FindManyUrlOptions {
      op: 'findMany';
      identifiers: {
          type: string;
          id: string;
      }[];
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface FindRelatedCollectionUrlOptions {
      op: 'findRelatedCollection';
      identifier: {
          type: string;
          id: string;
      };
      fieldPath: string;
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface FindRelatedResourceUrlOptions {
      op: 'findRelatedRecord';
      identifier: {
          type: string;
          id: string;
      };
      fieldPath: string;
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface CreateRecordUrlOptions {
      op: 'createRecord';
      identifier: {
          type: string;
      };
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface UpdateRecordUrlOptions {
      op: 'updateRecord';
      identifier: {
          type: string;
          id: string;
      };
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface DeleteRecordUrlOptions {
      op: 'deleteRecord';
      identifier: {
          type: string;
          id: string;
      };
      resourcePath?: string;
      host?: string;
      namespace?: string;
  }
  export interface GenericUrlOptions {
      resourcePath: string;
      host?: string;
      namespace?: string;
  }
  export type UrlOptions = FindRecordUrlOptions | QueryUrlOptions | FindManyUrlOptions | FindRelatedCollectionUrlOptions | FindRelatedResourceUrlOptions | CreateRecordUrlOptions | UpdateRecordUrlOptions | DeleteRecordUrlOptions | GenericUrlOptions;
  /**
   * Builds a URL for a request based on the provided options.
   * Does not include support for building query params (see `buildQueryParams`)
   * so that it may be composed cleanly with other query-params strategies.
   *
   * Usage:
   *
   * ```ts
   * import { buildBaseURL } from '@ember-data/request-utils';
   *
   * const url = buildBaseURL({
   *   host: 'https://api.example.com',
   *   namespace: 'api/v1',
   *   resourcePath: 'emberDevelopers',
   *   op: 'query',
   *   identifier: { type: 'ember-developer' }
   * });
   *
   * // => 'https://api.example.com/api/v1/emberDevelopers'
   * ```
   *
   * On the surface this may seem like a lot of work to do something simple, but
   * it is designed to be composable with other utilities and interfaces that the
   * average product engineer will never need to see or use.
   *
   * A few notes:
   *
   * - `resourcePath` is optional, but if it is not provided, `identifier.type` will be used.
   * - `host` and `namespace` are optional, but if they are not provided, the values globally
   *    configured via `setBuildURLConfig` will be used.
   * - `op` is required and must be one of the following:
   *   - 'findRecord' 'query' 'findMany' 'findRelatedCollection' 'findRelatedRecord'` 'createRecord' 'updateRecord' 'deleteRecord'
   * - Depending on the value of `op`, `identifier` or `identifiers` will be required.
   *
   * @method buildBaseURL
   * @static
   * @public
   * @for @ember-data/request-utils
   * @param urlOptions
   * @return string
   */
  export function buildBaseURL(urlOptions: UrlOptions): string;
  /**
   * filter out keys of an object that have falsy values or point to empty arrays
   * returning a new object with only those keys that have truthy values / non-empty arrays
   *
   * @method filterEmpty
   * @static
   * @public
   * @for @ember-data/request-utils
   * @param {Record<string, Serializable>} source object to filter keys with empty values from
   * @return {Record<string, Serializable>} A new object with the keys that contained empty values removed
   */
  export function filterEmpty(source: Record<string, Serializable>): Record<string, Serializable>;
  /**
   * Sorts query params by both key and value returning a new URLSearchParams
   * object with the keys inserted in sorted order.
   *
   * Treats `included` specially, splicing it into an array if it is a string and sorting the array.
   *
   * Options:
   * - arrayFormat: 'bracket' | 'indices' | 'repeat' | 'comma'
   *
   * 'bracket': appends [] to the key for every value e.g. `&ids[]=1&ids[]=2`
   * 'indices': appends [i] to the key for every value e.g. `&ids[0]=1&ids[1]=2`
   * 'repeat': appends the key for every value e.g. `&ids=1&ids=2`
   * 'comma' (default): appends the key once with a comma separated list of values e.g. `&ids=1,2`
   *
   * @method sortQueryParams
   * @static
   * @public
   * @for @ember-data/request-utils
   * @param {URLSearchParams | object} params
   * @param {object} options
   * @return {URLSearchParams} A URLSearchParams with keys inserted in sorted order
   */
  export function sortQueryParams(params: QueryParamsSource, options?: QueryParamsSerializationOptions): URLSearchParams;
  /**
   * Sorts query params by both key and value, returning a query params string
   *
   * Treats `included` specially, splicing it into an array if it is a string and sorting the array.
   *
   * Options:
   * - arrayFormat: 'bracket' | 'indices' | 'repeat' | 'comma'
   *
   * 'bracket': appends [] to the key for every value e.g. `ids[]=1&ids[]=2`
   * 'indices': appends [i] to the key for every value e.g. `ids[0]=1&ids[1]=2`
   * 'repeat': appends the key for every value e.g. `ids=1&ids=2`
   * 'comma' (default): appends the key once with a comma separated list of values e.g. `ids=1,2`
   *
   * @method buildQueryParams
   * @static
   * @public
   * @for @ember-data/request-utils
   * @param {URLSearchParams | object} params
   * @param {object} [options]
   * @return {string} A sorted query params string without the leading `?`
   */
  export function buildQueryParams(params: QueryParamsSource, options?: QueryParamsSerializationOptions): string;
  export interface CacheControlValue {
      immutable?: boolean;
      'max-age'?: number;
      'must-revalidate'?: boolean;
      'must-understand'?: boolean;
      'no-cache'?: boolean;
      'no-store'?: boolean;
      'no-transform'?: boolean;
      'only-if-cached'?: boolean;
      private?: boolean;
      'proxy-revalidate'?: boolean;
      public?: boolean;
      's-maxage'?: number;
      'stale-if-error'?: number;
      'stale-while-revalidate'?: number;
  }
  /**
   *  Parses a string Cache-Control header value into an object with the following structure:
   *
   * ```ts
   * interface CacheControlValue {
   *   immutable?: boolean;
   *   'max-age'?: number;
   *   'must-revalidate'?: boolean;
   *   'must-understand'?: boolean;
   *   'no-cache'?: boolean;
   *   'no-store'?: boolean;
   *   'no-transform'?: boolean;
   *   'only-if-cached'?: boolean;
   *   private?: boolean;
   *   'proxy-revalidate'?: boolean;
   *   public?: boolean;
   *   's-maxage'?: number;
   *   'stale-if-error'?: number;
   *   'stale-while-revalidate'?: number;
   * }
   * ```
   * @method parseCacheControl
   * @static
   * @public
   * @for @ember-data/request-utils
   * @param {string} header
   * @return {CacheControlValue}
   */
  export function parseCacheControl(header: string): CacheControlValue;
  export type PolicyConfig = {
      apiCacheSoftExpires: number;
      apiCacheHardExpires: number;
  };
  /**
   * A basic CachePolicy that can be added to the Store service.
   *
   * Determines staleness based on time since the request was last received from the API
   * using the `date` header.
   *
   * Invalidates any request for which `cacheOptions.types` was provided when a createRecord
   * request for that type is successful.
   *
   * For this to work, the `createRecord` request must include the `cacheOptions.types` array
   * with the types that should be invalidated, or its request should specify the identifiers
   * of the records that are being created via `records`. Providing both is valid.
   *
   * > [!NOTE]
   * > only requests that had specified `cacheOptions.types` and occurred prior to the
   * > createRecord request will be invalidated. This means that a given request should always
   * > specify the types that would invalidate it to opt into this behavior. Abstracting this
   * > behavior via builders is recommended to ensure consistency.
   *
   * This allows the Store's CacheHandler to determine if a request is expired and
   * should be refetched upon next request.
   *
   * The `Fetch` handler provided by `@ember-data/request/fetch` will automatically
   * add the `date` header to responses if it is not present.
   *
   * > [!NOTE]
   * > Date headers do not have millisecond precision, so expiration times should
   * > generally be larger than 1000ms.
   *
   * Usage:
   *
   * ```ts
   * import { CachePolicy } from '@ember-data/request-utils';
   * import DataStore from '@ember-data/store';
   *
   * // ...
   *
   * export class Store extends DataStore {
   *   constructor(args) {
   *     super(args);
   *     this.lifetimes = new CachePolicy({ apiCacheSoftExpires: 30_000, apiCacheHardExpires: 60_000 });
   *   }
   * }
   * ```
   *
   * @class CachePolicy
   * @public
   * @module @ember-data/request-utils
   */
  export class CachePolicy {
      config: PolicyConfig;
      _stores: WeakMap<Store, {
          invalidated: Set<StableDocumentIdentifier>;
          types: Map<string, Set<StableDocumentIdentifier>>;
      }>;
      _getStore(store: Store): {
          invalidated: Set<StableDocumentIdentifier>;
          types: Map<string, Set<StableDocumentIdentifier>>;
      };
      constructor(config: PolicyConfig);
      /**
       * Invalidate a request by its identifier for a given store instance.
       *
       * While the store argument may seem redundant, the CachePolicy
       * is designed to be shared across multiple stores / forks
       * of the store.
       *
       * ```ts
       * store.lifetimes.invalidateRequest(store, identifier);
       * ```
       *
       * @method invalidateRequest
       * @public
       * @param {StableDocumentIdentifier} identifier
       * @param {Store} store
       */
      invalidateRequest(identifier: StableDocumentIdentifier, store: Store): void;
      /**
       * Invalidate all requests associated to a specific type
       * for a given store instance.
       *
       * While the store argument may seem redundant, the CachePolicy
       * is designed to be shared across multiple stores / forks
       * of the store.
       *
       * This invalidation is done automatically when using this service
       * for both the CacheHandler and the LegacyNetworkHandler.
       *
       * ```ts
       * store.lifetimes.invalidateRequestsForType(store, 'person');
       * ```
       *
       * @method invalidateRequestsForType
       * @public
       * @param {string} type
       * @param {Store} store
       */
      invalidateRequestsForType(type: string, store: Store): void;
      /**
       * Invoked when a request has been fulfilled from the configured request handlers.
       * This is invoked by the CacheHandler for both foreground and background requests
       * once the cache has been updated.
       *
       * Note, this is invoked by the CacheHandler regardless of whether
       * the request has a cache-key.
       *
       * This method should not be invoked directly by consumers.
       *
       * @method didRequest
       * @public
       * @param {ImmutableRequestInfo} request
       * @param {ImmutableResponse} response
       * @param {Store} store
       * @param {StableDocumentIdentifier | null} identifier
       * @return {void}
       */
      didRequest(request: ImmutableRequestInfo, response: Response | ResponseInfo | null, identifier: StableDocumentIdentifier | null, store: Store): void;
      /**
       * Invoked to determine if the request may be fulfilled from cache
       * if possible.
       *
       * Note, this is only invoked by the CacheHandler if the request has
       * a cache-key.
       *
       * If no cache entry is found or the entry is hard expired,
       * the request will be fulfilled from the configured request handlers
       * and the cache will be updated before returning the response.
       *
       * @method isHardExpired
       * @public
       * @param {StableDocumentIdentifier} identifier
       * @param {Store} store
       * @return {boolean} true if the request is considered hard expired
       */
      isHardExpired(identifier: StableDocumentIdentifier, store: Store): boolean;
      /**
       * Invoked if `isHardExpired` is false to determine if the request
       * should be update behind the scenes if cache data is already available.
       *
       * Note, this is only invoked by the CacheHandler if the request has
       * a cache-key.
       *
       * If true, the request will be fulfilled from cache while a backgrounded
       * request is made to update the cache via the configured request handlers.
       *
       * @method isSoftExpired
       * @public
       * @param {StableDocumentIdentifier} identifier
       * @param {Store} store
       * @return {boolean} true if the request is considered soft expired
       */
      isSoftExpired(identifier: StableDocumentIdentifier, store: Store): boolean;
  }
  export class LifetimesService extends CachePolicy {
      constructor(config: PolicyConfig);
  }
  export {};
}
//# sourceMappingURL=index.d.ts.map