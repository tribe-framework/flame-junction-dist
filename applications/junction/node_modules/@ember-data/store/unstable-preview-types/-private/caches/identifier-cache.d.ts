declare module '@ember-data/store/-private/caches/identifier-cache' {
  import { type Identifier, type RecordIdentifier, type StableDocumentIdentifier, type StableExistingRecordIdentifier, type StableRecordIdentifier } from '@warp-drive/core-types/identifier';
  import type { ImmutableRequestInfo } from '@warp-drive/core-types/request';
  import type { ExistingResourceIdentifierObject, ResourceIdentifierObject } from '@warp-drive/core-types/spec/json-api-raw';
  import type { ForgetMethod, GenerationMethod, KeyInfo, KeyInfoMethod, ResetMethod, UpdateMethod } from '@ember-data/store/-types/q/identifier';
  type TypeFromIdentifier<T> = T extends {
      type: infer U;
  } ? U : string;
  type NarrowIdentifierIfPossible<T> = T extends ExistingResourceIdentifierObject ? StableExistingRecordIdentifier<TypeFromIdentifier<T>> : StableRecordIdentifier;
  export function isStableIdentifier(identifier: unknown): identifier is StableRecordIdentifier;
  export function isDocumentIdentifier(identifier: unknown): identifier is StableDocumentIdentifier;
  interface KeyOptions {
      lid: IdentifierMap;
      id: IdentifierMap;
  }
  type TypeMap = {
      [key: string]: KeyOptions;
  };
  type IdentifierMap = Map<string, StableRecordIdentifier>;
  type StableCache = {
      resources: IdentifierMap;
      documents: Map<string, StableDocumentIdentifier>;
      resourcesByType: TypeMap;
      polymorphicLidBackMap: Map<string, string[]>;
  };
  export type MergeMethod = (targetIdentifier: StableRecordIdentifier, matchedIdentifier: StableRecordIdentifier, resourceData: unknown) => StableRecordIdentifier;
  export function setIdentifierGenerationMethod(method: GenerationMethod | null): void;
  export function setIdentifierUpdateMethod(method: UpdateMethod | null): void;
  export function setIdentifierForgetMethod(method: ForgetMethod | null): void;
  export function setIdentifierResetMethod(method: ResetMethod | null): void;
  export function setKeyInfoForResource(method: KeyInfoMethod | null): void;
  /**
   * Each instance of {Store} receives a unique instance of a IdentifierCache.
   *
   * This cache is responsible for assigning or retrieving the unique identify
   * for arbitrary resource data encountered by the store. Data representing
   * a unique resource or record should always be represented by the same
   * identifier.
   *
   * It can be configured by consuming applications.
   *
   * @class IdentifierCache
     @public
   */
  export class IdentifierCache {
      _cache: StableCache;
      _generate: GenerationMethod;
      _update: UpdateMethod;
      _forget: ForgetMethod;
      _reset: ResetMethod;
      _merge: MergeMethod;
      _keyInfoForResource: KeyInfoMethod;
      _id: number;
      constructor();
      /**
       * Internal hook to allow management of merge conflicts with identifiers.
       *
       * we allow late binding of this private internal merge so that
       * the cache can insert itself here to handle elimination of duplicates
       *
       * @method __configureMerge
       * @private
       */
      __configureMerge(method: MergeMethod | null): void;
      upgradeIdentifier(resource: {
          type: string;
          id: string | null;
          lid?: string;
      }): StableRecordIdentifier;
      /**
       * @method _getRecordIdentifier
       * @private
       */
      _getRecordIdentifier(resource: {
          type: string;
          id: string | null;
          lid?: string;
      }, shouldGenerate: 2): StableRecordIdentifier;
      _getRecordIdentifier(resource: unknown, shouldGenerate: 1): StableRecordIdentifier;
      _getRecordIdentifier(resource: unknown, shouldGenerate: 0): StableRecordIdentifier | undefined;
      /**
       * allows us to peek without generating when needed
       * useful for the "create" case when we need to see if
       * we are accidentally overwritting something
       *
       * @method peekRecordIdentifier
       * @param resource
       * @return {StableRecordIdentifier | undefined}
       * @private
       */
      peekRecordIdentifier(resource: ResourceIdentifierObject | Identifier): StableRecordIdentifier | undefined;
      /**
        Returns the DocumentIdentifier for the given Request, creates one if it does not yet exist.
        Returns `null` if the request does not have a `cacheKey` or `url`.
    
        @method getOrCreateDocumentIdentifier
        @param request
        @return {StableDocumentIdentifier | null}
        @public
      */
      getOrCreateDocumentIdentifier(request: ImmutableRequestInfo): StableDocumentIdentifier | null;
      /**
        Returns the Identifier for the given Resource, creates one if it does not yet exist.
    
        Specifically this means that we:
    
        - validate the `id` `type` and `lid` combo against known identifiers
        - return an object with an `lid` that is stable (repeated calls with the same
          `id` + `type` or `lid` will return the same `lid` value)
        - this referential stability of the object itself is guaranteed
    
        @method getOrCreateRecordIdentifier
        @param resource
        @return {StableRecordIdentifier}
        @public
      */
      getOrCreateRecordIdentifier<T>(resource: T): NarrowIdentifierIfPossible<T>;
      /**
       Returns a new Identifier for the supplied data. Call this method to generate
       an identifier when a new resource is being created local to the client and
       potentially does not have an `id`.
    
       Delegates generation to the user supplied `GenerateMethod` if one has been provided
       with the signature `generateMethod({ type }, 'record')`.
    
       @method createIdentifierForNewRecord
       @param data
       @return {StableRecordIdentifier}
       @public
      */
      createIdentifierForNewRecord(data: {
          type: string;
          id?: string | null;
      }): StableRecordIdentifier;
      /**
       Provides the opportunity to update secondary lookup tables for existing identifiers
       Called after an identifier created with `createIdentifierForNewRecord` has been
       committed.
    
       Assigned `id` to an `Identifier` if `id` has not previously existed; however,
       attempting to change the `id` or calling update without providing an `id` when
       one is missing will throw an error.
    
        - sets `id` (if `id` was previously `null`)
        - `lid` and `type` MUST NOT be altered post creation
    
        If a merge occurs, it is possible the returned identifier does not match the originally
        provided identifier. In this case the abandoned identifier will go through the usual
        `forgetRecordIdentifier` codepaths.
    
        @method updateRecordIdentifier
        @param identifierObject
        @param data
        @return {StableRecordIdentifier}
        @public
      */
      updateRecordIdentifier(identifierObject: RecordIdentifier, data: unknown): StableRecordIdentifier;
      /**
       * @method _mergeRecordIdentifiers
       * @private
       */
      _mergeRecordIdentifiers(keyInfo: KeyInfo, identifier: StableRecordIdentifier, existingIdentifier: StableRecordIdentifier, data: unknown): StableRecordIdentifier;
      /**
       Provides the opportunity to eliminate an identifier from secondary lookup tables
       as well as eliminates it from ember-data's own lookup tables and book keeping.
    
       Useful when a record has been deleted and the deletion has been persisted and
       we do not care about the record anymore. Especially useful when an `id` of a
       deleted record might be reused later for a new record.
    
       @method forgetRecordIdentifier
       @param identifierObject
       @public
      */
      forgetRecordIdentifier(identifierObject: RecordIdentifier): void;
      destroy(): void;
  }
  export {};
}
//# sourceMappingURL=identifier-cache.d.ts.map