declare module '@ember-data/store/-private/managers/record-array-manager' {
  import type { LocalRelationshipOperation } from '@warp-drive/core-types/graph';
  import type { StableDocumentIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';
  import type { ImmutableRequestInfo } from '@warp-drive/core-types/request';
  import type { CollectionResourceDocument } from '@warp-drive/core-types/spec/json-api-raw';
  import { Collection, IdentifierArray } from '@ember-data/store/-private/record-arrays/identifier-array';
  import type { Store } from '@ember-data/store/-private/store-service';
  import type { UnsubscribeToken } from '@ember-data/store/-private/managers/notification-manager';
  /**
   * This is a clever optimization.
   *
   * clever optimizations rarely stand the test of time, so if you're
   * ever curious or think something better is possible please benchmark
   * and discuss. The benchmark for this at the time of writing is in
   * `scripts/benchmark-push.js`
   *
   * This approach turns out to be 150x faster in Chrome and node than
   * simply using push or concat. It's highly susceptible to the specifics
   * of the batch size, and may require tuning.
   *
   * Clever optimizations should always come with a `why`. This optimization
   * exists for two reasons.
   *
   * 1) array.push(...objects) and Array.prototype.push.apply(arr, objects)
   *   are susceptible to stack overflows. The size of objects at which this
   *   occurs varies by environment, browser, and current stack depth and memory
   *   pressure; however, it occurs in all browsers in fairly pristine conditions
   *   somewhere around 125k to 200k elements. Since EmberData regularly encounters
   *   arrays larger than this in size, we cannot use push.
   *
   * 2) `array.concat` or simply setting the array to a new reference is often an
   *   easier approach; however, native Proxy to an array cannot swap it's target array
   *   and attempts at juggling multiple array sources have proven to be victim to a number
   *   of browser implementation bugs. Should these bugs be addressed then we could
   *   simplify to using `concat`, however, do note this is currently 150x faster
   *   than concat, and due to the overloaded signature of concat will likely always
   *   be faster.
   *
   * Sincerely,
   *   - runspired (Chris Thoburn) 08/21/2022
   *
   * @function fastPush
   * @internal
   * @param target the array to push into
   * @param source the items to push into target
   */
  export function fastPush<T>(target: T[], source: T[]): void;
  type ChangeSet = Map<StableRecordIdentifier, 'add' | 'del'>;
  /**
    @class RecordArrayManager
    @internal
  */
  export class RecordArrayManager {
      store: Store;
      isDestroying: boolean;
      isDestroyed: boolean;
      _set: Map<IdentifierArray, Set<StableRecordIdentifier>>;
      _live: Map<string, IdentifierArray>;
      _managed: Set<IdentifierArray>;
      _pending: Map<IdentifierArray, ChangeSet>;
      _identifiers: Map<StableRecordIdentifier, Set<Collection>>;
      _staged: Map<string, ChangeSet>;
      _subscription: UnsubscribeToken;
      _documentSubscription: UnsubscribeToken;
      _keyedArrays: Map<string, Collection>;
      _visibilitySet: Map<StableRecordIdentifier, boolean>;
      constructor(options: {
          store: Store;
      });
      _syncArray(array: IdentifierArray | Collection): void;
      mutate(mutation: LocalRelationshipOperation): void;
      /**
        Get the `RecordArray` for a modelName, which contains all loaded records of
        given modelName.
    
        @method liveArrayFor
        @internal
        @param {String} modelName
        @return {RecordArray}
      */
      liveArrayFor(type: string): IdentifierArray;
      getCollection(config: {
          type?: string;
          query?: ImmutableRequestInfo | Record<string, unknown>;
          identifiers?: StableRecordIdentifier[];
          doc?: CollectionResourceDocument;
          identifier?: StableDocumentIdentifier | null;
      }): Collection;
      dirtyArray(array: IdentifierArray, delta: number, shouldSyncFromCache: boolean): void;
      _getPendingFor(identifier: StableRecordIdentifier, includeManaged: boolean, isRemove?: boolean): Map<IdentifierArray, ChangeSet> | void;
      populateManagedArray(array: Collection, identifiers: StableRecordIdentifier[], payload: CollectionResourceDocument | null): void;
      identifierAdded(identifier: StableRecordIdentifier): void;
      identifierRemoved(identifier: StableRecordIdentifier): void;
      identifierChanged(identifier: StableRecordIdentifier): void;
      clear(isClear?: boolean): void;
      destroy(): void;
  }
  export function disassociateIdentifier(ArraysCache: Map<StableRecordIdentifier, Set<Collection>>, array: Collection, identifier: StableRecordIdentifier): void;
  export {};
}
//# sourceMappingURL=record-array-manager.d.ts.map