declare module '@ember-data/store/-private/record-arrays/identifier-array' {
  import type { Signal } from '@ember-data/tracking/-private';
  import type { LocalRelationshipOperation } from '@warp-drive/core-types/graph';
  import type { StableDocumentIdentifier, StableRecordIdentifier } from '@warp-drive/core-types/identifier';
  import type { TypeFromInstanceOrString } from '@warp-drive/core-types/record';
  import type { ImmutableRequestInfo } from '@warp-drive/core-types/request';
  import type { Links, PaginationLinks } from '@warp-drive/core-types/spec/json-api-raw';
  import type { BaseFinderOptions } from '@ember-data/store/types';
  import type { RecordArrayManager } from '@ember-data/store/-private/managers/record-array-manager';
  import type { Store } from '@ember-data/store/-private/store-service';
  import { NativeProxy } from '@ember-data/store/-private/record-arrays/native-proxy-type-fix';
  export const ARRAY_SIGNAL: "___(unique) Symbol(#signal)";
  export const SOURCE: "___(unique) Symbol(#source)";
  export const MUTATE: "___(unique) Symbol(#update)";
  export const NOTIFY: "___(unique) Symbol(#notify)";
  const IS_COLLECTION: "___(unique) Symbol(IS_COLLECTION)";
  export function notifyArray(arr: IdentifierArray): void;
  export type IdentifierArrayCreateOptions<T = unknown> = {
      identifiers: StableRecordIdentifier<TypeFromInstanceOrString<T>>[];
      type?: TypeFromInstanceOrString<T>;
      store: Store;
      allowMutation: boolean;
      manager: MinimumManager;
      links?: Links | PaginationLinks | null;
      meta?: Record<string, unknown> | null;
      identifier?: StableDocumentIdentifier | null;
  };
  type PromiseTo<T> = Omit<Promise<T>, typeof Symbol.toStringTag>;
  type PromiseManyArray<T> = {
      length: number;
      content: IdentifierArray<T> | null;
      promise: Promise<IdentifierArray<T>> | null;
  } & PromiseTo<IdentifierArray<T>>;
  export type MinimumManager = {
      _syncArray: (array: IdentifierArray) => void;
      mutate?(mutation: LocalRelationshipOperation): void;
      reloadHasMany?<T>(key: string, options?: BaseFinderOptions): Promise<IdentifierArray<T>> | PromiseManyArray<T>;
  };
  /**
    A record array is an array that contains records of a certain type (or modelName).
    The record array materializes records as needed when they are retrieved for the first
    time. You should not create record arrays yourself. Instead, an instance of
    `RecordArray` or its subclasses will be returned by your application's store
    in response to queries.
  
    This class should not be imported and instantiated by consuming applications.
  
    @class RecordArray
    @public
  */
  export interface IdentifierArray<T = unknown> extends Omit<Array<T>, '[]'> {
      [MUTATE]?(target: StableRecordIdentifier[], receiver: typeof NativeProxy<StableRecordIdentifier[], T[]>, prop: string, args: unknown[], _SIGNAL: Signal): unknown;
  }
  export class IdentifierArray<T = unknown> {
      DEPRECATED_CLASS_NAME: string;
      /**
        The flag to signal a `RecordArray` is currently loading data.
        Example
        ```javascript
        let people = store.peekAll('person');
        people.isUpdating; // false
        people.update();
        people.isUpdating; // true
        ```
        @property isUpdating
        @public
        @type Boolean
      */
      isUpdating: boolean;
      isLoaded: boolean;
      isDestroying: boolean;
      isDestroyed: boolean;
      _updatingPromise: Promise<IdentifierArray<T>> | null;
      readonly identifier: StableDocumentIdentifier | null;
      [IS_COLLECTION]: boolean;
      [ARRAY_SIGNAL]: Signal;
      [SOURCE]: StableRecordIdentifier[];
      [NOTIFY](): void;
      links: Links | PaginationLinks | null;
      meta: Record<string, unknown> | null;
      modelName?: TypeFromInstanceOrString<T>;
      /**
        The store that created this record array.
    
        @property store
        @private
        @type Store
        */
      store: Store;
      _manager: MinimumManager;
      destroy(clear: boolean): void;
      get length(): number;
      set length(value: number);
      constructor(options: IdentifierArrayCreateOptions<T>);
      /**
        Used to get the latest version of all of the records in this array
        from the adapter.
    
        Example
    
        ```javascript
        let people = store.peekAll('person');
        people.isUpdating; // false
    
        people.update().then(function() {
          people.isUpdating; // false
        });
    
        people.isUpdating; // true
        ```
    
        @method update
        @public
      */
      update(): Promise<IdentifierArray<T>>;
      _update(): Promise<IdentifierArray<T>>;
      /**
        Saves all of the records in the `RecordArray`.
    
        Example
    
        ```javascript
        let messages = store.peekAll('message');
        messages.forEach(function(message) {
          message.hasBeenSeen = true;
        });
        messages.save();
        ```
    
        @method save
        @public
        @return {Promise<IdentifierArray>} promise
      */
      save(): Promise<IdentifierArray>;
  }
  export type CollectionCreateOptions = IdentifierArrayCreateOptions & {
      manager: RecordArrayManager;
      query: ImmutableRequestInfo | Record<string, unknown> | null;
      isLoaded: boolean;
  };
  export class Collection<T = unknown> extends IdentifierArray<T> {
      query: ImmutableRequestInfo | Record<string, unknown> | null;
      _manager: RecordArrayManager;
      constructor(options: CollectionCreateOptions);
      _update(): Promise<Collection<T>>;
      destroy(clear: boolean): void;
  }
  export {};
}
//# sourceMappingURL=identifier-array.d.ts.map