declare module '@ember-data/tracking/-private' {
  import { tagForProperty } from '@ember/-internals/metal';
  import { dependentKeyCompat as compat } from '@ember/object/compat';
  /**
   * This package provides primitives that allow powerful low-level
   * adjustments to change tracking notification behaviors.
   *
   * Typically you want to use these primitives when you want to divorce
   * property accesses on EmberData provided objects from the current
   * tracking context. Typically this sort of thing occurs when serializing
   * tracked data to send in a request: the data itself is often ancillary
   * to the thing which triggered the request in the first place and you
   * would not want to re-trigger the request for any update to the data.
   *
   * @module @ember-data/tracking
   * @main @ember-data/tracking
   */
  type OpaqueFn = (...args: unknown[]) => unknown;
  type Tag = {
      ref: null;
      t: boolean;
  };
  /**
   * If there is a current transaction, ensures that the relevant tag (and any
   * array computed chains symbols, if applicable) will be consumed during the
   * transaction.
   *
   * If there is no current transaction, will consume the tag(s) immediately.
   *
   * @internal
   * @param obj
   */
  export function subscribe(obj: Tag | Signal): void;
  export function addToTransaction(obj: Tag | Signal): void;
  export function addTransactionCB(method: OpaqueFn): void;
  /**
   * Run `method` without subscribing to any tracked properties
   * controlled by EmberData.
   *
   * This should rarely be used except by libraries that really
   * know what they are doing. It is most useful for wrapping
   * certain kinds of fetch/query logic from within a `Resource`
   * `hook` or other similar pattern.
   *
   * @function untracked
   * @public
   * @static
   * @for @ember-data/tracking
   * @param method
   * @return result of invoking method
   */
  export function untracked<T extends OpaqueFn>(method: T): ReturnType<T>;
  /**
   * Run the method, subscribing to any tracked properties
   * managed by EmberData that were accessed or written during
   * the method's execution as per-normal but while allowing
   * interleaving of reads and writes.
   *
   * This is useful when for instance you want to perform
   * a mutation based on existing state that must be read first.
   *
   * @function transact
   * @public
   * @static
   * @for @ember-data/tracking
   * @param method
   * @return result of invoking method
   */
  export function transact<T extends OpaqueFn>(method: T): ReturnType<T>;
  /**
   * A helpful utility for creating a new function that
   * always runs in a transaction. E.G. this "memoizes"
   * calling `transact(fn)`, currying args as necessary.
   *
   * @method memoTransact
   * @public
   * @static
   * @for @ember-data/tracking
   * @param method
   * @return a function that will invoke method in a transaction with any provided args and return its result
   */
  export function memoTransact<T extends OpaqueFn>(method: T): (...args: unknown[]) => ReturnType<T>;
  export const Signals: "___(unique) Symbol(Signals)";
  /**
   *  use to add a signal property to the prototype of something.
   *
   *  First arg is the thing to define on
   *  Second arg is the property name
   *  Third agg is the initial value of the property if any.
   *
   *  for instance
   *
   *  ```ts
   *  class Model {}
   *  defineSignal(Model.prototype, 'isLoading', false);
   *  ```
   *
   *  This is sort of like using a stage-3 decorator but works today
   *  while we are still on legacy decorators.
   *
   *  e.g. it is equivalent to
   *
   *  ```ts
   *  class Model {
   *    @signal accessor isLoading = false;
   *  }
   *  ```
   *
   *  @internal
   */
  export function defineSignal<T extends object>(obj: T, key: string, v?: unknown): void;
  export function defineSubscription<T extends object>(obj: T, key: string, desc: PropertyDescriptor): void;
  export interface Signal {
      /**
       * Key on the associated object
       * @internal
       */
      key: string;
      _debug_base?: string;
      /**
       * Whether this signal is part of an active transaction.
       * @internal
       */
      t: boolean;
      /**
       * Whether to "bust" the lastValue cache
       * @internal
       */
      shouldReset: boolean;
      /**
       * The reason this signal is dirty
       *
       * @internal
       */
      reason: string | null;
      /**
       * The framework specific "signal" e.g. glimmer "tracked"
       * or starbeam "cell" to consume/invalidate when appropriate.
       *
       * @internal
       */
      tag: ReturnType<typeof tagForProperty>;
      /**
       * In classic ember, arrays must entangle a `[]` symbol
       * in addition to any other tag in order for array chains to work.
       *
       * Note, this symbol MUST be the one that ember itself generates
       *
       * @internal
       */
      '[]': ReturnType<typeof tagForProperty> | null;
      /**
       * In classic ember, arrays must entangle a `@length` symbol
       * in addition to any other tag in order for array chains to work.
       *
       * Note, this symbol MUST be the one that ember itself generates
       *
       * @internal
       */
      '@length': ReturnType<typeof tagForProperty> | null;
      /**
       * The lastValue computed for this signal when
       * a signal is also used for storage.
       * @internal
       */
      lastValue: unknown;
  }
  export function createArrayTags<T extends object>(obj: T, signal: Signal): void;
  /**
   * Create a signal for the key/object pairing.
   *
   * @internal
   * @param obj Object we're creating the signal on
   * @param key Key to create the signal for
   * @return the signal
   */
  export function createSignal<T extends object>(obj: T, key: string): Signal;
  /**
   * Create a signal for the key/object pairing and subscribes to the signal.
   *
   * Use when you need to ensure a signal exists and is subscribed to.
   *
   * @internal
   * @param signals Map of signals
   * @param obj Object we're creating the signal on
   * @param key Key to create the signal for
   * @return the signal
   */
  export function entangleSignal<T extends object>(signals: Map<string, Signal>, obj: T, key: string): Signal;
  export function getSignal<T extends object>(obj: T, key: string, initialState: boolean): Signal;
  export function peekSignal<T extends object>(obj: T, key: string): Signal | undefined;
  export function subscribed<T extends object, K extends keyof T & string>(_target: T, key: K, desc: PropertyDescriptor): PropertyDescriptor;
  export { compat };
  export function notifySignal<T extends object, K extends keyof T & string>(obj: T, key: K): void;
}
//# sourceMappingURL=-private.d.ts.map