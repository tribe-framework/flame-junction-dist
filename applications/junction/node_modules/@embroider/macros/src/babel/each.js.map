{"version":3,"file":"each.js","sourceRoot":"","sources":["each.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport { buildLiterals, Evaluator } from './evaluate-json';\nimport type { types as t } from '@babel/core';\nimport error from './error';\nimport type State from './state';\nimport type * as Babel from '@babel/core';\nimport cloneDeep from 'lodash/cloneDeep';\n\ntype CallEachExpression = NodePath<t.CallExpression> & {\n  get(callee: 'callee'): NodePath<t.Identifier>;\n};\n\nexport type EachPath = NodePath<t.ForOfStatement> & {\n  get(right: 'right'): CallEachExpression;\n};\n\nexport function isEachPath(path: NodePath<t.ForOfStatement>): path is EachPath {\n  let right = path.get('right');\n  if (right.isCallExpression()) {\n    let callee = right.get('callee');\n    if (callee.referencesImport('@embroider/macros', 'each')) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function insertEach(path: EachPath, state: State, context: typeof Babel) {\n  let args = path.get('right').get('arguments');\n  if (args.length !== 1) {\n    throw error(path, `the each() macro accepts exactly one argument, you passed ${args.length}`);\n  }\n\n  let left = path.get('left');\n  if (!left.isVariableDeclaration() || left.get('declarations').length !== 1) {\n    throw error(left, `the each() macro doesn't support this syntax`);\n  }\n\n  let body = path.get('body');\n  let varName = (left.get('declarations')[0].get('id') as NodePath<t.Identifier>).node.name;\n  let nameRefs = body.scope.getBinding(varName)!.referencePaths;\n\n  let [arrayPath] = args;\n  let array = new Evaluator({ state }).evaluate(arrayPath);\n  if (!array.confident) {\n    throw error(args[0], `the argument to the each() macro must be statically known`);\n  }\n\n  if (state.opts.mode === 'compile-time' && !Array.isArray(array.value)) {\n    throw error(args[0], `the argument to the each() macro must be an array`);\n  }\n\n  if (state.opts.mode === 'run-time') {\n    let callee = path.get('right').get('callee');\n    callee.replaceWith(state.importUtil.import(callee, state.pathToOurAddon('runtime'), 'each'));\n  } else {\n    for (let element of array.value) {\n      let literalElement = buildLiterals(element, context);\n      for (let target of nameRefs) {\n        target.replaceWith(literalElement);\n      }\n      path.insertBefore(cloneDeep(path.get('body').node));\n    }\n    path.remove();\n  }\n}\n"]}