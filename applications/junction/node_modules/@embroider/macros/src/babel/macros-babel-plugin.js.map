{"version":3,"file":"macros-babel-plugin.js","sourceRoot":"","sources":["macros-babel-plugin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport type { types as t } from '@babel/core';\nimport type State from './state';\nimport { initState } from './state';\nimport type { Mode as GetConfigMode } from './get-config';\nimport { inlineRuntimeConfig, insertConfig } from './get-config';\nimport macroCondition, { isMacroConditionPath } from './macro-condition';\nimport { isEachPath, insertEach } from './each';\n\nimport error from './error';\nimport failBuild from './fail-build';\nimport { Evaluator, buildLiterals } from './evaluate-json';\nimport type * as Babel from '@babel/core';\nimport { existsSync, readdirSync } from 'fs';\nimport { resolve, dirname, join } from 'path';\n\nexport default function main(context: typeof Babel): unknown {\n  let t = context.types;\n  let visitor = {\n    Program: {\n      enter(path: NodePath<t.Program>, state: State) {\n        initState(context, path, state);\n      },\n      exit(_: NodePath<t.Program>, state: State) {\n        // @embroider/macros itself has no runtime behaviors and should always be removed\n        state.importUtil.removeAllImports('@embroider/macros');\n        for (let handler of state.jobs) {\n          handler();\n        }\n      },\n    },\n    'IfStatement|ConditionalExpression': {\n      enter(path: NodePath<t.IfStatement | t.ConditionalExpression>, state: State) {\n        if (isMacroConditionPath(path)) {\n          state.calledIdentifiers.add(path.get('test').get('callee').node);\n          macroCondition(path, state);\n        }\n      },\n    },\n    ForOfStatement: {\n      enter(path: NodePath<t.ForOfStatement>, state: State) {\n        if (isEachPath(path)) {\n          state.calledIdentifiers.add(path.get('right').get('callee').node);\n          insertEach(path, state, context);\n        }\n      },\n    },\n    FunctionDeclaration: {\n      enter(path: NodePath<t.FunctionDeclaration>, state: State) {\n        let id = path.get('id');\n        if (id.isIdentifier() && id.node.name === 'initializeRuntimeMacrosConfig' && state.opts.mode === 'run-time') {\n          let pkg = state.owningPackage();\n          if (pkg && pkg.name === '@embroider/macros') {\n            inlineRuntimeConfig(path, state, context);\n          }\n        }\n      },\n    },\n    CallExpression: {\n      enter(path: NodePath<t.CallExpression>, state: State) {\n        let callee = path.get('callee');\n        if (!callee.isIdentifier()) {\n          return;\n        }\n\n        // failBuild is implemented for side-effect, not value, so it's not\n        // handled by evaluateMacroCall.\n        if (callee.referencesImport('@embroider/macros', 'failBuild')) {\n          state.calledIdentifiers.add(callee.node);\n          failBuild(path, state);\n          return;\n        }\n\n        if (callee.referencesImport('@embroider/macros', 'importSync')) {\n          // we handle importSync in the exit hook\n          return;\n        }\n\n        // getOwnConfig/getGlobalConfig/getConfig needs special handling, so\n        // even though it also emits values via evaluateMacroCall when they're\n        // needed recursively by other macros, it has its own insertion-handling\n        // code that we invoke here.\n        //\n        // The things that are special include:\n        //  - automatic collapsing of chained properties, etc\n        //  - these macros have runtime implementations sometimes, which changes\n        //    how we rewrite them\n        let mode: GetConfigMode | false = callee.referencesImport('@embroider/macros', 'getOwnConfig')\n          ? 'own'\n          : callee.referencesImport('@embroider/macros', 'getGlobalConfig')\n          ? 'getGlobalConfig'\n          : callee.referencesImport('@embroider/macros', 'getConfig')\n          ? 'package'\n          : false;\n        if (mode) {\n          state.calledIdentifiers.add(callee.node);\n          insertConfig(path, state, mode, context);\n          return;\n        }\n\n        // isTesting can have a runtime implementation. At compile time it\n        // instead falls through to evaluateMacroCall.\n        if (callee.referencesImport('@embroider/macros', 'isTesting') && state.opts.mode === 'run-time') {\n          state.calledIdentifiers.add(callee.node);\n          callee.replaceWith(state.importUtil.import(callee, state.pathToOurAddon('runtime'), 'isTesting'));\n          return;\n        }\n\n        let result = new Evaluator({ state }).evaluateMacroCall(path);\n        if (result.confident) {\n          state.calledIdentifiers.add(callee.node);\n          path.replaceWith(buildLiterals(result.value, context));\n        }\n      },\n      exit(path: NodePath<t.CallExpression>, state: State) {\n        let callee = path.get('callee');\n        if (!callee.isIdentifier()) {\n          return;\n        }\n        // importSync doesn't evaluate to a static value, so it's implemented\n        // directly here, not in evaluateMacroCall.\n        // We intentionally do this on exit here, to allow other transforms to handle importSync before we do\n        // For example ember-auto-import needs to do some custom transforms to enable use of dynamic template strings,\n        // so its babel plugin needs to see and handle the importSync call first!\n        if (callee.referencesImport('@embroider/macros', 'importSync')) {\n          let specifier = path.node.arguments[0];\n          if (specifier?.type !== 'StringLiteral') {\n            let relativePath = '';\n            let property;\n            if (specifier.type === 'TemplateLiteral') {\n              relativePath = specifier.quasis[0].value.cooked!;\n              property = specifier.expressions[0] as t.Expression;\n            }\n            // babel might transform template form `../my-path/${id}` to '../my-path/'.concat(id)\n            if (\n              specifier.type === 'CallExpression' &&\n              specifier.callee.type === 'MemberExpression' &&\n              specifier.callee.property.type === 'Identifier' &&\n              specifier.callee.property.name === 'concat' &&\n              specifier.callee.object.type === 'StringLiteral'\n            ) {\n              relativePath = specifier.callee.object.value;\n              property = specifier.arguments[0] as t.Expression;\n            }\n            if (property && relativePath && relativePath.startsWith('.')) {\n              const resolvedPath = resolve(dirname((state as any).filename), relativePath);\n              let entries: string[] = [];\n              if (existsSync(resolvedPath)) {\n                entries = readdirSync(resolvedPath).filter(e => !e.startsWith('.'));\n              }\n              const obj = t.objectExpression(\n                entries.map(e => {\n                  let key = e.split('.')[0];\n                  const rest = e.split('.').slice(1, -1);\n                  if (rest.length) {\n                    key += `.${rest}`;\n                  }\n                  const id = t.callExpression(\n                    state.importUtil.import(path, state.pathToOurAddon('es-compat2'), 'default', 'esc'),\n                    [state.importUtil.import(path, join(relativePath, key).replace(/\\\\/g, '/'), '*')]\n                  );\n                  return t.objectProperty(t.stringLiteral(key), id);\n                })\n              );\n              const memberExpr = t.memberExpression(obj, property, true);\n              path.replaceWith(memberExpr);\n              state.calledIdentifiers.add(callee.node);\n              return;\n            } else {\n              throw new Error(\n                `importSync eager mode only supports dynamic paths which are relative, must start with a '.', had ${specifier.type}`\n              );\n            }\n          }\n          path.replaceWith(\n            t.callExpression(state.importUtil.import(path, state.pathToOurAddon('es-compat2'), 'default', 'esc'), [\n              state.importUtil.import(path, specifier.value, '*'),\n            ])\n          );\n          state.calledIdentifiers.add(callee.node);\n          return;\n        }\n      },\n    },\n    ReferencedIdentifier(path: NodePath<t.Identifier>, state: State) {\n      for (let candidate of [\n        'dependencySatisfies',\n        'moduleExists',\n        'getConfig',\n        'getOwnConfig',\n        'failBuild',\n        // we cannot check importSync, as the babel transform runs on exit, so *after* this check\n        // 'importSync',\n        'isDevelopingApp',\n        'isDevelopingThisPackage',\n        'isTesting',\n      ]) {\n        if (path.referencesImport('@embroider/macros', candidate) && !state.calledIdentifiers.has(path.node)) {\n          throw error(path, `You can only use ${candidate} as a function call`);\n        }\n      }\n\n      if (path.referencesImport('@embroider/macros', 'macroCondition') && !state.calledIdentifiers.has(path.node)) {\n        throw error(path, `macroCondition can only be used as the predicate of an if statement or ternary expression`);\n      }\n\n      if (path.referencesImport('@embroider/macros', 'each') && !state.calledIdentifiers.has(path.node)) {\n        throw error(\n          path,\n          `the each() macro can only be used within a for ... of statement, like: for (let x of each(thing)){}`\n        );\n      }\n\n      if (state.opts.owningPackageRoot) {\n        // there is only an owningPackageRoot when we are running inside a\n        // classic ember-cli build. In the embroider stage3 build, there is no\n        // owning package root because we're compiling *all* packages\n        // simultaneously.\n        //\n        // given that we're inside classic ember-cli, stop here without trying\n        // to rewrite bare `require`. It's not needed, because both our\n        // `importSync` and any user-written bare `require` can both mean the\n        // same thing: runtime AMD `require`.\n        return;\n      }\n\n      if (\n        state.opts.hideRequires &&\n        path.node.name === 'require' &&\n        !path.scope.hasBinding('require') &&\n        state.owningPackage().isEmberAddon()\n      ) {\n        // Our importSync macro has been compiled to `require`. But we want to\n        // distinguish that from any pre-existing, user-written `require` in an\n        // Ember addon, which should retain its *runtime* meaning.\n        path.replaceWith(t.memberExpression(t.identifier('window'), path.node));\n      }\n    },\n  };\n\n  if ((context as any).types.OptionalMemberExpression) {\n    // our getConfig and getOwnConfig macros are supposed to be able to absorb\n    // optional chaining. To make that work we need to see the optional chaining\n    // before preset-env compiles them away.\n    (visitor as any).OptionalMemberExpression = {\n      enter(path: NodePath<t.OptionalMemberExpression>, state: State) {\n        if (state.opts.mode === 'compile-time') {\n          let result = new Evaluator({ state }).evaluate(path);\n          if (result.confident) {\n            path.replaceWith(buildLiterals(result.value, context));\n          }\n        }\n      },\n    };\n  }\n\n  return { visitor };\n}\n"]}