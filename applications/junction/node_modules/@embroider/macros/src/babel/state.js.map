{"version":3,"file":"state.js","sourceRoot":"","sources":["state.ts"],"names":[],"mappings":";;AAiDA,8BAUC;AA1DD,+BAA8C;AAE9C,kEAAgG;AAChG,yDAA+C;AA6C/C,SAAgB,SAAS,CAAC,CAAe,EAAE,IAAmC,EAAE,KAAY;IAC1F,KAAK,CAAC,UAAU,GAAG,IAAI,8BAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IAC3C,KAAK,CAAC,IAAI,GAAG,EAAE,CAAC;IAChB,KAAK,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;IAC1B,KAAK,CAAC,iBAAiB,GAAG,IAAI,GAAG,EAAE,CAAC;IACpC,KAAK,CAAC,YAAY,GAAG,wCAAqB,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IAC1F,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,iBAAiB,IAAI,IAAA,2BAAQ,EAAE,IAAI,CAAC,GAAW,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAClG,KAAK,CAAC,cAAc,GAAG,WAAW,CAAC;IACnC,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;IACpC,KAAK,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;AACtD,CAAC;AAED,MAAM,gBAAgB,GAAG,IAAA,cAAO,EAAC,IAAA,WAAI,EAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;AAEjE,SAAS,WAAW,CAAc,UAAkB;IAClD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACjC,kEAAkE;QAClE,OAAO,IAAA,mCAAgB,EAAC,IAAA,cAAO,EAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAA,WAAI,EAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC,CAAC;IACxF,CAAC;SAAM,CAAC;QACN,sEAAsE;QACtE,aAAa;QACb,EAAE;QACF,qEAAqE;QACrE,yEAAyE;QACzE,4EAA4E;QAC5E,0EAA0E;QAC1E,eAAe;QACf,OAAO,qBAAqB,UAAU,EAAE,CAAC;IAC3C,CAAC;AACH,CAAC;AAED,SAAS,aAAa;IACpB,IAAI,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACzD,IAAI,CAAC,GAAG,EAAE,CAAC;QACT,MAAM,IAAI,KAAK,CAAC,uDAAuD,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC;IAC5F,CAAC;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,qBAAqB;IAC5B,IAAI,GAAG,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;IAC/B,OAAO,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AACzC,CAAC","sourcesContent":["import type { NodePath, Node } from '@babel/traverse';\nimport { join, dirname, resolve } from 'path';\nimport type { Package } from '@embroider/shared-internals';\nimport { cleanUrl, explicitRelative, RewrittenPackageCache } from '@embroider/shared-internals';\nimport { ImportUtil } from 'babel-import-util';\nimport type * as Babel from '@babel/core';\n\nexport default interface State {\n  importUtil: ImportUtil;\n  removed: Set<Node>;\n  calledIdentifiers: Set<Node>;\n  jobs: (() => void)[];\n  packageCache: RewrittenPackageCache;\n  sourceFile: string;\n  pathToOurAddon(moduleName: string): string;\n  owningPackage(): Package;\n  originalOwningPackage(): Package;\n\n  opts: {\n    userConfigs: {\n      [pkgRoot: string]: unknown;\n    };\n    globalConfig: {\n      [key: string]: unknown;\n    };\n    // we set this when we're running inside classic ember-cli, because in that\n    // case we don't have finer-grained info available about where the files\n    // we're processing are globally located. When running in embroider, we\n    // don't set this, because each file is visible at its full\n    // globally-relevant path.\n    owningPackageRoot: string | undefined;\n\n    // list of packages that are under active development, represented by the\n    // path to their package root directory\n    isDevelopingPackageRoots: string[];\n\n    // the package root directory of the app. Needed so that we can get\n    // consistent answers to `isDevelopingApp` and `isDeveopingThisPackage`, as\n    // well as consistent handling of Package devDependencies vs dependencies.\n    appPackageRoot: string;\n\n    embroiderMacrosConfigMarker: true;\n\n    hideRequires: boolean;\n\n    mode: 'compile-time' | 'run-time';\n  };\n}\n\nexport function initState(t: typeof Babel, path: NodePath<Babel.types.Program>, state: State) {\n  state.importUtil = new ImportUtil(t, path);\n  state.jobs = [];\n  state.removed = new Set();\n  state.calledIdentifiers = new Set();\n  state.packageCache = RewrittenPackageCache.shared('embroider', state.opts.appPackageRoot);\n  state.sourceFile = state.opts.owningPackageRoot || cleanUrl((path.hub as any).file.opts.filename);\n  state.pathToOurAddon = pathToAddon;\n  state.owningPackage = owningPackage;\n  state.originalOwningPackage = originalOwningPackage;\n}\n\nconst runtimeAddonPath = resolve(join(__dirname, '..', 'addon'));\n\nfunction pathToAddon(this: State, moduleName: string): string {\n  if (!this.opts.owningPackageRoot) {\n    // running inside embroider, so make a relative path to the module\n    return explicitRelative(dirname(this.sourceFile), join(runtimeAddonPath, moduleName));\n  } else {\n    // running inside a classic build, so use a classic-compatible runtime\n    // specifier.\n    //\n    // CAUTION: the module we're pointing at here gets merged between all\n    // present versions of @embroider/macros, and one will win. So if you are\n    // introducing incompatible changes to its API, you need to change this name\n    // (by tacking on a version number, etc) and rename the corresponding file\n    // in ../addon.\n    return `@embroider/macros/${moduleName}`;\n  }\n}\n\nfunction owningPackage(this: State): Package {\n  let pkg = this.packageCache.ownerOfFile(this.sourceFile);\n  if (!pkg) {\n    throw new Error(`unable to determine which npm package owns the file ${this.sourceFile}`);\n  }\n  return pkg;\n}\n\nfunction originalOwningPackage(this: State): Package {\n  let pkg = this.owningPackage();\n  return this.packageCache.original(pkg);\n}\n"]}