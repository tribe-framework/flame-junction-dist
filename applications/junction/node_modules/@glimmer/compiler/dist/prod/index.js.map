{"version":3,"file":"index.js","sources":["../../lib/builder/builder-interface.ts","../../lib/builder/builder.ts","../../lib/passes/2-encoding/mir.ts","../../lib/shared/list.ts","../../lib/shared/result.ts","../../lib/passes/1-normalization/visitors/expressions.ts","../../lib/passes/1-normalization/keywords/impl.ts","../../lib/passes/1-normalization/keywords/utils/call-to-append.ts","../../lib/passes/1-normalization/keywords/utils/curry.ts","../../lib/passes/1-normalization/keywords/utils/dynamic-vars.ts","../../lib/passes/1-normalization/keywords/utils/has-block.ts","../../lib/passes/1-normalization/keywords/utils/if-unless.ts","../../lib/passes/1-normalization/keywords/utils/log.ts","../../lib/passes/1-normalization/keywords/append.ts","../../lib/passes/1-normalization/keywords/block.ts","../../lib/passes/1-normalization/keywords/call.ts","../../lib/passes/1-normalization/keywords/modifier.ts","../../lib/utils.ts","../../lib/passes/1-normalization/visitors/element/classified.ts","../../lib/passes/1-normalization/visitors/element/component.ts","../../lib/passes/1-normalization/visitors/element/simple-element.ts","../../lib/passes/1-normalization/visitors/statements.ts","../../lib/passes/1-normalization/context.ts","../../lib/passes/1-normalization/visitors/strict-mode.ts","../../lib/wire-format-debug.ts","../../lib/passes/2-encoding/expressions.ts","../../lib/passes/2-encoding/content.ts","../../lib/compiler.ts","../../lib/passes/1-normalization/index.ts","../../lib/passes/2-encoding/index.ts"],"sourcesContent":["import type { Dict, DictValue, Nullable, PresentArray } from '@glimmer/interfaces';\nimport { assertNever, dict, expect, isPresentArray } from '@glimmer/util';\n\nexport type BuilderParams = BuilderExpression[];\nexport type BuilderHash = Nullable<Dict<BuilderExpression>>;\nexport type BuilderBlockHash = BuilderHash | { as: string | string[] };\nexport type BuilderBlocks = Dict<BuilderBlock>;\nexport type BuilderAttrs = Dict<BuilderAttr>;\n\nexport type NormalizedParams = NormalizedExpression[];\nexport type NormalizedHash = Dict<NormalizedExpression>;\nexport type NormalizedBlock = NormalizedStatement[];\nexport type NormalizedBlocks = Dict<NormalizedBlock>;\nexport type NormalizedAttrs = Dict<NormalizedAttr>;\nexport type NormalizedAttr = HeadKind.Splat | NormalizedExpression;\n\nexport interface NormalizedElement {\n  name: string;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport interface NormalizedAngleInvocation {\n  head: NormalizedExpression;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport enum HeadKind {\n  Block = 'Block',\n  Call = 'Call',\n  Element = 'Element',\n  AppendPath = 'AppendPath',\n  AppendExpr = 'AppendExpr',\n  Literal = 'Literal',\n  Modifier = 'Modifier',\n  DynamicComponent = 'DynamicComponent',\n  Comment = 'Comment',\n  Splat = 'Splat',\n  Keyword = 'Keyword',\n}\n\nexport enum VariableKind {\n  Local = 'Local',\n  Free = 'Free',\n  Arg = 'Arg',\n  Block = 'Block',\n  This = 'This',\n}\n\nexport interface Variable {\n  kind: VariableKind;\n  name: string;\n  /**\n   * Differences:\n   *\n   * - strict mode variables always refer to in-scope variables\n   * - loose mode variables use this algorithm:\n   *   1. otherwise, fall back to `this.<name>`\n   */\n  mode: 'loose' | 'strict';\n}\n\nexport interface Path {\n  head: Variable;\n  tail: PresentArray<string>;\n}\n\nexport interface AppendExpr {\n  kind: HeadKind.AppendExpr;\n  expr: NormalizedExpression;\n  trusted: boolean;\n}\n\nexport interface AppendPath {\n  kind: HeadKind.AppendPath;\n  path: NormalizedPath;\n  trusted: boolean;\n}\n\nexport interface NormalizedKeywordStatement {\n  kind: HeadKind.Keyword;\n  name: string;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport type NormalizedStatement =\n  | {\n      kind: HeadKind.Call;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      trusted: boolean;\n    }\n  | {\n      kind: HeadKind.Block;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      blockParams: Nullable<string[]>;\n      blocks: NormalizedBlocks;\n    }\n  | NormalizedKeywordStatement\n  | {\n      kind: HeadKind.Element;\n      name: string;\n      attrs: NormalizedAttrs;\n      block: NormalizedBlock;\n    }\n  | { kind: HeadKind.Comment; value: string }\n  | { kind: HeadKind.Literal; value: string }\n  | AppendPath\n  | AppendExpr\n  | { kind: HeadKind.Modifier; params: NormalizedParams; hash: Nullable<NormalizedHash> }\n  | {\n      kind: HeadKind.DynamicComponent;\n      expr: NormalizedExpression;\n      hash: Nullable<NormalizedHash>;\n      block: NormalizedBlock;\n    };\n\nexport function normalizeStatement(statement: BuilderStatement): NormalizedStatement {\n  if (Array.isArray(statement)) {\n    if (statementIsExpression(statement)) {\n      return normalizeAppendExpression(statement);\n    } else if (isSugaryArrayStatement(statement)) {\n      return normalizeSugaryArrayStatement(statement);\n    } else {\n      return normalizeVerboseStatement(statement);\n    }\n  } else if (typeof statement === 'string') {\n    return normalizeAppendHead(normalizeDottedPath(statement), false);\n  } else {\n    throw assertNever(statement);\n  }\n}\n\nexport function normalizeAppendHead(\n  head: NormalizedHead,\n  trusted: boolean\n): AppendExpr | AppendPath {\n  if (head.type === ExpressionKind.GetPath) {\n    return {\n      kind: HeadKind.AppendPath,\n      path: head,\n      trusted,\n    };\n  } else {\n    return {\n      kind: HeadKind.AppendExpr,\n      expr: head,\n      trusted,\n    };\n  }\n}\n\nfunction isSugaryArrayStatement(statement: BuilderStatement): statement is SugaryArrayStatement {\n  if (Array.isArray(statement) && typeof statement[0] === 'string') {\n    switch (statement[0][0]) {\n      case '(':\n      case '#':\n      case '<':\n      case '!':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\nexport type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;\n\nexport function normalizeSugaryArrayStatement(\n  statement: SugaryArrayStatement\n): NormalizedStatement {\n  const name = statement[0];\n\n  switch (name[0]) {\n    case '(': {\n      let params: Nullable<NormalizedParams> = null;\n      let hash: Nullable<NormalizedHash> = null;\n\n      if (statement.length === 3) {\n        params = normalizeParams(statement[1] as Params);\n        hash = normalizeHash(statement[2] as Hash);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          params = normalizeParams(statement[1] as Params);\n        } else {\n          hash = normalizeHash(statement[1] as Hash);\n        }\n      }\n\n      return {\n        kind: HeadKind.Call,\n        head: normalizeCallHead(name),\n        params,\n        hash,\n        trusted: false,\n      };\n    }\n\n    case '#': {\n      const {\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      } = normalizeBuilderBlockStatement(statement as BuilderBlockStatement);\n\n      return {\n        kind: HeadKind.Block,\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '!': {\n      const name = statement[0].slice(1);\n      const { params, hash, blocks, blockParams } = normalizeBuilderBlockStatement(\n        statement as BuilderBlockStatement\n      );\n\n      return {\n        kind: HeadKind.Keyword,\n        name,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '<': {\n      let attrs: NormalizedAttrs = dict();\n      let block: NormalizedBlock = [];\n\n      if (statement.length === 3) {\n        attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        block = normalizeBlock(statement[2] as BuilderBlock);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          block = normalizeBlock(statement[1] as BuilderBlock);\n        } else {\n          attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        }\n      }\n\n      return {\n        kind: HeadKind.Element,\n        name: expect(extractElement(name), `BUG: expected ${name} to look like a tag name`),\n        attrs,\n        block,\n      };\n    }\n\n    default:\n      throw new Error(`Unreachable ${JSON.stringify(statement)} in normalizeSugaryArrayStatement`);\n  }\n}\n\nfunction normalizeVerboseStatement(statement: VerboseStatement): NormalizedStatement {\n  switch (statement[0]) {\n    case Builder.Literal: {\n      return {\n        kind: HeadKind.Literal,\n        value: statement[1],\n      };\n    }\n\n    case Builder.Append: {\n      return normalizeAppendExpression(statement[1], statement[2]);\n    }\n\n    case Builder.Modifier: {\n      return {\n        kind: HeadKind.Modifier,\n        params: normalizeParams(statement[1]),\n        hash: normalizeHash(statement[2]),\n      };\n    }\n\n    case Builder.DynamicComponent: {\n      return {\n        kind: HeadKind.DynamicComponent,\n        expr: normalizeExpression(statement[1]),\n        hash: normalizeHash(statement[2]),\n        block: normalizeBlock(statement[3]),\n      };\n    }\n\n    case Builder.Comment: {\n      return {\n        kind: HeadKind.Comment,\n        value: statement[1],\n      };\n    }\n  }\n}\n\nfunction extractBlockHead(name: string): NormalizedHead {\n  const result = /^(#|!)(.*)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing # in block head`);\n  }\n\n  return normalizeDottedPath(result[2] as string);\n}\n\nfunction normalizeCallHead(name: string): NormalizedHead {\n  const result = /^\\((.*)\\)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing () in call head`);\n  }\n\n  return normalizeDottedPath(result[1] as string);\n}\n\nfunction normalizePath(head: string, tail: string[] = []): NormalizedHead {\n  const pathHead = normalizePathHead(head);\n\n  if (isPresentArray(tail)) {\n    return {\n      type: ExpressionKind.GetPath,\n      path: {\n        head: pathHead,\n        tail,\n      },\n    };\n  } else {\n    return {\n      type: ExpressionKind.GetVar,\n      variable: pathHead,\n    };\n  }\n}\n\nfunction normalizeDottedPath(whole: string): NormalizedHead {\n  const { kind, name: rest } = normalizePathHead(whole);\n\n  const [name, ...tail] = rest.split('.') as [string, ...string[]];\n\n  const variable: Variable = { kind, name, mode: 'loose' };\n\n  if (isPresentArray(tail)) {\n    return { type: ExpressionKind.GetPath, path: { head: variable, tail } };\n  } else {\n    return { type: ExpressionKind.GetVar, variable };\n  }\n}\n\nexport function normalizePathHead(whole: string): Variable {\n  let kind: VariableKind;\n  let name: string;\n\n  if (/^this(?:\\.|$)/u.test(whole)) {\n    return {\n      kind: VariableKind.This,\n      name: whole,\n      mode: 'loose',\n    };\n  }\n\n  switch (whole[0]) {\n    case '^':\n      kind = VariableKind.Free;\n      name = whole.slice(1);\n      break;\n\n    case '@':\n      kind = VariableKind.Arg;\n      name = whole.slice(1);\n      break;\n\n    case '&':\n      kind = VariableKind.Block;\n      name = whole.slice(1);\n      break;\n\n    default:\n      kind = VariableKind.Local;\n      name = whole;\n  }\n\n  return { kind, name, mode: 'loose' };\n}\n\nexport type BuilderBlockStatement =\n  | [string, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams | BuilderBlockHash, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams, BuilderBlockHash, BuilderBlock | BuilderBlocks];\n\nexport interface NormalizedBuilderBlockStatement {\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport function normalizeBuilderBlockStatement(\n  statement: BuilderBlockStatement\n): NormalizedBuilderBlockStatement {\n  const head = statement[0];\n  let blocks: NormalizedBlocks = dict();\n  let params: Nullable<NormalizedParams> = null;\n  let hash: Nullable<NormalizedHash> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  if (statement.length === 2) {\n    blocks = normalizeBlocks(statement[1]);\n  } else if (statement.length === 3) {\n    if (Array.isArray(statement[1])) {\n      params = normalizeParams(statement[1]);\n    } else {\n      ({ hash, blockParams } = normalizeBlockHash(statement[1]));\n    }\n\n    blocks = normalizeBlocks(statement[2]);\n  } else if (statement.length === 4) {\n    params = normalizeParams(statement[1]);\n    ({ hash, blockParams } = normalizeBlockHash(statement[2]));\n    blocks = normalizeBlocks(statement[3]);\n  }\n\n  return {\n    head: extractBlockHead(head),\n    params,\n    hash,\n    blockParams,\n    blocks,\n  };\n}\n\nfunction normalizeBlockHash(hash: BuilderBlockHash): {\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n} {\n  if (hash === null) {\n    return { hash: null, blockParams: null };\n  }\n\n  let out: Nullable<Dict<NormalizedExpression>> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  entries(hash, (key, value) => {\n    if (key === 'as') {\n      blockParams = Array.isArray(value) ? (value as string[]) : [value as string];\n    } else {\n      out = out || dict();\n      out[key] = normalizeExpression(value as BuilderExpression);\n    }\n  });\n\n  return { hash: out, blockParams };\n}\n\nexport function entries<D extends Dict>(\n  dict: D,\n  callback: <K extends keyof D>(key: K, value: D[K]) => void\n): void {\n  Object.keys(dict).forEach((key) => {\n    const value = dict[key];\n    callback(key, value as D[keyof D]);\n  });\n}\n\nfunction normalizeBlocks(value: BuilderBlock | BuilderBlocks): NormalizedBlocks {\n  if (Array.isArray(value)) {\n    return { default: normalizeBlock(value) };\n  } else {\n    return mapObject(value, normalizeBlock);\n  }\n}\n\nfunction normalizeBlock(block: BuilderBlock): NormalizedBlock {\n  return block.map((s) => normalizeStatement(s));\n}\n\nfunction normalizeAttrs(attrs: BuilderAttrs): NormalizedAttrs {\n  return mapObject(attrs, (a) => normalizeAttr(a).expr);\n}\n\nfunction normalizeAttr(attr: BuilderAttr): { expr: NormalizedAttr; trusted: boolean } {\n  if (attr === 'splat') {\n    return { expr: HeadKind.Splat, trusted: false };\n  } else {\n    const expr = normalizeExpression(attr);\n    return { expr, trusted: false };\n  }\n}\n\nfunction mapObject<T extends Dict<unknown>, Out>(\n  object: T,\n  mapper: (value: DictValue<T>, key: keyof T) => Out\n): { [P in keyof T]: Out } {\n  const out = dict() as { [P in keyof T]?: Out };\n\n  Object.keys(object).forEach(<K extends keyof T>(k: K) => {\n    out[k] = mapper(object[k] as DictValue<T>, k);\n  });\n\n  return out as { [P in keyof T]: Out };\n}\n\nexport type BuilderElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport type BuilderComment = [Builder.Comment, string];\n\nexport type InvocationElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport function isElement(input: [string, ...unknown[]]): input is BuilderElement {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function extractElement(input: string): Nullable<string> {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input);\n\n  return match?.[1] ?? null;\n}\n\nexport function isAngleInvocation(input: [string, ...unknown[]]): input is InvocationElement {\n  // TODO Paths\n  const match = /^<(@[\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function isBlock(input: [string, ...unknown[]]): input is BuilderBlockStatement {\n  // TODO Paths\n  const match = /^#[\\s\\S]?([\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport enum Builder {\n  Literal,\n  Comment,\n  Append,\n  Modifier,\n  DynamicComponent,\n  Get,\n  Concat,\n  HasBlock,\n  HasBlockParams,\n}\n\nexport type VerboseStatement =\n  | [Builder.Literal, string]\n  | [Builder.Comment, string]\n  | [Builder.Append, BuilderExpression, true]\n  | [Builder.Append, BuilderExpression]\n  | [Builder.Modifier, Params, Hash]\n  | [Builder.DynamicComponent, BuilderExpression, Hash, BuilderBlock];\n\nexport type BuilderStatement =\n  | VerboseStatement\n  | SugaryArrayStatement\n  | TupleBuilderExpression\n  | string;\n\nexport type BuilderAttr = 'splat' | BuilderExpression;\n\nexport type TupleBuilderExpression =\n  | [Builder.Literal, string | boolean | null | undefined]\n  | [Builder.Get, string]\n  | [Builder.Get, string, string[]]\n  | [Builder.Concat, ...BuilderExpression[]]\n  | [Builder.HasBlock, string]\n  | [Builder.HasBlockParams, string]\n  | BuilderCallExpression;\n\ntype Params = BuilderParams;\ntype Hash = Dict<BuilderExpression>;\n\nexport enum ExpressionKind {\n  Literal = 'Literal',\n  Call = 'Call',\n  GetPath = 'GetPath',\n  GetVar = 'GetVar',\n  Concat = 'Concat',\n  HasBlock = 'HasBlock',\n  HasBlockParams = 'HasBlockParams',\n}\n\nexport interface NormalizedCallExpression {\n  type: ExpressionKind.Call;\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n}\n\nexport interface NormalizedPath {\n  type: ExpressionKind.GetPath;\n  path: Path;\n}\n\nexport interface NormalizedVar {\n  type: ExpressionKind.GetVar;\n  variable: Variable;\n}\n\nexport type NormalizedHead = NormalizedPath | NormalizedVar;\n\nexport interface NormalizedConcat {\n  type: ExpressionKind.Concat;\n  params: [NormalizedExpression, ...NormalizedExpression[]];\n}\n\nexport type NormalizedExpression =\n  | {\n      type: ExpressionKind.Literal;\n      value: null | undefined | boolean | string | number;\n    }\n  | NormalizedCallExpression\n  | NormalizedPath\n  | NormalizedVar\n  | NormalizedConcat\n  | {\n      type: ExpressionKind.HasBlock;\n      name: string;\n    }\n  | {\n      type: ExpressionKind.HasBlockParams;\n      name: string;\n    };\n\nexport function normalizeAppendExpression(\n  expression: BuilderExpression,\n  forceTrusted = false\n): AppendExpr | AppendPath {\n  if (expression === null || expression === undefined) {\n    return {\n      expr: {\n        type: ExpressionKind.Literal,\n        value: expression,\n      },\n      kind: HeadKind.AppendExpr,\n      trusted: false,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression[1] },\n          kind: HeadKind.AppendExpr,\n          trusted: false,\n        };\n\n      case Builder.Get: {\n        return normalizeAppendHead(normalizePath(expression[1], expression[2]), forceTrusted);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return {\n          expr,\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n      }\n\n      case Builder.HasBlock:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlock,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlockParams,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return {\n            expr: normalizeCallExpression(expression),\n            kind: HeadKind.AppendExpr,\n            trusted: forceTrusted,\n          };\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeAppendHead(normalizeDottedPath(expression), forceTrusted);\n      }\n      case 'boolean':\n      case 'number':\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression },\n          kind: HeadKind.AppendExpr,\n          trusted: true,\n        };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\nexport function normalizeExpression(expression: BuilderExpression): NormalizedExpression {\n  if (expression === null || expression === undefined) {\n    return {\n      type: ExpressionKind.Literal,\n      value: expression,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return { type: ExpressionKind.Literal, value: expression[1] };\n\n      case Builder.Get: {\n        return normalizePath(expression[1], expression[2]);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return expr;\n      }\n\n      case Builder.HasBlock:\n        return {\n          type: ExpressionKind.HasBlock,\n          name: expression[1],\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          type: ExpressionKind.HasBlockParams,\n          name: expression[1],\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return normalizeCallExpression(expression);\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeDottedPath(expression);\n      }\n      case 'boolean':\n      case 'number':\n        return { type: ExpressionKind.Literal, value: expression };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\n// | [Builder.Get, string]\n// | [Builder.Get, string, string[]]\n// | [Builder.Concat, Params]\n// | [Builder.HasBlock, string]\n// | [Builder.HasBlockParams, string]\n\nexport type BuilderExpression =\n  | TupleBuilderExpression\n  | BuilderCallExpression\n  | null\n  | undefined\n  | boolean\n  | string\n  | number;\n\nexport function isBuilderExpression(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is TupleBuilderExpression | BuilderCallExpression {\n  return Array.isArray(expr);\n}\n\nexport function isLiteral(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is [Builder.Literal, string | boolean | undefined] {\n  return Array.isArray(expr) && expr[0] === 'literal';\n}\n\nexport function statementIsExpression(\n  statement: BuilderStatement\n): statement is TupleBuilderExpression {\n  if (!Array.isArray(statement)) {\n    return false;\n  }\n\n  const name = statement[0];\n\n  if (typeof name === 'number') {\n    switch (name) {\n      case Builder.Literal:\n      case Builder.Get:\n      case Builder.Concat:\n      case Builder.HasBlock:\n      case Builder.HasBlockParams:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  if (name[0] === '(') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isBuilderCallExpression(\n  value: TupleBuilderExpression | BuilderCallExpression\n): value is BuilderCallExpression {\n  return typeof value[0] === 'string' && value[0][0] === '(';\n}\n\nexport type MiniBuilderBlock = BuilderStatement[];\n\nexport type BuilderBlock = MiniBuilderBlock;\n\nexport type BuilderCallExpression = [string] | [string, Params | Hash] | [string, Params, Hash];\n\nexport function normalizeParams(input: Params): NormalizedParams {\n  return input.map(normalizeExpression);\n}\n\nexport function normalizeHash(input: Nullable<Hash>): Nullable<NormalizedHash> {\n  if (input === null) return null;\n  return mapObject(input, normalizeExpression);\n}\n\nexport function normalizeCallExpression(expr: BuilderCallExpression): NormalizedCallExpression {\n  switch (expr.length) {\n    case 1:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: null,\n        hash: null,\n      };\n    case 2: {\n      if (Array.isArray(expr[1])) {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: normalizeParams(expr[1]),\n          hash: null,\n        };\n      } else {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: null,\n          hash: normalizeHash(expr[1]),\n        };\n      }\n    }\n\n    case 3:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: normalizeParams(expr[1]),\n        hash: normalizeHash(expr[2]),\n      };\n  }\n}\n","import type {\n  AttrNamespace,\n  Dict,\n  Expressions,\n  GetContextualFreeOpcode,\n  Nullable,\n  PresentArray,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport {\n  assert,\n  assertNever,\n  dict,\n  exhausted,\n  expect,\n  isPresentArray,\n  NS_XLINK,\n  NS_XML,\n  NS_XMLNS,\n  values,\n} from '@glimmer/util';\nimport { SexpOpcodes as Op, VariableResolutionContext } from '@glimmer/wire-format';\n\nimport type {\n  BuilderComment,\n  BuilderStatement,\n  NormalizedAngleInvocation,\n  NormalizedAttrs,\n  NormalizedBlock,\n  NormalizedBlocks,\n  NormalizedElement,\n  NormalizedExpression,\n  NormalizedHash,\n  NormalizedHead,\n  NormalizedKeywordStatement,\n  NormalizedParams,\n  NormalizedPath,\n  NormalizedStatement,\n  Variable,\n} from './builder-interface';\n\nimport {\n  Builder,\n  ExpressionKind,\n  HeadKind,\n  normalizeStatement,\n  VariableKind,\n} from './builder-interface';\n\ninterface Symbols {\n  top: ProgramSymbols;\n  freeVar(name: string): number;\n  arg(name: string): number;\n  block(name: string): number;\n  local(name: string): number;\n  this(): number;\n\n  hasLocal(name: string): boolean;\n\n  child(params: string[]): LocalSymbols;\n}\n\nexport class ProgramSymbols implements Symbols {\n  _freeVariables: string[] = [];\n  _symbols: string[] = ['this'];\n\n  top = this;\n\n  toSymbols(): string[] {\n    return this._symbols.slice(1);\n  }\n\n  toUpvars(): string[] {\n    return this._freeVariables;\n  }\n\n  freeVar(name: string): number {\n    return addString(this._freeVariables, name);\n  }\n\n  block(name: string): number {\n    return this.symbol(name);\n  }\n\n  arg(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  local(name: string): never {\n    throw new Error(\n      `No local ${name} was found. Maybe you meant ^${name} for upvar, or !${name} for keyword?`\n    );\n  }\n\n  this(): number {\n    return 0;\n  }\n\n  hasLocal(_name: string): false {\n    return false;\n  }\n\n  // any symbol\n  symbol(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nclass LocalSymbols implements Symbols {\n  private locals: Dict<number> = dict();\n\n  constructor(\n    private parent: Symbols,\n    locals: string[]\n  ) {\n    for (let local of locals) {\n      this.locals[local] = parent.top.symbol(local);\n    }\n  }\n\n  get paramSymbols(): number[] {\n    return values(this.locals);\n  }\n\n  get top(): ProgramSymbols {\n    return this.parent.top;\n  }\n\n  freeVar(name: string): number {\n    return this.parent.freeVar(name);\n  }\n\n  arg(name: string): number {\n    return this.parent.arg(name);\n  }\n\n  block(name: string): number {\n    return this.parent.block(name);\n  }\n\n  local(name: string): number {\n    if (name in this.locals) {\n      return this.locals[name] as number;\n    } else {\n      return this.parent.local(name);\n    }\n  }\n\n  this(): number {\n    return this.parent.this();\n  }\n\n  hasLocal(name: string): boolean {\n    if (name in this.locals) {\n      return true;\n    } else {\n      return this.parent.hasLocal(name);\n    }\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nfunction addString(array: string[], item: string): number {\n  let index = array.indexOf(item);\n\n  if (index === -1) {\n    index = array.length;\n    array.push(item);\n    return index;\n  } else {\n    return index;\n  }\n}\n\nexport interface BuilderGetFree {\n  type: 'GetFree';\n  head: string;\n  tail: string[];\n}\n\nfunction unimpl(message: string): Error {\n  return new Error(`unimplemented ${message}`);\n}\n\nexport function buildStatements(\n  statements: BuilderStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(normalizeStatement(s), symbols)));\n\n  return out;\n}\n\nexport function buildNormalizedStatements(\n  statements: NormalizedStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(s, symbols)));\n\n  return out;\n}\n\nexport function buildStatement(\n  normalized: NormalizedStatement,\n  symbols: Symbols = new ProgramSymbols()\n): WireFormat.Statement[] {\n  switch (normalized.kind) {\n    case HeadKind.AppendPath: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildGetPath(normalized.path, symbols),\n        ],\n      ];\n    }\n\n    case HeadKind.AppendExpr: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildExpression(\n            normalized.expr,\n            normalized.trusted ? 'TrustedAppend' : 'Append',\n            symbols\n          ),\n        ],\n      ];\n    }\n\n    case HeadKind.Call: {\n      let { head: path, params, hash, trusted } = normalized;\n      let builtParams: Nullable<WireFormat.Core.Params> = params\n        ? buildParams(params, symbols)\n        : null;\n      let builtHash: WireFormat.Core.Hash = hash ? buildHash(hash, symbols) : null;\n      let builtExpr: WireFormat.Expression = buildCallHead(\n        path,\n        trusted\n          ? VariableResolutionContext.ResolveAsHelperHead\n          : VariableResolutionContext.ResolveAsComponentOrHelperHead,\n        symbols\n      );\n\n      return [\n        [trusted ? Op.TrustingAppend : Op.Append, [Op.Call, builtExpr, builtParams, builtHash]],\n      ];\n    }\n\n    case HeadKind.Literal: {\n      return [[Op.Append, normalized.value]];\n    }\n\n    case HeadKind.Comment: {\n      return [[Op.Comment, normalized.value]];\n    }\n\n    case HeadKind.Block: {\n      let blocks = buildBlocks(normalized.blocks, normalized.blockParams, symbols);\n      let hash = buildHash(normalized.hash, symbols);\n      let params = buildParams(normalized.params, symbols);\n      let path = buildCallHead(\n        normalized.head,\n        VariableResolutionContext.ResolveAsComponentHead,\n        symbols\n      );\n\n      return [[Op.Block, path, params, hash, blocks]];\n    }\n\n    case HeadKind.Keyword: {\n      return [buildKeyword(normalized, symbols)];\n    }\n\n    case HeadKind.Element:\n      return buildElement(normalized, symbols);\n\n    case HeadKind.Modifier:\n      throw unimpl('modifier');\n\n    case HeadKind.DynamicComponent:\n      throw unimpl('dynamic component');\n\n    default:\n      throw assertNever(normalized);\n  }\n}\n\nexport function s(\n  arr: TemplateStringsArray,\n  ...interpolated: unknown[]\n): [Builder.Literal, string] {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Literal, result];\n}\n\nexport function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Comment, result];\n}\n\nexport function unicode(charCode: string): string {\n  return String.fromCharCode(parseInt(charCode, 16));\n}\n\nexport const NEWLINE = '\\n';\n\nfunction buildKeyword(\n  normalized: NormalizedKeywordStatement,\n  symbols: Symbols\n): WireFormat.Statement {\n  let { name } = normalized;\n  let params = buildParams(normalized.params, symbols);\n  let childSymbols = symbols.child(normalized.blockParams || []);\n\n  let block = buildBlock(\n    normalized.blocks['default'] as NormalizedBlock,\n    childSymbols,\n    childSymbols.paramSymbols\n  );\n  let inverse = normalized.blocks['else']\n    ? buildBlock(normalized.blocks['else'], symbols, [])\n    : null;\n\n  switch (name) {\n    case 'let':\n      return [Op.Let, expect(params, 'let requires params'), block];\n    case 'if':\n      return [Op.If, expect(params, 'if requires params')[0], block, inverse];\n    case 'each': {\n      let keyExpr = normalized.hash ? normalized.hash['key'] : null;\n      let key = keyExpr ? buildExpression(keyExpr, 'Strict', symbols) : null;\n      return [Op.Each, expect(params, 'if requires params')[0], key, block, inverse];\n    }\n\n    default:\n      throw new Error('unimplemented keyword');\n  }\n}\n\nfunction buildElement(\n  { name, attrs, block }: NormalizedElement,\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [\n    hasSplat(attrs) ? [Op.OpenElementWithSplat, name] : [Op.OpenElement, name],\n  ];\n  if (attrs) {\n    let { params, args } = buildElementParams(attrs, symbols);\n    out.push(...params);\n    assert(args === null, `Can't pass args to a simple element`);\n  }\n  out.push([Op.FlushElement]);\n\n  if (Array.isArray(block)) {\n    block.forEach((s) => out.push(...buildStatement(s, symbols)));\n  } else if (block === null) {\n    // do nothing\n  } else {\n    throw assertNever(block);\n  }\n\n  out.push([Op.CloseElement]);\n\n  return out;\n}\n\nfunction hasSplat(attrs: Nullable<NormalizedAttrs>): boolean {\n  if (attrs === null) return false;\n\n  return Object.keys(attrs).some((a) => attrs[a] === HeadKind.Splat);\n}\n\nexport function buildAngleInvocation(\n  { attrs, block, head }: NormalizedAngleInvocation,\n  symbols: Symbols\n): WireFormat.Statements.Component {\n  let paramList: WireFormat.ElementParameter[] = [];\n  let args: WireFormat.Core.Hash = null;\n  let blockList: WireFormat.Statement[] = [];\n\n  if (attrs) {\n    let built = buildElementParams(attrs, symbols);\n    paramList = built.params;\n    args = built.args;\n  }\n\n  if (block) blockList = buildNormalizedStatements(block, symbols);\n\n  return [\n    Op.Component,\n    buildExpression(head, VariableResolutionContext.ResolveAsComponentHead, symbols),\n    isPresentArray(paramList) ? paramList : null,\n    args,\n    [['default'], [[blockList, []]]],\n  ];\n}\n\nexport function buildElementParams(\n  attrs: NormalizedAttrs,\n  symbols: Symbols\n): { params: WireFormat.ElementParameter[]; args: WireFormat.Core.Hash } {\n  let params: WireFormat.ElementParameter[] = [];\n  let keys: string[] = [];\n  let values: WireFormat.Expression[] = [];\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (value === HeadKind.Splat) {\n      params.push([Op.AttrSplat, symbols.block('&attrs')]);\n    } else if (key[0] === '@') {\n      keys.push(key);\n      values.push(buildExpression(value, 'Strict', symbols));\n    } else {\n      params.push(\n        ...buildAttributeValue(\n          key,\n          value,\n          // TODO: extract namespace from key\n          extractNamespace(key),\n          symbols\n        )\n      );\n    }\n  }\n\n  return { params, args: isPresentArray(keys) && isPresentArray(values) ? [keys, values] : null };\n}\n\nexport function extractNamespace(name: string): Nullable<AttrNamespace> {\n  if (name === 'xmlns') {\n    return NS_XMLNS;\n  }\n\n  let match = /^([^:]*):([^:]*)$/u.exec(name);\n\n  if (match === null) {\n    return null;\n  }\n\n  let namespace = match[1];\n\n  switch (namespace) {\n    case 'xlink':\n      return NS_XLINK;\n    case 'xml':\n      return NS_XML;\n    case 'xmlns':\n      return NS_XMLNS;\n  }\n\n  return null;\n}\n\nexport function buildAttributeValue(\n  name: string,\n  value: NormalizedExpression,\n  namespace: Nullable<AttrNamespace>,\n  symbols: Symbols\n): WireFormat.Attribute[] {\n  switch (value.type) {\n    case ExpressionKind.Literal: {\n      let val = value.value;\n\n      if (val === false) {\n        return [];\n      } else if (val === true) {\n        return [[Op.StaticAttr, name, '', namespace ?? undefined]];\n      } else if (typeof val === 'string') {\n        return [[Op.StaticAttr, name, val, namespace ?? undefined]];\n      } else {\n        throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(val)}`);\n      }\n    }\n\n    default:\n      return [\n        [\n          Op.DynamicAttr,\n          name,\n          buildExpression(value, 'AttrValue', symbols),\n          namespace ?? undefined,\n        ],\n      ];\n  }\n}\n\ntype ExprResolution =\n  | VariableResolutionContext\n  | 'Append'\n  | 'TrustedAppend'\n  | 'AttrValue'\n  | 'SubExpression'\n  | 'Strict';\n\nfunction varContext(context: ExprResolution, bare: boolean): VarResolution {\n  switch (context) {\n    case 'Append':\n      return bare ? 'AppendBare' : 'AppendInvoke';\n    case 'TrustedAppend':\n      return bare ? 'TrustedAppendBare' : 'TrustedAppendInvoke';\n    case 'AttrValue':\n      return bare ? 'AttrValueBare' : 'AttrValueInvoke';\n    default:\n      return context;\n  }\n}\n\nexport function buildExpression(\n  expr: NormalizedExpression,\n  context: ExprResolution,\n  symbols: Symbols\n): WireFormat.Expression {\n  switch (expr.type) {\n    case ExpressionKind.GetPath: {\n      return buildGetPath(expr, symbols);\n    }\n\n    case ExpressionKind.GetVar: {\n      return buildVar(expr.variable, varContext(context, true), symbols);\n    }\n\n    case ExpressionKind.Concat: {\n      return [Op.Concat, buildConcat(expr.params, symbols)];\n    }\n\n    case ExpressionKind.Call: {\n      let builtParams = buildParams(expr.params, symbols);\n      let builtHash = buildHash(expr.hash, symbols);\n      let builtExpr = buildCallHead(\n        expr.head,\n        context === 'Strict' ? 'SubExpression' : varContext(context, false),\n        symbols\n      );\n\n      return [Op.Call, builtExpr, builtParams, builtHash];\n    }\n\n    case ExpressionKind.HasBlock: {\n      return [\n        Op.HasBlock,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.HasBlockParams: {\n      return [\n        Op.HasBlockParams,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.Literal: {\n      if (expr.value === undefined) {\n        return [Op.Undefined];\n      } else {\n        return expr.value;\n      }\n    }\n\n    default:\n      assertNever(expr);\n  }\n}\n\nexport function buildCallHead(\n  callHead: NormalizedHead,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar | Expressions.GetPath {\n  if (callHead.type === ExpressionKind.GetVar) {\n    return buildVar(callHead.variable, context, symbols);\n  } else {\n    return buildGetPath(callHead, symbols);\n  }\n}\n\nexport function buildGetPath(head: NormalizedPath, symbols: Symbols): Expressions.GetPath {\n  return buildVar(head.path.head, VariableResolutionContext.Strict, symbols, head.path.tail);\n}\n\ntype VarResolution =\n  | VariableResolutionContext\n  | 'AppendBare'\n  | 'AppendInvoke'\n  | 'TrustedAppendBare'\n  | 'TrustedAppendInvoke'\n  | 'AttrValueBare'\n  | 'AttrValueInvoke'\n  | 'SubExpression'\n  | 'Strict';\n\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path: PresentArray<string>\n): Expressions.GetPath;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path?: PresentArray<string>\n): Expressions.GetPath | Expressions.GetVar {\n  let op: Expressions.GetPath[0] | Expressions.GetVar[0] = Op.GetSymbol;\n  let sym: number;\n  switch (head.kind) {\n    case VariableKind.Free:\n      if (context === 'Strict') {\n        op = Op.GetStrictKeyword;\n      } else if (context === 'AppendBare') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'AppendInvoke') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'TrustedAppendBare') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'TrustedAppendInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueBare') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'SubExpression') {\n        op = Op.GetFreeAsHelperHead;\n      } else {\n        op = expressionContextOp(context);\n      }\n      sym = symbols.freeVar(head.name);\n      break;\n    default:\n      op = Op.GetSymbol;\n      sym = getSymbolForVar(head.kind, symbols, head.name);\n  }\n\n  if (path === undefined || path.length === 0) {\n    return [op, sym];\n  } else {\n    assert(op !== Op.GetStrictKeyword, '[BUG] keyword with a path');\n    return [op, sym, path];\n  }\n}\n\nfunction getSymbolForVar(\n  kind: Exclude<VariableKind, VariableKind.Free>,\n  symbols: Symbols,\n  name: string\n) {\n  switch (kind) {\n    case VariableKind.Arg:\n      return symbols.arg(name);\n    case VariableKind.Block:\n      return symbols.block(name);\n    case VariableKind.Local:\n      return symbols.local(name);\n    case VariableKind.This:\n      return symbols.this();\n    default:\n      return exhausted(kind);\n  }\n}\n\nexport function expressionContextOp(context: VariableResolutionContext): GetContextualFreeOpcode {\n  switch (context) {\n    case VariableResolutionContext.Strict:\n      return Op.GetStrictKeyword;\n    case VariableResolutionContext.ResolveAsComponentOrHelperHead:\n      return Op.GetFreeAsComponentOrHelperHead;\n    case VariableResolutionContext.ResolveAsHelperHead:\n      return Op.GetFreeAsHelperHead;\n    case VariableResolutionContext.ResolveAsModifierHead:\n      return Op.GetFreeAsModifierHead;\n    case VariableResolutionContext.ResolveAsComponentHead:\n      return Op.GetFreeAsComponentHead;\n    default:\n      return exhausted(context);\n  }\n}\n\nexport function buildParams(\n  exprs: Nullable<NormalizedParams>,\n  symbols: Symbols\n): Nullable<WireFormat.Core.Params> {\n  if (exprs === null || !isPresentArray(exprs)) return null;\n\n  return exprs.map((e) => buildExpression(e, 'Strict', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildConcat(\n  exprs: [NormalizedExpression, ...NormalizedExpression[]],\n  symbols: Symbols\n): WireFormat.Core.ConcatParams {\n  return exprs.map((e) => buildExpression(e, 'AttrValue', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildHash(exprs: Nullable<NormalizedHash>, symbols: Symbols): WireFormat.Core.Hash {\n  if (exprs === null) return null;\n\n  let out: [string[], WireFormat.Expression[]] = [[], []];\n\n  for (const [key, value] of Object.entries(exprs)) {\n    out[0].push(key);\n    out[1].push(buildExpression(value, 'Strict', symbols));\n  }\n\n  return out as WireFormat.Core.Hash;\n}\n\nexport function buildBlocks(\n  blocks: NormalizedBlocks,\n  blockParams: Nullable<string[]>,\n  parent: Symbols\n): WireFormat.Core.Blocks {\n  let keys: string[] = [];\n  let values: WireFormat.SerializedInlineBlock[] = [];\n\n  for (const [name, block] of Object.entries(blocks)) {\n    keys.push(name);\n\n    if (name === 'default') {\n      let symbols = parent.child(blockParams || []);\n\n      values.push(buildBlock(block, symbols, symbols.paramSymbols));\n    } else {\n      values.push(buildBlock(block, parent, []));\n    }\n  }\n\n  return [keys, values];\n}\n\nfunction buildBlock(\n  block: NormalizedBlock,\n  symbols: Symbols,\n  locals: number[] = []\n): WireFormat.SerializedInlineBlock {\n  return [buildNormalizedStatements(block, symbols), locals];\n}\n","import type { CurriedType, PresentArray } from '@glimmer/interfaces';\nimport type {\n  ASTv2,\n  BlockSymbolTable,\n  ProgramSymbolTable,\n  SourceSlice,\n  SymbolTable,\n} from '@glimmer/syntax';\nimport { node } from '@glimmer/syntax';\n\nimport type { AnyOptionalList, OptionalList, PresentList } from '../../shared/list';\n\nexport class Template extends node('Template').fields<{\n  scope: ProgramSymbolTable;\n  body: Statement[];\n}>() {}\n\nexport class InElement extends node('InElement').fields<{\n  guid: string;\n  insertBefore: ExpressionNode | Missing;\n  destination: ExpressionNode;\n  block: NamedBlock;\n}>() {}\n\nexport class Not extends node('Not').fields<{ value: ExpressionNode }>() {}\n\nexport class If extends node('If').fields<{\n  condition: ExpressionNode;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class IfInline extends node('IfInline').fields<{\n  condition: ExpressionNode;\n  truthy: ExpressionNode;\n  falsy: ExpressionNode | null;\n}>() {}\n\nexport class Each extends node('Each').fields<{\n  value: ExpressionNode;\n  key: ExpressionNode | null;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class Let extends node('Let').fields<{\n  positional: Positional;\n  block: NamedBlock;\n}>() {}\n\nexport class WithDynamicVars extends node('WithDynamicVars').fields<{\n  named: NamedArguments;\n  block: NamedBlock;\n}>() {}\n\nexport class GetDynamicVar extends node('GetDynamicVar').fields<{\n  name: ExpressionNode;\n}>() {}\n\nexport class Log extends node('Log').fields<{\n  positional: Positional;\n}>() {}\n\nexport class InvokeComponent extends node('InvokeComponent').fields<{\n  definition: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks | null;\n}>() {}\n\nexport class NamedBlocks extends node('NamedBlocks').fields<{\n  blocks: OptionalList<NamedBlock>;\n}>() {}\n\nexport class NamedBlock extends node('NamedBlock').fields<{\n  scope: BlockSymbolTable;\n  name: SourceSlice;\n  body: Statement[];\n}>() {}\nexport class AppendTrustedHTML extends node('AppendTrustedHTML').fields<{\n  html: ExpressionNode;\n}>() {}\nexport class AppendTextNode extends node('AppendTextNode').fields<{ text: ExpressionNode }>() {}\nexport class AppendComment extends node('AppendComment').fields<{ value: SourceSlice }>() {}\n\nexport class Component extends node('Component').fields<{\n  tag: ExpressionNode;\n  params: ElementParameters;\n  args: NamedArguments;\n  blocks: NamedBlocks;\n}>() {}\n\nexport interface AttrKind {\n  // triple-curly\n  trusting: boolean;\n  // this attribute is on an element with component features:\n  //   - <CapCase ...>\n  //   - modifiers\n  //   - <dynamic.tag ...>\n  component: boolean;\n}\n\nexport class StaticAttr extends node('StaticAttr').fields<{\n  kind: { component: boolean };\n  name: SourceSlice;\n  value: SourceSlice;\n  namespace?: string | undefined;\n}>() {}\n\nexport class DynamicAttr extends node('DynamicAttr').fields<{\n  kind: AttrKind;\n  name: SourceSlice;\n  value: ExpressionNode;\n  namespace?: string | undefined;\n}>() {}\n\nexport class SimpleElement extends node('SimpleElement').fields<{\n  tag: SourceSlice;\n  params: ElementParameters;\n  body: Statement[];\n  dynamicFeatures: boolean;\n}>() {}\n\nexport class ElementParameters extends node('ElementParameters').fields<{\n  body: AnyOptionalList<ElementParameter>;\n}>() {}\n\nexport class Yield extends node('Yield').fields<{\n  target: SourceSlice;\n  to: number;\n  positional: Positional;\n}>() {}\nexport class Debugger extends node('Debugger').fields<{ scope: SymbolTable }>() {}\n\nexport class CallExpression extends node('CallExpression').fields<{\n  callee: ExpressionNode;\n  args: Args;\n}>() {}\n\nexport class Modifier extends node('Modifier').fields<{ callee: ExpressionNode; args: Args }>() {}\nexport class InvokeBlock extends node('InvokeBlock').fields<{\n  head: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks;\n}>() {}\nexport class SplatAttr extends node('SplatAttr').fields<{ symbol: number }>() {}\nexport class PathExpression extends node('PathExpression').fields<{\n  head: ExpressionNode;\n  tail: Tail;\n}>() {}\n\nexport class Missing extends node('Missing').fields() {}\nexport class InterpolateExpression extends node('InterpolateExpression').fields<{\n  parts: PresentList<ExpressionNode>;\n}>() {}\nexport class HasBlock extends node('HasBlock').fields<{ target: SourceSlice; symbol: number }>() {}\nexport class HasBlockParams extends node('HasBlockParams').fields<{\n  target: SourceSlice;\n  symbol: number;\n}>() {}\nexport class Curry extends node('Curry').fields<{\n  definition: ExpressionNode;\n  curriedType: CurriedType;\n  args: Args;\n}>() {}\nexport class Positional extends node('Positional').fields<{\n  list: OptionalList<ExpressionNode>;\n}>() {}\nexport class NamedArguments extends node('NamedArguments').fields<{\n  entries: OptionalList<NamedArgument>;\n}>() {}\nexport class NamedArgument extends node('NamedArgument').fields<{\n  key: SourceSlice;\n  value: ExpressionNode;\n}>() {}\nexport class Args extends node('Args').fields<{\n  positional: Positional;\n  named: NamedArguments;\n}>() {}\nexport class Tail extends node('Tail').fields<{ members: PresentArray<SourceSlice> }>() {}\n\nexport type ExpressionNode =\n  | ASTv2.LiteralExpression\n  | ASTv2.KeywordExpression\n  | ASTv2.VariableReference\n  | Missing\n  | PathExpression\n  | InterpolateExpression\n  | CallExpression\n  | Not\n  | IfInline\n  | HasBlock\n  | HasBlockParams\n  | Curry\n  | GetDynamicVar\n  | Log;\n\nexport type ElementParameter = StaticAttr | DynamicAttr | Modifier | SplatAttr;\n\nexport type Internal =\n  | Args\n  | Positional\n  | NamedArguments\n  | NamedArgument\n  | Tail\n  | NamedBlock\n  | NamedBlocks\n  | ElementParameters;\nexport type ExprLike = ExpressionNode | Internal;\nexport type Statement =\n  | InElement\n  | Debugger\n  | Yield\n  | AppendTrustedHTML\n  | AppendTextNode\n  | Component\n  | SimpleElement\n  | InvokeBlock\n  | AppendComment\n  | If\n  | Each\n  | Let\n  | WithDynamicVars\n  | InvokeComponent;\n","import type { Nullable, PresentArray } from '@glimmer/interfaces';\nimport { isPresentArray, mapPresentArray } from '@glimmer/util';\n\nexport interface OptionalList<T> {\n  map<U>(callback: (input: T) => U): MapList<T, U, AnyOptionalList<T>>;\n  filter<S extends T>(\n    predicate: (value: T, index: number, array: T[]) => value is S\n  ): AnyOptionalList<S>;\n  toArray(): T[];\n  toPresentArray(): Nullable<PresentArray<T>>;\n  into<U, V>(options: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V;\n}\n\nexport class PresentList<T> implements OptionalList<T> {\n  constructor(readonly list: PresentArray<T>) {}\n\n  toArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  map<U>(callback: (input: T) => U): MapList<T, U, PresentList<T>> {\n    let result = mapPresentArray(this.list, callback);\n    return new PresentList(result) as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(predicate: (value: T) => value is S): AnyOptionalList<S> {\n    let out: S[] = [];\n\n    for (let item of this.list) {\n      if (predicate(item)) {\n        out.push(item);\n      }\n    }\n\n    return OptionalList(out);\n  }\n\n  toPresentArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  into<U, V>({ ifPresent }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifPresent(this);\n  }\n}\n\nexport class EmptyList<T> implements OptionalList<T> {\n  readonly list: T[] = [];\n\n  map<U>(_callback: (input: T) => U): MapList<T, U, EmptyList<T>> {\n    return new EmptyList() as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(_predicate: (value: T) => value is S): AnyOptionalList<S> {\n    return new EmptyList();\n  }\n\n  toArray(): T[] {\n    return this.list;\n  }\n\n  toPresentArray(): Nullable<PresentArray<T>> {\n    return null;\n  }\n\n  into<U, V>({ ifEmpty }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifEmpty();\n  }\n}\n\n// export type OptionalList<T> = PresentList<T> | EmptyList<T>;\n\nexport function OptionalList<T>(value: readonly T[]): AnyOptionalList<T> {\n  if (isPresentArray(value)) {\n    return new PresentList(value);\n  } else {\n    return new EmptyList<T>();\n  }\n}\n\nexport type AnyOptionalList<T> = (PresentList<T> | EmptyList<T>) & OptionalList<T>;\n\nexport type MapList<T, U, L extends OptionalList<T>> = L extends PresentList<T>\n  ? PresentList<U>\n  : L extends EmptyList<T>\n    ? EmptyList<U>\n    : never;\n","import type { GlimmerSyntaxError } from '@glimmer/syntax';\n\nimport type { AnyOptionalList } from './list';\n\nimport { OptionalList } from './list';\n\nabstract class ResultImpl<T> {\n  static all<T extends Result<unknown>[]>(...results: T): MapAll<T> {\n    let out: unknown[] = [];\n\n    for (let result of results) {\n      if (result.isErr) {\n        return result.cast();\n      } else {\n        out.push(result.value);\n      }\n    }\n\n    return Ok(out as MapAllOk<T>);\n  }\n\n  abstract mapOk<U>(callback: (value: T) => U): Result<U>;\n  abstract readonly isOk: boolean;\n  abstract readonly isErr: boolean;\n}\n\nexport const Result = ResultImpl;\n\nclass OkImpl<T> extends ResultImpl<T> {\n  readonly isOk = true;\n  readonly isErr = false;\n\n  constructor(readonly value: T) {\n    super();\n  }\n\n  expect(_message?: string): T {\n    return this.value;\n  }\n\n  ifOk(callback: (value: T) => void): this {\n    callback(this.value);\n    return this;\n  }\n\n  andThen<U>(callback: (value: T) => Result<U>): Result<U> {\n    return callback(this.value);\n  }\n\n  mapOk<U>(callback: (value: T) => U): Result<U> {\n    return Ok(callback(this.value));\n  }\n\n  ifErr(_callback: (value: GlimmerSyntaxError) => void): this {\n    return this;\n  }\n\n  mapErr(_callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return this;\n  }\n}\n\nclass ErrImpl<T> extends ResultImpl<T> {\n  readonly isOk = false;\n  readonly isErr = true;\n\n  constructor(readonly reason: GlimmerSyntaxError) {\n    super();\n  }\n\n  expect(message?: string): T {\n    throw new Error(message || 'expected an Ok, got Err');\n  }\n\n  andThen<U>(_callback: (value: T) => Result<U>): Result<U> {\n    return this.cast<U>();\n  }\n\n  mapOk<U>(_callback: (value: T) => U): Result<U> {\n    return this.cast<U>();\n  }\n\n  ifOk(_callback: (value: T) => void): this {\n    return this;\n  }\n\n  mapErr(callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return Err(callback(this.reason));\n  }\n\n  ifErr(callback: (value: GlimmerSyntaxError) => void): this {\n    callback(this.reason);\n    return this;\n  }\n\n  cast<U>(): Result<U> {\n    return this as unknown as Result<U>;\n  }\n}\n\nexport function isResult<T>(input: MaybeResult<T>): input is Result<T> {\n  return input instanceof ResultImpl;\n}\n\nexport function intoResult<T>(input: MaybeResult<T>): Result<T> {\n  if (isResult(input)) {\n    return input;\n  } else {\n    return Ok(input);\n  }\n}\n\nexport type Result<T> = OkImpl<T> | ErrImpl<T>;\n\ntype MapAllOk<T extends Result<unknown>[]> = {\n  [P in keyof T]: T[P] extends Result<infer Inner> ? Inner : never;\n};\n\ntype MapAll<T extends Result<unknown>[]> = Result<MapAllOk<T>>;\n\nexport function Ok<T>(value: T): Result<T> {\n  return new OkImpl(value);\n}\n\nexport type Ok<T> = OkImpl<T>;\n\nexport function Err<T>(reason: GlimmerSyntaxError): Result<T> {\n  return new ErrImpl(reason);\n}\n\nexport type Err<T> = ErrImpl<T>;\n\nexport type MaybeResult<T> = T | Result<T>;\n\nexport class MapIntoResultArray<T> {\n  constructor(private items: T[]) {}\n\n  map<U>(mapper: (item: T) => Result<U>): Result<U[]> {\n    let out = new ResultArray<U>();\n\n    for (let item of this.items) {\n      out.add(mapper(item));\n    }\n\n    return out.toArray();\n  }\n}\n\nexport class ResultArray<T> {\n  constructor(private items: Result<T>[] = []) {}\n\n  add(item: Result<T>): void {\n    this.items.push(item);\n  }\n\n  toArray(): Result<T[]> {\n    let err = this.items.filter((item): item is ErrImpl<T> => item instanceof ErrImpl)[0];\n\n    if (err !== undefined) {\n      return err.cast<T[]>();\n    } else {\n      return Ok((this.items as OkImpl<T>[]).map((item) => item.value));\n    }\n  }\n\n  toOptionalList(): Result<AnyOptionalList<T>> {\n    return this.toArray().mapOk((arr) => OptionalList(arr));\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { ASTv2, KEYWORDS_TYPES } from '@glimmer/syntax';\nimport { getLast, isPresentArray } from '@glimmer/util';\n\nimport type { AnyOptionalList, PresentList } from '../../../shared/list';\nimport type { NormalizationState } from '../context';\n\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { CALL_KEYWORDS } from '../keywords';\n\nexport class NormalizeExpressions {\n  visit(node: ASTv2.ExpressionNode, state: NormalizationState): Result<mir.ExpressionNode> {\n    switch (node.type) {\n      case 'Literal':\n        return Ok(this.Literal(node));\n      case 'Keyword':\n        return Ok(this.Keyword(node));\n      case 'Interpolate':\n        return this.Interpolate(node, state);\n      case 'Path':\n        return this.PathExpression(node);\n      case 'Call': {\n        let translated = CALL_KEYWORDS.translate(node, state);\n\n        if (translated !== null) {\n          return translated;\n        }\n\n        return this.CallExpression(node, state);\n      }\n    }\n  }\n\n  visitList(\n    nodes: PresentArray<ASTv2.ExpressionNode>,\n    state: NormalizationState\n  ): Result<PresentList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>> {\n    return new ResultArray(nodes.map((e) => VISIT_EXPRS.visit(e, state))).toOptionalList();\n  }\n\n  /**\n   * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.\n   *\n   * TODO since keywords don't support tails anyway, distinguish PathExpression from\n   * VariableReference in ASTv2.\n   */\n  PathExpression(path: ASTv2.PathExpression): Result<mir.ExpressionNode> {\n    let ref = this.VariableReference(path.ref);\n    let { tail } = path;\n\n    if (isPresentArray(tail)) {\n      let tailLoc = tail[0].loc.extend(getLast(tail).loc);\n      return Ok(\n        new mir.PathExpression({\n          loc: path.loc,\n          head: ref,\n          tail: new mir.Tail({ loc: tailLoc, members: tail }),\n        })\n      );\n    } else {\n      return Ok(ref);\n    }\n  }\n\n  VariableReference(ref: ASTv2.VariableReference): ASTv2.VariableReference {\n    return ref;\n  }\n\n  Literal(literal: ASTv2.LiteralExpression): ASTv2.LiteralExpression {\n    return literal;\n  }\n\n  Keyword(keyword: ASTv2.KeywordExpression): ASTv2.KeywordExpression {\n    return keyword;\n  }\n\n  Interpolate(\n    expr: ASTv2.InterpolateExpression,\n    state: NormalizationState\n  ): Result<mir.InterpolateExpression> {\n    let parts = expr.parts.map(convertPathToCallIfKeyword) as PresentArray<ASTv2.ExpressionNode>;\n\n    return VISIT_EXPRS.visitList(parts, state).mapOk(\n      (parts) => new mir.InterpolateExpression({ loc: expr.loc, parts: parts })\n    );\n  }\n\n  CallExpression(\n    expr: ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<mir.ExpressionNode> {\n    if (expr.callee.type === 'Call') {\n      throw new Error(`unimplemented: subexpression at the head of a subexpression`);\n    } else {\n      return Result.all(\n        VISIT_EXPRS.visit(expr.callee, state),\n        VISIT_EXPRS.Args(expr.args, state)\n      ).mapOk(\n        ([callee, args]) =>\n          new mir.CallExpression({\n            loc: expr.loc,\n            callee,\n            args,\n          })\n      );\n    }\n  }\n\n  Args({ positional, named, loc }: ASTv2.Args, state: NormalizationState): Result<mir.Args> {\n    return Result.all(this.Positional(positional, state), this.NamedArguments(named, state)).mapOk(\n      ([positional, named]) =>\n        new mir.Args({\n          loc,\n          positional,\n          named,\n        })\n    );\n  }\n\n  Positional(\n    positional: ASTv2.PositionalArguments,\n    state: NormalizationState\n  ): Result<mir.Positional> {\n    return VISIT_EXPRS.visitList(positional.exprs, state).mapOk(\n      (list) =>\n        new mir.Positional({\n          loc: positional.loc,\n          list,\n        })\n    );\n  }\n\n  NamedArguments(\n    named: ASTv2.NamedArguments,\n    state: NormalizationState\n  ): Result<mir.NamedArguments> {\n    let pairs = named.entries.map((arg) => {\n      let value = convertPathToCallIfKeyword(arg.value);\n\n      return VISIT_EXPRS.visit(value, state).mapOk(\n        (value) =>\n          new mir.NamedArgument({\n            loc: arg.loc,\n            key: arg.name,\n            value,\n          })\n      );\n    });\n\n    return new ResultArray(pairs)\n      .toOptionalList()\n      .mapOk((pairs) => new mir.NamedArguments({ loc: named.loc, entries: pairs }));\n  }\n}\n\nexport function convertPathToCallIfKeyword(path: ASTv2.ExpressionNode): ASTv2.ExpressionNode {\n  if (path.type === 'Path' && path.ref.type === 'Free' && path.ref.name in KEYWORDS_TYPES) {\n    return new ASTv2.CallExpression({\n      callee: path,\n      args: ASTv2.Args.empty(path.loc),\n      loc: path.loc,\n    });\n  }\n\n  return path;\n}\n\nexport const VISIT_EXPRS = new NormalizeExpressions();\n","import type { ASTv2, KeywordType } from '@glimmer/syntax';\nimport { generateSyntaxError, isKeyword, KEYWORDS_TYPES } from '@glimmer/syntax';\nimport { exhausted } from '@glimmer/util';\n\nimport type { Result } from '../../../shared/result';\nimport type { NormalizationState } from '../context';\n\nimport { Err } from '../../../shared/result';\n\nexport interface KeywordDelegate<Match extends KeywordMatch, V, Out> {\n  assert(options: Match, state: NormalizationState): Result<V>;\n  translate(options: { node: Match; state: NormalizationState }, param: V): Result<Out>;\n}\n\nexport interface Keyword<K extends KeywordType = KeywordType, Out = unknown> {\n  translate(node: KeywordCandidates[K], state: NormalizationState): Result<Out> | null;\n}\n\nexport interface BlockKeyword<Out = unknown> {\n  translate(node: ASTv2.InvokeBlock, state: NormalizationState): Result<Out> | null;\n}\n\nclass KeywordImpl<\n  K extends KeywordType,\n  S extends string = string,\n  Param = unknown,\n  Out = unknown,\n> {\n  protected types: Set<KeywordCandidates[K]['type']>;\n\n  constructor(\n    protected keyword: S,\n    type: KeywordType,\n    private delegate: KeywordDelegate<KeywordMatches[K], Param, Out>\n  ) {\n    let nodes = new Set<KeywordNode['type']>();\n    for (let nodeType of KEYWORD_NODES[type]) {\n      nodes.add(nodeType);\n    }\n\n    this.types = nodes;\n  }\n\n  protected match(node: KeywordCandidates[K]): node is KeywordMatches[K] {\n    if (!this.types.has(node.type)) {\n      return false;\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path !== null && path.type === 'Path' && path.ref.type === 'Free') {\n      return path.ref.name === this.keyword;\n    } else {\n      return false;\n    }\n  }\n\n  translate(node: KeywordMatches[K], state: NormalizationState): Result<Out> | null {\n    if (this.match(node)) {\n      let path = getCalleeExpression(node);\n\n      if (path !== null && path.type === 'Path' && path.tail.length > 0) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${\n              this.keyword\n            }\\` keyword was used incorrectly. It was used as \\`${path.loc.asString()}\\`, but it cannot be used with additional path segments. \\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n\n      let param = this.delegate.assert(node, state);\n      return param.andThen((param) => this.delegate.translate({ node, state }, param));\n    } else {\n      return null;\n    }\n  }\n}\n\nexport const KEYWORD_NODES = {\n  Call: ['Call'],\n  Block: ['InvokeBlock'],\n  Append: ['AppendContent'],\n  Modifier: ['ElementModifier'],\n} as const;\n\nexport interface KeywordCandidates {\n  Call: ASTv2.ExpressionNode;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordCandidate = KeywordCandidates[keyof KeywordCandidates];\n\nexport interface KeywordMatches {\n  Call: ASTv2.CallExpression;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordMatch = KeywordMatches[keyof KeywordMatches];\n\n/**\n * A \"generic\" keyword is something like `has-block`, which makes sense in the context\n * of sub-expression or append\n */\nexport type GenericKeywordNode = ASTv2.AppendContent | ASTv2.CallExpression;\n\nexport type KeywordNode =\n  | GenericKeywordNode\n  | ASTv2.CallExpression\n  | ASTv2.InvokeBlock\n  | ASTv2.ElementModifier;\n\nexport function keyword<\n  K extends KeywordType,\n  D extends KeywordDelegate<KeywordMatches[K], unknown, Out>,\n  Out = unknown,\n>(keyword: string, type: K, delegate: D): Keyword<K, Out> {\n  return new KeywordImpl(keyword, type, delegate as KeywordDelegate<KeywordMatch, unknown, Out>);\n}\n\nexport type PossibleKeyword = KeywordNode;\ntype OutFor<K extends Keyword | BlockKeyword> = K extends BlockKeyword<infer Out>\n  ? Out\n  : K extends Keyword<KeywordType, infer Out>\n    ? Out\n    : never;\n\nfunction getCalleeExpression(\n  node: KeywordNode | ASTv2.ExpressionNode\n): ASTv2.ExpressionNode | null {\n  switch (node.type) {\n    // This covers the inside of attributes and expressions, as well as the callee\n    // of call nodes\n    case 'Path':\n      return node;\n    case 'AppendContent':\n      return getCalleeExpression(node.value);\n    case 'Call':\n    case 'InvokeBlock':\n    case 'ElementModifier':\n      return node.callee;\n    default:\n      return null;\n  }\n}\n\nexport class Keywords<K extends KeywordType, KeywordList extends Keyword<K> = never>\n  implements Keyword<K, OutFor<KeywordList>>\n{\n  _keywords: Keyword[] = [];\n  _type: K;\n\n  constructor(type: K) {\n    this._type = type;\n  }\n\n  kw<S extends string = string, Out = unknown>(\n    name: S,\n    delegate: KeywordDelegate<KeywordMatches[K], unknown, Out>\n  ): Keywords<K, KeywordList | Keyword<K, Out>> {\n    this._keywords.push(keyword(name, this._type, delegate));\n\n    return this;\n  }\n\n  translate(\n    node: KeywordCandidates[K],\n    state: NormalizationState\n  ): Result<OutFor<KeywordList>> | null {\n    for (let keyword of this._keywords) {\n      let result = keyword.translate(node, state) as Result<OutFor<KeywordList>>;\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path && path.type === 'Path' && path.ref.type === 'Free' && isKeyword(path.ref.name)) {\n      let { name } = path.ref as { name: keyof typeof KEYWORDS_TYPES };\n\n      let usedType = this._type;\n      let validTypes: readonly KeywordType[] = KEYWORDS_TYPES[name];\n\n      if (!validTypes.includes(usedType)) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${name}\\` keyword was used incorrectly. It was used as ${\n              typesToReadableName[usedType]\n            }, but its valid usages are:\\n\\n${generateTypesMessage(\n              name,\n              validTypes\n            )}\\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    return null;\n  }\n}\n\nconst typesToReadableName = {\n  Append: 'an append statement',\n  Block: 'a block statement',\n  Call: 'a call expression',\n  Modifier: 'a modifier',\n};\n\nfunction generateTypesMessage(name: string, types: readonly KeywordType[]): string {\n  return types\n    .map((type) => {\n      switch (type) {\n        case 'Append':\n          return `- As an append statement, as in: {{${name}}}`;\n        case 'Block':\n          return `- As a block statement, as in: {{#${name}}}{{/${name}}}`;\n        case 'Call':\n          return `- As an expression, as in: (${name})`;\n        case 'Modifier':\n          return `- As a modifier, as in: <div {{${name}}}></div>`;\n        default:\n          return exhausted(type);\n      }\n    })\n    .join('\\n\\n');\n}\n\n/**\n * This function builds keyword definitions for a particular type of AST node (`KeywordType`).\n *\n * You can build keyword definitions for:\n *\n * - `Expr`: A `SubExpression` or `PathExpression`\n * - `Block`: A `BlockStatement`\n *   - A `BlockStatement` is a keyword candidate if its head is a\n *     `PathExpression`\n * - `Append`: An `AppendStatement`\n *\n * A node is a keyword candidate if:\n *\n * - A `PathExpression` is a keyword candidate if it has no tail, and its\n *   head expression is a `LocalVarHead` or `FreeVarHead` whose name is\n *   the keyword's name.\n * - A `SubExpression`, `AppendStatement`, or `BlockStatement` is a keyword\n *   candidate if its head is a keyword candidate.\n *\n * The keyword infrastructure guarantees that:\n *\n * - If a node is not a keyword candidate, it is never passed to any keyword's\n *   `assert` method.\n * - If a node is not the `KeywordType` for a particular keyword, it will not\n *   be passed to the keyword's `assert` method.\n *\n * `Expr` keywords are used in expression positions and should return HIR\n * expressions. `Block` and `Append` keywords are used in statement\n * positions and should return HIR statements.\n *\n * A keyword definition has two parts:\n *\n * - `match`, which determines whether an AST node matches the keyword, and can\n *   optionally return some information extracted from the AST node.\n * - `translate`, which takes a matching AST node as well as the extracted\n *   information and returns an appropriate HIR instruction.\n *\n * # Example\n *\n * This keyword:\n *\n * - turns `(hello)` into `\"hello\"`\n *   - as long as `hello` is not in scope\n * - makes it an error to pass any arguments (such as `(hello world)`)\n *\n * ```ts\n * keywords('SubExpr').kw('hello', {\n *   assert(node: ExprKeywordNode): Result<void> | false {\n *     // we don't want to transform `hello` as a `PathExpression`\n *     if (node.type !== 'SubExpression') {\n *       return false;\n *     }\n *\n *     // node.head would be `LocalVarHead` if `hello` was in scope\n *     if (node.head.type !== 'FreeVarHead') {\n *       return false;\n *     }\n *\n *     if (node.params.length || node.hash) {\n *       return Err(generateSyntaxError(`(hello) does not take any arguments`), node.loc);\n *     } else {\n *       return Ok();\n *     }\n *   },\n *\n *   translate(node: ASTv2.SubExpression): hir.Expression {\n *     return ASTv2.builders.literal(\"hello\", node.loc)\n *   }\n * })\n * ```\n *\n * The keyword infrastructure checks to make sure that the node is the right\n * type before calling `assert`, so you only need to consider `SubExpression`\n * and `PathExpression` here. It also checks to make sure that the node passed\n * to `assert` has the keyword name in the right place.\n *\n * Note the important difference between returning `false` from `assert`,\n * which just means that the node didn't match, and returning `Err`, which\n * means that the node matched, but there was a keyword-specific syntax\n * error.\n */\nexport function keywords<K extends KeywordType>(type: K): Keywords<K> {\n  return new Keywords(type);\n}\n","import type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport * as mir from '../../../2-encoding/mir';\n\nexport function toAppend<T>({\n  assert,\n  translate,\n}: KeywordDelegate<GenericKeywordNode, T, mir.ExpressionNode>): KeywordDelegate<\n  GenericKeywordNode,\n  T,\n  mir.AppendTextNode\n> {\n  return {\n    assert,\n    translate(\n      { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n      value: T\n    ): Result<mir.AppendTextNode> {\n      let result = translate({ node, state }, value);\n\n      return result.mapOk((text) => new mir.AppendTextNode({ text, loc: node.loc }));\n    },\n  };\n}\n","import type { CurriedType } from '@glimmer/interfaces';\nimport { ASTv2, generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nconst CurriedTypeToReadableType = {\n  [CurriedTypes.Component]: 'component',\n  [CurriedTypes.Helper]: 'helper',\n  [CurriedTypes.Modifier]: 'modifier',\n} as const;\n\nexport function assertCurryKeyword(curriedType: CurriedType) {\n  return (\n    node: ASTv2.AppendContent | ASTv2.InvokeBlock | ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<{\n    definition: ASTv2.ExpressionNode;\n    args: ASTv2.Args;\n  }> => {\n    let readableType = CurriedTypeToReadableType[curriedType];\n    let stringsAllowed = curriedType === CurriedTypes.Component;\n\n    let { args } = node;\n\n    let definition = args.nth(0);\n\n    if (definition === null) {\n      return Err(\n        generateSyntaxError(\n          `(${readableType}) requires a ${readableType} definition or identifier as its first positional parameter, did not receive any parameters.`,\n          args.loc\n        )\n      );\n    }\n\n    if (definition.type === 'Literal') {\n      if (stringsAllowed && state.isStrict) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values in strict mode templates`,\n            node.loc\n          )\n        );\n      } else if (!stringsAllowed) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values, you must pass a ${readableType} definition directly`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    args = new ASTv2.Args({\n      positional: new ASTv2.PositionalArguments({\n        exprs: args.positional.exprs.slice(1),\n        loc: args.positional.loc,\n      }),\n      named: args.named,\n      loc: args.loc,\n    });\n\n    return Ok({ definition, args });\n  };\n}\n\nfunction translateCurryKeyword(curriedType: CurriedType) {\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.CallExpression | ASTv2.AppendContent; state: NormalizationState },\n    { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n  ): Result<mir.Curry> => {\n    let definitionResult = VISIT_EXPRS.visit(definition, state);\n    let argsResult = VISIT_EXPRS.Args(args, state);\n\n    return Result.all(definitionResult, argsResult).mapOk(\n      ([definition, args]) =>\n        new mir.Curry({\n          loc: node.loc,\n          curriedType,\n          definition,\n          args,\n        })\n    );\n  };\n}\n\nexport function curryKeyword(\n  curriedType: CurriedType\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  { definition: ASTv2.ExpressionNode; args: ASTv2.Args },\n  mir.Curry\n> {\n  return {\n    assert: assertCurryKeyword(curriedType),\n    translate: translateCurryKeyword(curriedType),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertGetDynamicVarKeyword(node: GenericKeywordNode): Result<ASTv2.ExpressionNode> {\n  let call = node.type === 'AppendContent' ? node.value : node;\n\n  let named = call.type === 'Call' ? call.args.named : null;\n  let positionals = call.type === 'Call' ? call.args.positional : null;\n\n  if (named && !named.isEmpty()) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) does not take any named arguments`, node.loc)\n    );\n  }\n\n  let varName = positionals?.nth(0);\n\n  if (!varName) {\n    return Err(generateSyntaxError(`(-get-dynamic-vars) requires a var name to get`, node.loc));\n  }\n\n  if (positionals && positionals.size > 1) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) only receives one positional arg`, node.loc)\n    );\n  }\n\n  return Ok(varName);\n}\n\nfunction translateGetDynamicVarKeyword(\n  { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n  name: ASTv2.ExpressionNode\n): Result<mir.GetDynamicVar> {\n  return VISIT_EXPRS.visit(name, state).mapOk(\n    (name) => new mir.GetDynamicVar({ name, loc: node.loc })\n  );\n}\n\nexport const getDynamicVarKeyword: KeywordDelegate<\n  GenericKeywordNode,\n  ASTv2.ExpressionNode,\n  mir.GetDynamicVar\n> = {\n  assert: assertGetDynamicVarKeyword,\n  translate: translateGetDynamicVarKeyword,\n};\n","import { ASTv2, generateSyntaxError, SourceSlice } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\n\nfunction assertHasBlockKeyword(type: string) {\n  return (node: GenericKeywordNode): Result<SourceSlice> => {\n    let call = node.type === 'AppendContent' ? node.value : node;\n\n    let named = call.type === 'Call' ? call.args.named : null;\n    let positionals = call.type === 'Call' ? call.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(generateSyntaxError(`(${type}) does not take any named arguments`, call.loc));\n    }\n\n    if (!positionals || positionals.isEmpty()) {\n      return Ok(SourceSlice.synthetic('default'));\n    } else if (positionals.exprs.length === 1) {\n      let positional = positionals.exprs[0] as ASTv2.ExpressionNode;\n      if (ASTv2.isLiteral(positional, 'string')) {\n        return Ok(positional.toSlice());\n      } else {\n        return Err(\n          generateSyntaxError(\n            `(${type}) can only receive a string literal as its first argument`,\n            call.loc\n          )\n        );\n      }\n    } else {\n      return Err(\n        generateSyntaxError(`(${type}) only takes a single positional argument`, call.loc)\n      );\n    }\n  };\n}\n\nfunction translateHasBlockKeyword(type: string) {\n  return (\n    { node, state: { scope } }: { node: ASTv2.CallExpression; state: NormalizationState },\n    target: SourceSlice\n  ): Result<mir.HasBlock | mir.HasBlockParams> => {\n    let block =\n      type === 'has-block'\n        ? new mir.HasBlock({ loc: node.loc, target, symbol: scope.allocateBlock(target.chars) })\n        : new mir.HasBlockParams({\n            loc: node.loc,\n            target,\n            symbol: scope.allocateBlock(target.chars),\n          });\n\n    return Ok(block);\n  };\n}\n\nexport function hasBlockKeyword(\n  type: string\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  SourceSlice,\n  mir.HasBlock | mir.HasBlockParams\n> {\n  return {\n    assert: assertHasBlockKeyword(type),\n    translate: translateHasBlockKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertIfUnlessInlineKeyword(type: string) {\n  return (\n    originalNode: ASTv2.AppendContent | ASTv2.ExpressionNode\n  ): Result<{\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  }> => {\n    let inverted = type === 'unless';\n\n    let node = originalNode.type === 'AppendContent' ? originalNode.value : originalNode;\n    let named = node.type === 'Call' ? node.args.named : null;\n    let positional = node.type === 'Call' ? node.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(\n        generateSyntaxError(\n          `(${type}) cannot receive named parameters, received ${named.entries\n            .map((e) => e.name.chars)\n            .join(', ')}`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let condition = positional?.nth(0);\n\n    if (!positional || !condition) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Did not receive any parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let truthy = positional.nth(1);\n    let falsy = positional.nth(2);\n\n    if (truthy === null) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Received only one parameter, the condition`,\n          originalNode.loc\n        )\n      );\n    }\n\n    if (positional.size > 3) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${type}), 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }, and 3. the value to return if the condition is ${\n            inverted ? 'true' : 'false'\n          }. Received ${positional?.size ?? 0} parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    return Ok({ condition, truthy, falsy });\n  };\n}\n\nfunction translateIfUnlessInlineKeyword(type: string) {\n  let inverted = type === 'unless';\n\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.AppendContent | ASTv2.ExpressionNode; state: NormalizationState },\n    {\n      condition,\n      truthy,\n      falsy,\n    }: {\n      condition: ASTv2.ExpressionNode;\n      truthy: ASTv2.ExpressionNode;\n      falsy: ASTv2.ExpressionNode | null;\n    }\n  ): Result<mir.IfInline> => {\n    let conditionResult = VISIT_EXPRS.visit(condition, state);\n    let truthyResult = VISIT_EXPRS.visit(truthy, state);\n    let falsyResult = falsy ? VISIT_EXPRS.visit(falsy, state) : Ok(null);\n\n    return Result.all(conditionResult, truthyResult, falsyResult).mapOk(\n      ([condition, truthy, falsy]) => {\n        if (inverted) {\n          condition = new mir.Not({ value: condition, loc: node.loc });\n        }\n\n        return new mir.IfInline({\n          loc: node.loc,\n          condition,\n          truthy,\n          falsy,\n        });\n      }\n    );\n  };\n}\n\nexport function ifUnlessInlineKeyword(type: string): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  {\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  },\n  mir.IfInline\n> {\n  return {\n    assert: assertIfUnlessInlineKeyword(type),\n    translate: translateIfUnlessInlineKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertLogKeyword(node: GenericKeywordNode): Result<ASTv2.PositionalArguments> {\n  let {\n    args: { named, positional },\n  } = node;\n\n  if (named && !named.isEmpty()) {\n    return Err(generateSyntaxError(`(log) does not take any named arguments`, node.loc));\n  }\n\n  return Ok(positional);\n}\n\nfunction translateLogKeyword(\n  { node, state }: { node: ASTv2.CallExpression; state: NormalizationState },\n  positional: ASTv2.PositionalArguments\n): Result<mir.Log> {\n  return VISIT_EXPRS.Positional(positional, state).mapOk(\n    (positional) => new mir.Log({ positional, loc: node.loc })\n  );\n}\n\nexport const logKeyword: KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  ASTv2.PositionalArguments,\n  mir.Log\n> = {\n  assert: assertLogKeyword,\n  translate: translateLogKeyword,\n};\n","import { ASTv2, generateSyntaxError, src } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { keywords } from './impl';\nimport { toAppend } from './utils/call-to-append';\nimport { assertCurryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const APPEND_KEYWORDS = keywords('Append')\n  .kw('has-block', toAppend(hasBlockKeyword('has-block')))\n  .kw('has-block-params', toAppend(hasBlockKeyword('has-block-params')))\n  .kw('-get-dynamic-var', toAppend(getDynamicVarKeyword))\n  .kw('log', toAppend(logKeyword))\n  .kw('if', toAppend(ifUnlessInlineKeyword('if')))\n  .kw('unless', toAppend(ifUnlessInlineKeyword('unless')))\n  .kw('yield', {\n    assert(node: ASTv2.AppendContent): Result<{\n      target: src.SourceSlice;\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (args.named.isEmpty()) {\n        return Ok({\n          target: src.SourceSpan.synthetic('default').toSlice(),\n          positional: args.positional,\n        });\n      } else {\n        let target = args.named.get('to');\n\n        if (args.named.size > 1 || target === null) {\n          return Err(\n            generateSyntaxError(`yield only takes a single named argument: 'to'`, args.named.loc)\n          );\n        }\n\n        if (ASTv2.isLiteral(target, 'string')) {\n          return Ok({ target: target.toSlice(), positional: args.positional });\n        } else {\n          return Err(\n            generateSyntaxError(`you can only yield to a literal string value`, target.loc)\n          );\n        }\n      }\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      {\n        target,\n        positional,\n      }: {\n        target: src.SourceSlice;\n        positional: ASTv2.PositionalArguments;\n      }\n    ): Result<mir.Statement> {\n      return VISIT_EXPRS.Positional(positional, state).mapOk(\n        (positional) =>\n          new mir.Yield({\n            loc: node.loc,\n            target,\n            to: state.scope.allocateBlock(target.chars),\n            positional,\n          })\n      );\n    },\n  })\n  .kw('debugger', {\n    assert(node: ASTv2.AppendContent): Result<void> {\n      let { args } = node;\n      let { positional } = args;\n\n      if (args.isEmpty()) {\n        return Ok(undefined);\n      } else {\n        if (positional.isEmpty()) {\n          return Err(generateSyntaxError(`debugger does not take any named arguments`, node.loc));\n        } else {\n          return Err(\n            generateSyntaxError(`debugger does not take any positional arguments`, node.loc)\n          );\n        }\n      }\n    },\n\n    translate({\n      node,\n      state: { scope },\n    }: {\n      node: ASTv2.AppendContent;\n      state: NormalizationState;\n    }): Result<mir.Statement> {\n      scope.setHasDebugger();\n      return Ok(new mir.Debugger({ loc: node.loc, scope }));\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(\n        ([definition, args]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks: null,\n          })\n      );\n    },\n  })\n  .kw('helper', {\n    assert: assertCurryKeyword(CurriedTypes.Helper),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.AppendTextNode> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => {\n        let text = new mir.CallExpression({ callee: definition, args, loc: node.loc });\n\n        return new mir.AppendTextNode({\n          loc: node.loc,\n          text,\n        });\n      });\n    },\n  });\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { VISIT_STMTS } from '../visitors/statements';\nimport { keywords } from './impl';\nimport { assertCurryKeyword } from './utils/curry';\n\nexport const BLOCK_KEYWORDS = keywords('Block')\n  .kw('in-element', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      insertBefore: ASTv2.ExpressionNode | null;\n      destination: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      let guid = args.get('guid');\n\n      if (guid) {\n        return Err(generateSyntaxError(`Cannot pass \\`guid\\` to \\`{{#in-element}}\\``, guid.loc));\n      }\n\n      let insertBefore = args.get('insertBefore');\n      let destination = args.nth(0);\n\n      if (destination === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#in-element}} requires a target element as its first positional parameter`,\n            args.loc\n          )\n        );\n      }\n\n      // TODO Better syntax checks\n\n      return Ok({ insertBefore, destination });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      {\n        insertBefore,\n        destination,\n      }: { insertBefore: ASTv2.ExpressionNode | null; destination: ASTv2.ExpressionNode }\n    ): Result<mir.InElement> {\n      let named = node.blocks.get('default');\n      let body = VISIT_STMTS.NamedBlock(named, state);\n      let destinationResult = VISIT_EXPRS.visit(destination, state);\n\n      return Result.all(body, destinationResult)\n        .andThen(\n          ([body, destination]): Result<{\n            body: mir.NamedBlock;\n            destination: mir.ExpressionNode;\n            insertBefore: mir.ExpressionNode;\n          }> => {\n            if (insertBefore) {\n              return VISIT_EXPRS.visit(insertBefore, state).mapOk((insertBefore) => ({\n                body,\n                destination,\n                insertBefore,\n              }));\n            } else {\n              return Ok({\n                body,\n                destination,\n                insertBefore: new mir.Missing({\n                  loc: node.callee.loc.collapse('end'),\n                }),\n              });\n            }\n          }\n        )\n        .mapOk(\n          ({ body, destination, insertBefore }) =>\n            new mir.InElement({\n              loc: node.loc,\n              block: body,\n              insertBefore,\n              guid: state.generateUniqueCursor(),\n              destination,\n            })\n        );\n    },\n  })\n  .kw('if', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('unless', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition: new mir.Not({ value: condition, loc: node.loc }),\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('each', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      value: ASTv2.ExpressionNode;\n      key: ASTv2.ExpressionNode | null;\n    }> {\n      let { args } = node;\n\n      if (!args.named.entries.every((e) => e.name.chars === 'key')) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive the 'key' named parameter, received ${args.named.entries\n              .filter((e) => e.name.chars !== 'key')\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive one positional parameter, the collection being iterated. Received ${args.positional.size} parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      let value = args.nth(0);\n      let key = args.get('key');\n\n      if (value === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters`,\n            args.loc\n          )\n        );\n      }\n\n      return Ok({ value, key });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { value, key }: { value: ASTv2.ExpressionNode; key: ASTv2.ExpressionNode | null }\n    ): Result<mir.Each> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let valueResult = VISIT_EXPRS.visit(value, state);\n      let keyResult = key ? VISIT_EXPRS.visit(key, state) : Ok(null);\n\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(valueResult, keyResult, blockResult, inverseResult).mapOk(\n        ([value, key, block, inverse]) =>\n          new mir.Each({\n            loc: node.loc,\n            value,\n            key,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('let', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size === 0) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} requires at least one value as its first positional parameter, did not receive any parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      if (node.blocks.get('else')) {\n        return Err(\n          generateSyntaxError(`{{#let}} cannot receive an {{else}} block`, args.positional.loc)\n        );\n      }\n\n      return Ok({ positional: args.positional });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { positional }: { positional: ASTv2.PositionalArguments }\n    ): Result<mir.Let> {\n      let block = node.blocks.get('default');\n\n      let positionalResult = VISIT_EXPRS.Positional(positional, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(positionalResult, blockResult).mapOk(\n        ([positional, block]) =>\n          new mir.Let({\n            loc: node.loc,\n            positional,\n            block,\n          })\n      );\n    },\n  })\n  .kw('-with-dynamic-vars', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      named: ASTv2.NamedArguments;\n    }> {\n      return Ok({ named: node.args.named });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { named }: { named: ASTv2.NamedArguments }\n    ): Result<mir.WithDynamicVars> {\n      let block = node.blocks.get('default');\n\n      let namedResult = VISIT_EXPRS.NamedArguments(named, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(namedResult, blockResult).mapOk(\n        ([named, block]) =>\n          new mir.WithDynamicVars({\n            loc: node.loc,\n            named,\n            block,\n          })\n      );\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n      let blocksResult = VISIT_STMTS.NamedBlocks(node.blocks, state);\n\n      return Result.all(definitionResult, argsResult, blocksResult).mapOk(\n        ([definition, args, blocks]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks,\n          })\n      );\n    },\n  });\n","import { CurriedTypes } from '@glimmer/vm';\n\nimport { keywords } from './impl';\nimport { curryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const CALL_KEYWORDS = keywords('Call')\n  .kw('has-block', hasBlockKeyword('has-block'))\n  .kw('has-block-params', hasBlockKeyword('has-block-params'))\n  .kw('-get-dynamic-var', getDynamicVarKeyword)\n  .kw('log', logKeyword)\n  .kw('if', ifUnlessInlineKeyword('if'))\n  .kw('unless', ifUnlessInlineKeyword('unless'))\n  .kw('component', curryKeyword(CurriedTypes.Component))\n  .kw('helper', curryKeyword(CurriedTypes.Helper))\n  .kw('modifier', curryKeyword(CurriedTypes.Modifier));\n","import { keywords } from './impl';\n\nexport const MODIFIER_KEYWORDS = keywords('Modifier');\n","import type { Dict, WellKnownAttrName, WellKnownTagName } from '@glimmer/interfaces';\nimport { WellKnownAttrNames, WellKnownTagNames } from '@glimmer/wire-format';\n\n// There is a small whitelist of namespaced attributes specially\n// enumerated in\n// https://www.w3.org/TR/html/syntax.html#attributes-0\n//\n// > When a foreign element has one of the namespaced attributes given by\n// > the local name and namespace of the first and second cells of a row\n// > from the following table, it must be written using the name given by\n// > the third cell from the same row.\n//\n// In all other cases, colons are interpreted as a regular character\n// with no special meaning:\n//\n// > No other namespaced attribute can be expressed in the HTML syntax.\n\nconst XLINK = 'http://www.w3.org/1999/xlink';\nconst XML = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\nconst WHITELIST: Dict<string | undefined> = {\n  'xlink:actuate': XLINK,\n  'xlink:arcrole': XLINK,\n  'xlink:href': XLINK,\n  'xlink:role': XLINK,\n  'xlink:show': XLINK,\n  'xlink:title': XLINK,\n  'xlink:type': XLINK,\n  'xml:base': XML,\n  'xml:lang': XML,\n  'xml:space': XML,\n  xmlns: XMLNS,\n  'xmlns:xlink': XMLNS,\n};\n\nexport function getAttrNamespace(attrName: string): string | undefined {\n  return WHITELIST[attrName];\n}\n\nconst DEFLATE_TAG_TABLE: {\n  [tagName: string]: WellKnownTagName | undefined;\n} = {\n  div: WellKnownTagNames.div,\n  span: WellKnownTagNames.span,\n  p: WellKnownTagNames.p,\n  a: WellKnownTagNames.a,\n};\n\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function deflateTagName(tagName: string): string | WellKnownTagName {\n  return DEFLATE_TAG_TABLE[tagName] ?? tagName;\n}\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nconst DEFLATE_ATTR_TABLE: {\n  [tagName: string]: WellKnownAttrName | undefined;\n} = {\n  class: WellKnownAttrNames.class,\n  id: WellKnownAttrNames.id,\n  value: WellKnownAttrNames.value,\n  name: WellKnownAttrNames.name,\n  type: WellKnownAttrNames.type,\n  style: WellKnownAttrNames.style,\n  href: WellKnownAttrNames.href,\n};\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\n\nexport function deflateAttrName(attrName: string): string | WellKnownAttrName {\n  return DEFLATE_ATTR_TABLE[attrName] ?? attrName;\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n","import { ASTv2, maybeLoc, src } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\n\nimport { OptionalList } from '../../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../../shared/result';\nimport { getAttrNamespace } from '../../../../utils';\nimport * as mir from '../../../2-encoding/mir';\nimport { MODIFIER_KEYWORDS } from '../../keywords';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\n\nexport type ValidAttr = mir.StaticAttr | mir.DynamicAttr | mir.SplatAttr;\n\ntype ProcessedAttributes = {\n  attrs: ValidAttr[];\n  args: mir.NamedArguments;\n};\n\nexport interface Classified {\n  readonly dynamicFeatures: boolean;\n\n  arg(attr: ASTv2.AttrNode, classified: ClassifiedElement): Result<mir.NamedArgument>;\n  toStatement(classified: ClassifiedElement, prepared: PreparedArgs): Result<mir.Statement>;\n}\n\nexport class ClassifiedElement {\n  readonly delegate: Classified;\n\n  constructor(\n    readonly element: ASTv2.ElementNode,\n    delegate: Classified,\n    readonly state: NormalizationState\n  ) {\n    this.delegate = delegate;\n  }\n\n  toStatement(): Result<mir.Statement> {\n    return this.prepare().andThen((prepared) => this.delegate.toStatement(this, prepared));\n  }\n\n  private attr(attr: ASTv2.HtmlAttr): Result<ValidAttr> {\n    let name = attr.name;\n    let rawValue = attr.value;\n    let namespace = getAttrNamespace(name.chars) || undefined;\n\n    if (ASTv2.isLiteral(rawValue, 'string')) {\n      return Ok(\n        new mir.StaticAttr({\n          loc: attr.loc,\n          name,\n          value: rawValue.toSlice(),\n          namespace,\n          kind: {\n            component: this.delegate.dynamicFeatures,\n          },\n        })\n      );\n    }\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk((value) => {\n      let isTrusting = attr.trusting;\n\n      return new mir.DynamicAttr({\n        loc: attr.loc,\n        name,\n        value: value,\n        namespace,\n        kind: {\n          trusting: isTrusting,\n          component: this.delegate.dynamicFeatures,\n        },\n      });\n    });\n  }\n\n  private modifier(modifier: ASTv2.ElementModifier): Result<mir.Modifier> {\n    let translated = MODIFIER_KEYWORDS.translate(modifier, this.state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(modifier.callee, this.state);\n    let args = VISIT_EXPRS.Args(modifier.args, this.state);\n\n    return Result.all(head, args).mapOk(\n      ([head, args]) =>\n        new mir.Modifier({\n          loc: modifier.loc,\n          callee: head,\n          args,\n        })\n    );\n  }\n\n  private attrs(): Result<ProcessedAttributes> {\n    let attrs = new ResultArray<ValidAttr>();\n    let args = new ResultArray<mir.NamedArgument>();\n\n    // Unlike most attributes, the `type` attribute can change how\n    // subsequent attributes are interpreted by the browser. To address\n    // this, in simple cases, we special case the `type` attribute to be set\n    // last. For elements with splattributes, where attribute order affects\n    // precedence, this re-ordering happens at runtime instead.\n    // See https://github.com/glimmerjs/glimmer-vm/pull/726\n    let typeAttr: ASTv2.AttrNode | null = null;\n    let simple = this.element.attrs.filter((attr) => attr.type === 'SplatAttr').length === 0;\n\n    for (let attr of this.element.attrs) {\n      if (attr.type === 'SplatAttr') {\n        attrs.add(\n          Ok(new mir.SplatAttr({ loc: attr.loc, symbol: this.state.scope.allocateBlock('attrs') }))\n        );\n      } else if (attr.name.chars === 'type' && simple) {\n        typeAttr = attr;\n      } else {\n        attrs.add(this.attr(attr));\n      }\n    }\n\n    for (let arg of this.element.componentArgs) {\n      args.add(this.delegate.arg(arg, this));\n    }\n\n    if (typeAttr) {\n      attrs.add(this.attr(typeAttr));\n    }\n\n    return Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({\n      attrs,\n      args: new mir.NamedArguments({\n        loc: maybeLoc(args, src.SourceSpan.NON_EXISTENT),\n        entries: OptionalList(args),\n      }),\n    }));\n  }\n\n  private prepare(): Result<PreparedArgs> {\n    let attrs = this.attrs();\n    let modifiers = new ResultArray(this.element.modifiers.map((m) => this.modifier(m))).toArray();\n\n    return Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {\n      let { attrs, args } = result;\n\n      let elementParams = [...attrs, ...modifiers];\n\n      let params = new mir.ElementParameters({\n        loc: maybeLoc(elementParams, src.SourceSpan.NON_EXISTENT),\n        body: OptionalList(elementParams),\n      });\n\n      return { args, params };\n    });\n  }\n}\n\nexport interface PreparedArgs {\n  args: mir.NamedArguments;\n  params: mir.ElementParameters;\n}\n\nexport function hasDynamicFeatures({\n  attrs,\n  modifiers,\n}: Pick<ASTv2.ElementNode, 'attrs' | 'modifiers'>): boolean {\n  // ElementModifier needs the special ComponentOperations\n  if (modifiers.length > 0) {\n    return true;\n  }\n\n  // Splattributes need the special ComponentOperations to merge into\n  return !!attrs.filter((attr) => attr.type === 'SplatAttr')[0];\n}\n","import type { ASTv2 } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport * as mir from '../../../2-encoding/mir';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedComponent implements Classified {\n  readonly dynamicFeatures = true;\n\n  constructor(\n    private tag: mir.ExpressionNode,\n    private element: ASTv2.InvokeComponent\n  ) {}\n\n  arg(attr: ASTv2.ComponentArg, { state }: ClassifiedElement): Result<mir.NamedArgument> {\n    let name = attr.name;\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(attr.value), state).mapOk(\n      (value) =>\n        new mir.NamedArgument({\n          loc: attr.loc,\n          key: name,\n          value,\n        })\n    );\n  }\n\n  toStatement(component: ClassifiedElement, { args, params }: PreparedArgs): Result<mir.Statement> {\n    let { element, state } = component;\n\n    return this.blocks(state).mapOk(\n      (blocks) =>\n        new mir.Component({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          args,\n          blocks,\n        })\n    );\n  }\n\n  private blocks(state: NormalizationState): Result<mir.NamedBlocks> {\n    return VISIT_STMTS.NamedBlocks(this.element.blocks, state);\n  }\n}\n","import type { ASTv2, SourceSlice } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport { Err } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedSimpleElement implements Classified {\n  constructor(\n    private tag: SourceSlice,\n    private element: ASTv2.SimpleElement,\n    readonly dynamicFeatures: boolean\n  ) {}\n\n  readonly isComponent = false;\n\n  arg(attr: ASTv2.ComponentArg): Result<mir.NamedArgument> {\n    return Err(\n      generateSyntaxError(\n        `${attr.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\\`${this.tag.chars}\\`) is a regular, non-component HTML element.`,\n        attr.loc\n      )\n    );\n  }\n\n  toStatement(classified: ClassifiedElement, { params }: PreparedArgs): Result<mir.Statement> {\n    let { state, element } = classified;\n\n    let body = VISIT_STMTS.visitList(this.element.body, state);\n\n    return body.mapOk(\n      (body) =>\n        new mir.SimpleElement({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          body: body.toArray(),\n          dynamicFeatures: this.dynamicFeatures,\n        })\n    );\n  }\n}\n","import { ASTv2 } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../context';\n\nimport { OptionalList } from '../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { BLOCK_KEYWORDS } from '../keywords';\nimport { APPEND_KEYWORDS } from '../keywords/append';\nimport { ClassifiedElement, hasDynamicFeatures } from './element/classified';\nimport { ClassifiedComponent } from './element/component';\nimport { ClassifiedSimpleElement } from './element/simple-element';\nimport { VISIT_EXPRS } from './expressions';\n\nclass NormalizationStatements {\n  visitList(\n    nodes: readonly ASTv2.ContentNode[],\n    state: NormalizationState\n  ): Result<OptionalList<mir.Statement>> {\n    return new ResultArray(nodes.map((e) => VISIT_STMTS.visit(e, state)))\n      .toOptionalList()\n      .mapOk((list) => list.filter((s: mir.Statement | null): s is mir.Statement => s !== null));\n  }\n\n  visit(node: ASTv2.ContentNode, state: NormalizationState): Result<mir.Statement | null> {\n    switch (node.type) {\n      case 'GlimmerComment':\n        return Ok(null);\n      case 'AppendContent':\n        return this.AppendContent(node, state);\n      case 'HtmlText':\n        return Ok(this.TextNode(node));\n      case 'HtmlComment':\n        return Ok(this.HtmlComment(node));\n      case 'InvokeBlock':\n        return this.InvokeBlock(node, state);\n      case 'InvokeComponent':\n        return this.Component(node, state);\n      case 'SimpleElement':\n        return this.SimpleElement(node, state);\n    }\n  }\n\n  InvokeBlock(node: ASTv2.InvokeBlock, state: NormalizationState): Result<mir.Statement> {\n    let translated = BLOCK_KEYWORDS.translate(node, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(node.callee, state);\n    let args = VISIT_EXPRS.Args(node.args, state);\n\n    return Result.all(head, args).andThen(([head, args]) =>\n      this.NamedBlocks(node.blocks, state).mapOk(\n        (blocks) =>\n          new mir.InvokeBlock({\n            loc: node.loc,\n            head,\n            args,\n            blocks,\n          })\n      )\n    );\n  }\n\n  NamedBlocks(blocks: ASTv2.NamedBlocks, state: NormalizationState): Result<mir.NamedBlocks> {\n    let list = new ResultArray(blocks.blocks.map((b) => this.NamedBlock(b, state)));\n\n    return list\n      .toArray()\n      .mapOk((list) => new mir.NamedBlocks({ loc: blocks.loc, blocks: OptionalList(list) }));\n  }\n\n  NamedBlock(named: ASTv2.NamedBlock, state: NormalizationState): Result<mir.NamedBlock> {\n    let body = state.visitBlock(named.block);\n\n    return body.mapOk((body) => {\n      return new mir.NamedBlock({\n        loc: named.loc,\n        name: named.name,\n        body: body.toArray(),\n        scope: named.block.scope,\n      });\n    });\n  }\n\n  SimpleElement(element: ASTv2.SimpleElement, state: NormalizationState): Result<mir.Statement> {\n    return new ClassifiedElement(\n      element,\n      new ClassifiedSimpleElement(element.tag, element, hasDynamicFeatures(element)),\n      state\n    ).toStatement();\n  }\n\n  Component(component: ASTv2.InvokeComponent, state: NormalizationState): Result<mir.Statement> {\n    return VISIT_EXPRS.visit(component.callee, state).andThen((callee) =>\n      new ClassifiedElement(\n        component,\n        new ClassifiedComponent(callee, component),\n        state\n      ).toStatement()\n    );\n  }\n\n  AppendContent(append: ASTv2.AppendContent, state: NormalizationState): Result<mir.Statement> {\n    let translated = APPEND_KEYWORDS.translate(append, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let value = VISIT_EXPRS.visit(append.value, state);\n\n    return value.mapOk((value) => {\n      if (append.trusting) {\n        return new mir.AppendTrustedHTML({\n          loc: append.loc,\n          html: value,\n        });\n      } else {\n        return new mir.AppendTextNode({\n          loc: append.loc,\n          text: value,\n        });\n      }\n    });\n  }\n\n  TextNode(text: ASTv2.HtmlText): mir.Statement {\n    return new mir.AppendTextNode({\n      loc: text.loc,\n      text: new ASTv2.LiteralExpression({ loc: text.loc, value: text.chars }),\n    });\n  }\n\n  HtmlComment(comment: ASTv2.HtmlComment): mir.Statement {\n    return new mir.AppendComment({\n      loc: comment.loc,\n      value: comment.text,\n    });\n  }\n}\n\nexport const VISIT_STMTS = new NormalizationStatements();\n","import type { ASTv2, SymbolTable } from '@glimmer/syntax';\n\nimport type { OptionalList } from '../../shared/list';\nimport type { Result } from '../../shared/result';\nimport type * as mir from '../2-encoding/mir';\n\nimport { VISIT_STMTS } from './visitors/statements';\n\n/**\n * This is the mutable state for this compiler pass.\n */\nexport class NormalizationState {\n  _currentScope: SymbolTable;\n  _cursorCount = 0;\n\n  constructor(\n    block: SymbolTable,\n    readonly isStrict: boolean\n  ) {\n    this._currentScope = block;\n  }\n\n  generateUniqueCursor(): string {\n    return `%cursor:${this._cursorCount++}%`;\n  }\n\n  get scope(): SymbolTable {\n    return this._currentScope;\n  }\n\n  visitBlock(block: ASTv2.Block): Result<OptionalList<mir.Statement>> {\n    let oldBlock = this._currentScope;\n    this._currentScope = block.scope;\n\n    try {\n      return VISIT_STMTS.visitList(block.body, this);\n    } finally {\n      this._currentScope = oldBlock;\n    }\n  }\n}\n","import type { HasSourceSpan } from '@glimmer/syntax';\nimport { generateSyntaxError, loc } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { Result } from '../../../shared/result';\nimport type * as mir from '../../2-encoding/mir';\n\nimport { Err, Ok } from '../../../shared/result';\n\nenum ResolutionType {\n  Value = 'value',\n  Component = 'component',\n  Helper = 'helper',\n  Modifier = 'modifier',\n  ComponentOrHelper = 'component or helper',\n}\n\nexport default class StrictModeValidationPass {\n  // This is done at the end of all the keyword normalizations\n  // At this point any free variables that isn't a valid keyword\n  // in its context should be considered a syntax error. We\n  // probably had various opportunities to do this inline in the\n  // earlier passes, but this aims to produce a better syntax\n  // error as we don't always have the right loc-context to do\n  // so in the other spots.\n  static validate(template: mir.Template): Result<mir.Template> {\n    return new this(template).validate();\n  }\n\n  private constructor(private template: mir.Template) {}\n\n  validate(): Result<mir.Template> {\n    return this.Statements(this.template.body).mapOk(() => this.template);\n  }\n\n  Statements(statements: mir.Statement[]): Result<null> {\n    let result = Ok(null);\n\n    for (let statement of statements) {\n      result = result.andThen(() => this.Statement(statement));\n    }\n\n    return result;\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): Result<null> {\n    let result = Ok(null);\n\n    for (let block of blocks.toArray()) {\n      result = result.andThen(() => this.NamedBlock(block));\n    }\n\n    return result;\n  }\n\n  NamedBlock(block: mir.NamedBlock): Result<null> {\n    return this.Statements(block.body);\n  }\n\n  Statement(statement: mir.Statement): Result<null> {\n    switch (statement.type) {\n      case 'InElement':\n        return this.InElement(statement);\n\n      case 'Debugger':\n        return Ok(null);\n\n      case 'Yield':\n        return this.Yield(statement);\n\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(statement);\n\n      case 'AppendTextNode':\n        return this.AppendTextNode(statement);\n\n      case 'Component':\n        return this.Component(statement);\n\n      case 'SimpleElement':\n        return this.SimpleElement(statement);\n\n      case 'InvokeBlock':\n        return this.InvokeBlock(statement);\n\n      case 'AppendComment':\n        return Ok(null);\n\n      case 'If':\n        return this.If(statement);\n\n      case 'Each':\n        return this.Each(statement);\n\n      case 'Let':\n        return this.Let(statement);\n\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(statement);\n\n      case 'InvokeComponent':\n        return this.InvokeComponent(statement);\n    }\n  }\n\n  Expressions(expressions: mir.ExpressionNode[]): Result<null> {\n    let result = Ok(null);\n\n    for (let expression of expressions) {\n      result = result.andThen(() => this.Expression(expression));\n    }\n\n    return result;\n  }\n\n  Expression(\n    expression: mir.ExpressionNode,\n    span: HasSourceSpan = expression,\n    resolution?: ResolutionType\n  ): Result<null> {\n    switch (expression.type) {\n      case 'Literal':\n      case 'Keyword':\n      case 'Missing':\n      case 'This':\n      case 'Arg':\n      case 'Local':\n      case 'HasBlock':\n      case 'HasBlockParams':\n      case 'GetDynamicVar':\n        return Ok(null);\n\n      case 'PathExpression':\n        return this.Expression(expression.head, span, resolution);\n\n      case 'Free':\n        return this.errorFor(expression.name, span, resolution);\n\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expression, span, resolution);\n\n      case 'CallExpression':\n        return this.CallExpression(expression, span, resolution ?? ResolutionType.Helper);\n\n      case 'Not':\n        return this.Expression(expression.value, span, resolution);\n\n      case 'IfInline':\n        return this.IfInline(expression);\n\n      case 'Curry':\n        return this.Curry(expression);\n\n      case 'Log':\n        return this.Log(expression);\n    }\n  }\n\n  Args(args: mir.Args): Result<null> {\n    return this.Positional(args.positional).andThen(() => this.NamedArguments(args.named));\n  }\n\n  Positional(positional: mir.Positional, span?: HasSourceSpan): Result<null> {\n    let result = Ok(null);\n    let expressions = positional.list.toArray();\n\n    // For cases like {{yield foo}}, when there is only a single argument, it\n    // makes for a slightly better error to report that entire span. However,\n    // when there are more than one, we need to be specific.\n    if (expressions.length === 1) {\n      result = this.Expression(expressions[0]!, span);\n    } else {\n      result = this.Expressions(expressions);\n    }\n\n    return result;\n  }\n\n  NamedArguments({ entries }: mir.NamedArguments): Result<null> {\n    let result = Ok(null);\n\n    for (let arg of entries.toArray()) {\n      result = result.andThen(() => this.NamedArgument(arg));\n    }\n\n    return result;\n  }\n\n  NamedArgument(arg: mir.NamedArgument): Result<null> {\n    if (arg.value.type === 'CallExpression') {\n      return this.Expression(arg.value, arg, ResolutionType.Helper);\n    } else {\n      return this.Expression(arg.value, arg);\n    }\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): Result<null> {\n    let result = Ok(null);\n\n    for (let param of body.toArray()) {\n      result = result.andThen(() => this.ElementParameter(param));\n    }\n\n    return result;\n  }\n\n  ElementParameter(param: mir.ElementParameter): Result<null> {\n    switch (param.type) {\n      case 'StaticAttr':\n        return Ok(null);\n      case 'DynamicAttr':\n        return this.DynamicAttr(param);\n      case 'Modifier':\n        return this.Modifier(param);\n      case 'SplatAttr':\n        return Ok(null);\n    }\n  }\n\n  DynamicAttr(attr: mir.DynamicAttr): Result<null> {\n    if (attr.value.type === 'CallExpression') {\n      return this.Expression(attr.value, attr, ResolutionType.Helper);\n    } else {\n      return this.Expression(attr.value, attr);\n    }\n  }\n\n  Modifier(modifier: mir.Modifier): Result<null> {\n    return this.Expression(modifier.callee, modifier, ResolutionType.Modifier).andThen(() =>\n      this.Args(modifier.args)\n    );\n  }\n\n  InElement(inElement: mir.InElement): Result<null> {\n    return (\n      this.Expression(inElement.destination)\n        // Unfortunately we lost the `insertBefore=` part of the span\n        .andThen(() => this.Expression(inElement.insertBefore))\n        .andThen(() => this.NamedBlock(inElement.block))\n    );\n  }\n\n  Yield(statement: mir.Yield): Result<null> {\n    return this.Positional(statement.positional, statement);\n  }\n\n  AppendTrustedHTML(statement: mir.AppendTrustedHTML): Result<null> {\n    return this.Expression(statement.html, statement);\n  }\n\n  AppendTextNode(statement: mir.AppendTextNode): Result<null> {\n    if (statement.text.type === 'CallExpression') {\n      return this.Expression(statement.text, statement, ResolutionType.ComponentOrHelper);\n    } else {\n      return this.Expression(statement.text, statement);\n    }\n  }\n\n  Component(statement: mir.Component): Result<null> {\n    return this.Expression(statement.tag, statement, ResolutionType.Component)\n      .andThen(() => this.ElementParameters(statement.params))\n      .andThen(() => this.NamedArguments(statement.args))\n      .andThen(() => this.NamedBlocks(statement.blocks));\n  }\n\n  SimpleElement(statement: mir.SimpleElement): Result<null> {\n    return this.ElementParameters(statement.params).andThen(() => this.Statements(statement.body));\n  }\n\n  InvokeBlock(statement: mir.InvokeBlock): Result<null> {\n    return this.Expression(statement.head, statement.head, ResolutionType.Component)\n      .andThen(() => this.Args(statement.args))\n      .andThen(() => this.NamedBlocks(statement.blocks));\n  }\n\n  If(statement: mir.If): Result<null> {\n    return this.Expression(statement.condition, statement)\n      .andThen(() => this.NamedBlock(statement.block))\n      .andThen(() => {\n        if (statement.inverse) {\n          return this.NamedBlock(statement.inverse);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Each(statement: mir.Each): Result<null> {\n    return this.Expression(statement.value, statement)\n      .andThen(() => {\n        if (statement.key) {\n          return this.Expression(statement.key, statement);\n        } else {\n          return Ok(null);\n        }\n      })\n      .andThen(() => this.NamedBlock(statement.block))\n      .andThen(() => {\n        if (statement.inverse) {\n          return this.NamedBlock(statement.inverse);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Let(statement: mir.Let): Result<null> {\n    return this.Positional(statement.positional).andThen(() => this.NamedBlock(statement.block));\n  }\n\n  WithDynamicVars(statement: mir.WithDynamicVars): Result<null> {\n    return this.NamedArguments(statement.named).andThen(() => this.NamedBlock(statement.block));\n  }\n\n  InvokeComponent(statement: mir.InvokeComponent): Result<null> {\n    return this.Expression(statement.definition, statement, ResolutionType.Component)\n      .andThen(() => this.Args(statement.args))\n      .andThen(() => {\n        if (statement.blocks) {\n          return this.NamedBlocks(statement.blocks);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  InterpolateExpression(\n    expression: mir.InterpolateExpression,\n    span: HasSourceSpan,\n    resolution?: ResolutionType\n  ): Result<null> {\n    let expressions = expression.parts.toArray();\n\n    if (expressions.length === 1) {\n      return this.Expression(expressions[0], span, resolution);\n    } else {\n      return this.Expressions(expressions);\n    }\n  }\n\n  CallExpression(\n    expression: mir.CallExpression,\n    span: HasSourceSpan,\n    resolution?: ResolutionType\n  ): Result<null> {\n    return this.Expression(expression.callee, span, resolution).andThen(() =>\n      this.Args(expression.args)\n    );\n  }\n\n  IfInline(expression: mir.IfInline): Result<null> {\n    return this.Expression(expression.condition)\n      .andThen(() => this.Expression(expression.truthy))\n      .andThen(() => {\n        if (expression.falsy) {\n          return this.Expression(expression.falsy);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Curry(expression: mir.Curry): Result<null> {\n    let resolution: ResolutionType;\n\n    if (expression.curriedType === CurriedTypes.Component) {\n      resolution = ResolutionType.Component;\n    } else if (expression.curriedType === CurriedTypes.Helper) {\n      resolution = ResolutionType.Helper;\n    } else {\n      resolution = ResolutionType.Modifier;\n    }\n\n    return this.Expression(expression.definition, expression, resolution).andThen(() =>\n      this.Args(expression.args)\n    );\n  }\n\n  Log(expression: mir.Log): Result<null> {\n    return this.Positional(expression.positional, expression);\n  }\n\n  errorFor(name: string, span: HasSourceSpan, type = ResolutionType.Value): Result<never> {\n    return Err(\n      generateSyntaxError(\n        `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${name}`,\n        loc(span)\n      )\n    );\n  }\n}\n","import type {\n  CurriedType,\n  Nullable,\n  SerializedInlineBlock,\n  SerializedTemplateBlock,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { dict, exhausted } from '@glimmer/util';\nimport { CurriedTypes } from '@glimmer/vm';\nimport { SexpOpcodes as Op } from '@glimmer/wire-format';\n\nimport { inflateAttrName, inflateTagName } from './utils';\n\nexport default class WireFormatDebugger {\n  private upvars: string[];\n  private symbols: string[];\n\n  constructor([_statements, symbols, _hasEval, upvars]: SerializedTemplateBlock) {\n    this.upvars = upvars;\n    this.symbols = symbols;\n  }\n\n  format(program: SerializedTemplateBlock): unknown {\n    let out = [];\n\n    for (let statement of program[0]) {\n      out.push(this.formatOpcode(statement));\n    }\n\n    return out;\n  }\n\n  formatOpcode(opcode: WireFormat.Syntax): unknown {\n    if (Array.isArray(opcode)) {\n      switch (opcode[0]) {\n        case Op.Append:\n          return ['append', this.formatOpcode(opcode[1])];\n        case Op.TrustingAppend:\n          return ['trusting-append', this.formatOpcode(opcode[1])];\n\n        case Op.Block:\n          return [\n            'block',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.InElement:\n          return [\n            'in-element',\n            opcode[1],\n            this.formatOpcode(opcode[2]),\n            opcode[3] ? this.formatOpcode(opcode[3]) : undefined,\n          ];\n\n        case Op.OpenElement:\n          return ['open-element', inflateTagName(opcode[1])];\n\n        case Op.OpenElementWithSplat:\n          return ['open-element-with-splat', inflateTagName(opcode[1])];\n\n        case Op.CloseElement:\n          return ['close-element'];\n\n        case Op.FlushElement:\n          return ['flush-element'];\n\n        case Op.StaticAttr:\n          return ['static-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.StaticComponentAttr:\n          return ['static-component-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.DynamicAttr:\n          return [\n            'dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.ComponentAttr:\n          return [\n            'component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.AttrSplat:\n          return ['attr-splat'];\n\n        case Op.Yield:\n          return ['yield', opcode[1], this.formatParams(opcode[2])];\n\n        case Op.DynamicArg:\n          return ['dynamic-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.StaticArg:\n          return ['static-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.TrustingDynamicAttr:\n          return [\n            'trusting-dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.TrustingComponentAttr:\n          return [\n            'trusting-component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.Debugger:\n          return ['debugger', opcode[1]];\n\n        case Op.Comment:\n          return ['comment', opcode[1]];\n\n        case Op.Modifier:\n          return [\n            'modifier',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Component:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatElementParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.HasBlock:\n          return ['has-block', this.formatOpcode(opcode[1])];\n\n        case Op.HasBlockParams:\n          return ['has-block-params', this.formatOpcode(opcode[1])];\n\n        case Op.Curry:\n          return [\n            'curry',\n            this.formatOpcode(opcode[1]),\n            this.formatCurryType(opcode[2]),\n            this.formatParams(opcode[3]),\n            this.formatHash(opcode[4]),\n          ];\n\n        case Op.Undefined:\n          return ['undefined'];\n\n        case Op.Call:\n          return [\n            'call',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Concat:\n          return ['concat', this.formatParams(opcode[1] as WireFormat.Core.Params)];\n\n        case Op.GetStrictKeyword:\n          return ['get-strict-free', this.upvars[opcode[1]]];\n\n        case Op.GetFreeAsComponentOrHelperHead:\n          return ['GetFreeAsComponentOrHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsHelperHead:\n          return ['GetFreeAsHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsComponentHead:\n          return ['GetFreeAsComponentHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsModifierHead:\n          return ['GetFreeAsModifierHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetSymbol: {\n          if (opcode[1] === 0) {\n            return ['get-symbol', 'this', opcode[2]];\n          } else {\n            return ['get-symbol', this.symbols[opcode[1] - 1], opcode[2]];\n          }\n        }\n\n        case Op.GetLexicalSymbol: {\n          return ['get-template-symbol', opcode[1], opcode[2]];\n        }\n\n        case Op.If:\n          return [\n            'if',\n            this.formatOpcode(opcode[1]),\n            this.formatBlock(opcode[2]),\n            opcode[3] ? this.formatBlock(opcode[3]) : null,\n          ];\n\n        case Op.IfInline:\n          return ['if-inline'];\n\n        case Op.Not:\n          return ['not'];\n\n        case Op.Each:\n          return [\n            'each',\n            this.formatOpcode(opcode[1]),\n            opcode[2] ? this.formatOpcode(opcode[2]) : null,\n            this.formatBlock(opcode[3]),\n            opcode[4] ? this.formatBlock(opcode[4]) : null,\n          ];\n\n        case Op.Let:\n          return ['let', this.formatParams(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.Log:\n          return ['log', this.formatParams(opcode[1])];\n\n        case Op.WithDynamicVars:\n          return ['-with-dynamic-vars', this.formatHash(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.GetDynamicVar:\n          return ['-get-dynamic-vars', this.formatOpcode(opcode[1])];\n\n        case Op.InvokeComponent:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n      }\n    } else {\n      return opcode;\n    }\n  }\n\n  private formatCurryType(value: CurriedType) {\n    switch (value) {\n      case CurriedTypes.Component:\n        return 'component';\n      case CurriedTypes.Helper:\n        return 'helper';\n      case CurriedTypes.Modifier:\n        return 'modifier';\n      default:\n        throw exhausted(value);\n    }\n  }\n\n  private formatElementParams(\n    opcodes: Nullable<WireFormat.ElementParameter[]>\n  ): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatParams(opcodes: Nullable<WireFormat.Expression[]>): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatHash(hash: WireFormat.Core.Hash): Nullable<object> {\n    if (hash === null) return null;\n\n    return hash[0].reduce((accum, key, index) => {\n      accum[key] = this.formatOpcode(hash[1][index]);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlocks(blocks: WireFormat.Core.Blocks): Nullable<object> {\n    if (blocks === null) return null;\n\n    return blocks[0].reduce((accum, key, index) => {\n      accum[key] = this.formatBlock(blocks[1][index] as SerializedInlineBlock);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlock(block: SerializedInlineBlock): object {\n    return {\n      statements: block[0].map((s) => this.formatOpcode(s)),\n      parameters: block[1],\n    };\n  }\n}\n","import type { PresentArray, WireFormat } from '@glimmer/interfaces';\nimport type { ASTv2 } from '@glimmer/syntax';\nimport { assert, assertPresentArray, isPresentArray, mapPresentArray } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type * as mir from './mir';\n\nexport type HashPair = [string, WireFormat.Expression];\n\nexport class ExpressionEncoder {\n  expr(expr: mir.ExpressionNode): WireFormat.Expression {\n    switch (expr.type) {\n      case 'Missing':\n        return undefined;\n      case 'Literal':\n        return this.Literal(expr);\n      case 'Keyword':\n        return this.Keyword(expr);\n      case 'CallExpression':\n        return this.CallExpression(expr);\n      case 'PathExpression':\n        return this.PathExpression(expr);\n      case 'Arg':\n        return [SexpOpcodes.GetSymbol, expr.symbol];\n      case 'Local':\n        return this.Local(expr);\n      case 'This':\n        return [SexpOpcodes.GetSymbol, 0];\n      case 'Free':\n        return [expr.resolution.resolution(), expr.symbol];\n      case 'HasBlock':\n        return this.HasBlock(expr);\n      case 'HasBlockParams':\n        return this.HasBlockParams(expr);\n      case 'Curry':\n        return this.Curry(expr);\n      case 'Not':\n        return this.Not(expr);\n      case 'IfInline':\n        return this.IfInline(expr);\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expr);\n      case 'GetDynamicVar':\n        return this.GetDynamicVar(expr);\n      case 'Log':\n        return this.Log(expr);\n    }\n  }\n\n  Literal({\n    value,\n  }: ASTv2.LiteralExpression): WireFormat.Expressions.Value | WireFormat.Expressions.Undefined {\n    if (value === undefined) {\n      return [SexpOpcodes.Undefined];\n    } else {\n      return value;\n    }\n  }\n\n  Missing(): undefined {\n    return undefined;\n  }\n\n  HasBlock({ symbol }: mir.HasBlock): WireFormat.Expressions.HasBlock {\n    return [SexpOpcodes.HasBlock, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  HasBlockParams({ symbol }: mir.HasBlockParams): WireFormat.Expressions.HasBlockParams {\n    return [SexpOpcodes.HasBlockParams, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  Curry({ definition, curriedType, args }: mir.Curry): WireFormat.Expressions.Curry {\n    return [\n      SexpOpcodes.Curry,\n      EXPR.expr(definition),\n      curriedType,\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n    ];\n  }\n\n  Local({\n    isTemplateLocal,\n    symbol,\n  }: ASTv2.LocalVarReference):\n    | WireFormat.Expressions.GetSymbol\n    | WireFormat.Expressions.GetLexicalSymbol {\n    return [isTemplateLocal ? SexpOpcodes.GetLexicalSymbol : SexpOpcodes.GetSymbol, symbol];\n  }\n\n  Keyword({ symbol }: ASTv2.KeywordExpression): WireFormat.Expressions.GetStrictFree {\n    return [SexpOpcodes.GetStrictKeyword, symbol];\n  }\n\n  PathExpression({ head, tail }: mir.PathExpression): WireFormat.Expressions.GetPath {\n    let getOp = EXPR.expr(head) as WireFormat.Expressions.GetVar;\n    assert(getOp[0] !== SexpOpcodes.GetStrictKeyword, '[BUG] keyword in a PathExpression');\n    return [...getOp, EXPR.Tail(tail)];\n  }\n\n  InterpolateExpression({ parts }: mir.InterpolateExpression): WireFormat.Expressions.Concat {\n    return [SexpOpcodes.Concat, parts.map((e) => EXPR.expr(e)).toArray()];\n  }\n\n  CallExpression({ callee, args }: mir.CallExpression): WireFormat.Expressions.Helper {\n    return [SexpOpcodes.Call, EXPR.expr(callee), ...EXPR.Args(args)];\n  }\n\n  Tail({ members }: mir.Tail): PresentArray<string> {\n    return mapPresentArray(members, (member) => member.chars);\n  }\n\n  Args({ positional, named }: mir.Args): WireFormat.Core.Args {\n    return [this.Positional(positional), this.NamedArguments(named)];\n  }\n\n  Positional({ list }: mir.Positional): WireFormat.Core.Params {\n    return list.map((l) => EXPR.expr(l)).toPresentArray();\n  }\n\n  NamedArgument({ key, value }: mir.NamedArgument): HashPair {\n    return [key.chars, EXPR.expr(value)];\n  }\n\n  NamedArguments({ entries: pairs }: mir.NamedArguments): WireFormat.Core.Hash {\n    let list = pairs.toArray();\n\n    if (isPresentArray(list)) {\n      let names: string[] = [];\n      let values: WireFormat.Expression[] = [];\n\n      for (let pair of list) {\n        let [name, value] = EXPR.NamedArgument(pair);\n        names.push(name);\n        values.push(value);\n      }\n\n      assertPresentArray(names);\n      assertPresentArray(values);\n\n      return [names, values];\n    } else {\n      return null;\n    }\n  }\n\n  Not({ value }: mir.Not): WireFormat.Expressions.Not {\n    return [SexpOpcodes.Not, EXPR.expr(value)];\n  }\n\n  IfInline({ condition, truthy, falsy }: mir.IfInline): WireFormat.Expressions.IfInline {\n    let expr = [SexpOpcodes.IfInline, EXPR.expr(condition), EXPR.expr(truthy)];\n\n    if (falsy) {\n      expr.push(EXPR.expr(falsy));\n    }\n\n    return expr as WireFormat.Expressions.IfInline;\n  }\n\n  GetDynamicVar({ name }: mir.GetDynamicVar): WireFormat.Expressions.GetDynamicVar {\n    return [SexpOpcodes.GetDynamicVar, EXPR.expr(name)];\n  }\n\n  Log({ positional }: mir.Log): WireFormat.Expressions.Log {\n    return [SexpOpcodes.Log, this.Positional(positional)];\n  }\n}\n\nexport const EXPR = new ExpressionEncoder();\n","import type {\n  AttrOpcode,\n  ComponentAttrOpcode,\n  DynamicAttrOpcode,\n  StaticAttrOpcode,\n  StaticComponentAttrOpcode,\n  TrustingComponentAttrOpcode,\n  TrustingDynamicAttrOpcode,\n  WellKnownAttrName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { exhausted, LOCAL_LOGGER } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { OptionalList } from '../../shared/list';\nimport type * as mir from './mir';\n\nimport { deflateAttrName, deflateTagName } from '../../utils';\nimport { EXPR } from './expressions';\n\nclass WireStatements<S extends WireFormat.Statement = WireFormat.Statement> {\n  constructor(private statements: readonly S[]) {}\n\n  toArray(): readonly S[] {\n    return this.statements;\n  }\n}\n\nexport class ContentEncoder {\n  list(statements: mir.Statement[]): WireFormat.Statement[] {\n    let out: WireFormat.Statement[] = [];\n\n    for (let statement of statements) {\n      let result = CONTENT.content(statement);\n\n      if (result && result instanceof WireStatements) {\n        out.push(...result.toArray());\n      } else {\n        out.push(result);\n      }\n    }\n\n    return out;\n  }\n\n  content(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    if (LOCAL_SHOULD_LOG) {\n      LOCAL_LOGGER.log(`encoding`, stmt);\n    }\n\n    return this.visitContent(stmt);\n  }\n\n  private visitContent(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    switch (stmt.type) {\n      case 'Debugger':\n        return [SexpOpcodes.Debugger, stmt.scope.getDebugInfo()];\n      case 'AppendComment':\n        return this.AppendComment(stmt);\n      case 'AppendTextNode':\n        return this.AppendTextNode(stmt);\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(stmt);\n      case 'Yield':\n        return this.Yield(stmt);\n      case 'Component':\n        return this.Component(stmt);\n      case 'SimpleElement':\n        return this.SimpleElement(stmt);\n      case 'InElement':\n        return this.InElement(stmt);\n      case 'InvokeBlock':\n        return this.InvokeBlock(stmt);\n      case 'If':\n        return this.If(stmt);\n      case 'Each':\n        return this.Each(stmt);\n      case 'Let':\n        return this.Let(stmt);\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(stmt);\n      case 'InvokeComponent':\n        return this.InvokeComponent(stmt);\n      default:\n        return exhausted(stmt);\n    }\n  }\n\n  Yield({ to, positional }: mir.Yield): WireFormat.Statements.Yield {\n    return [SexpOpcodes.Yield, to, EXPR.Positional(positional)];\n  }\n\n  InElement({\n    guid,\n    insertBefore,\n    destination,\n    block,\n  }: mir.InElement): WireFormat.Statements.InElement {\n    let wireBlock = CONTENT.NamedBlock(block)[1];\n    // let guid = args.guid;\n    let wireDestination = EXPR.expr(destination);\n    let wireInsertBefore = EXPR.expr(insertBefore);\n\n    if (wireInsertBefore === undefined) {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination];\n    } else {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination, wireInsertBefore];\n    }\n  }\n\n  InvokeBlock({ head, args, blocks }: mir.InvokeBlock): WireFormat.Statements.Block {\n    return [SexpOpcodes.Block, EXPR.expr(head), ...EXPR.Args(args), CONTENT.NamedBlocks(blocks)];\n  }\n\n  AppendTrustedHTML({ html }: mir.AppendTrustedHTML): WireFormat.Statements.TrustingAppend {\n    return [SexpOpcodes.TrustingAppend, EXPR.expr(html)];\n  }\n\n  AppendTextNode({ text }: mir.AppendTextNode): WireFormat.Statements.Append {\n    return [SexpOpcodes.Append, EXPR.expr(text)];\n  }\n\n  AppendComment({ value }: mir.AppendComment): WireFormat.Statements.Comment {\n    return [SexpOpcodes.Comment, value.chars];\n  }\n\n  SimpleElement({ tag, params, body, dynamicFeatures }: mir.SimpleElement): WireStatements {\n    let op = dynamicFeatures ? SexpOpcodes.OpenElementWithSplat : SexpOpcodes.OpenElement;\n    return new WireStatements<WireFormat.Statement | WireFormat.ElementParameter>([\n      [op, deflateTagName(tag.chars)],\n      ...CONTENT.ElementParameters(params).toArray(),\n      [SexpOpcodes.FlushElement],\n      ...CONTENT.list(body),\n      [SexpOpcodes.CloseElement],\n    ]);\n  }\n\n  Component({ tag, params, args, blocks }: mir.Component): WireFormat.Statements.Component {\n    let wireTag = EXPR.expr(tag);\n    let wirePositional = CONTENT.ElementParameters(params);\n    let wireNamed = EXPR.NamedArguments(args);\n\n    let wireNamedBlocks = CONTENT.NamedBlocks(blocks);\n\n    return [\n      SexpOpcodes.Component,\n      wireTag,\n      wirePositional.toPresentArray(),\n      wireNamed,\n      wireNamedBlocks,\n    ];\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): OptionalList<WireFormat.ElementParameter> {\n    return body.map((p) => CONTENT.ElementParameter(p));\n  }\n\n  ElementParameter(param: mir.ElementParameter): WireFormat.ElementParameter {\n    switch (param.type) {\n      case 'SplatAttr':\n        return [SexpOpcodes.AttrSplat, param.symbol];\n      case 'DynamicAttr':\n        return [dynamicAttrOp(param.kind), ...dynamicAttr(param)];\n      case 'StaticAttr':\n        return [staticAttrOp(param.kind), ...staticAttr(param)];\n      case 'Modifier':\n        return [SexpOpcodes.Modifier, EXPR.expr(param.callee), ...EXPR.Args(param.args)];\n    }\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): WireFormat.Core.Blocks {\n    let names: string[] = [];\n    let serializedBlocks: WireFormat.SerializedInlineBlock[] = [];\n\n    for (let block of blocks.toArray()) {\n      let [name, serializedBlock] = CONTENT.NamedBlock(block);\n\n      names.push(name);\n      serializedBlocks.push(serializedBlock);\n    }\n\n    return names.length > 0 ? [names, serializedBlocks] : null;\n  }\n\n  NamedBlock({ name, body, scope }: mir.NamedBlock): WireFormat.Core.NamedBlock {\n    let nameChars = name.chars;\n    if (nameChars === 'inverse') {\n      nameChars = 'else';\n    }\n    return [nameChars, [CONTENT.list(body), scope.slots]];\n  }\n\n  If({ condition, block, inverse }: mir.If): WireFormat.Statements.If {\n    return [\n      SexpOpcodes.If,\n      EXPR.expr(condition),\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Each({ value, key, block, inverse }: mir.Each): WireFormat.Statements.Each {\n    return [\n      SexpOpcodes.Each,\n      EXPR.expr(value),\n      key ? EXPR.expr(key) : null,\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Let({ positional, block }: mir.Let): WireFormat.Statements.Let {\n    return [SexpOpcodes.Let, EXPR.Positional(positional), CONTENT.NamedBlock(block)[1]];\n  }\n\n  WithDynamicVars({ named, block }: mir.WithDynamicVars): WireFormat.Statements.WithDynamicVars {\n    return [SexpOpcodes.WithDynamicVars, EXPR.NamedArguments(named), CONTENT.NamedBlock(block)[1]];\n  }\n\n  InvokeComponent({\n    definition,\n    args,\n    blocks,\n  }: mir.InvokeComponent): WireFormat.Statements.InvokeComponent {\n    return [\n      SexpOpcodes.InvokeComponent,\n      EXPR.expr(definition),\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n      blocks ? CONTENT.NamedBlocks(blocks) : null,\n    ];\n  }\n}\n\nexport const CONTENT = new ContentEncoder();\n\nexport type StaticAttrArgs = [name: string | WellKnownAttrName, value: string, namespace?: string];\n\nfunction staticAttr({ name, value, namespace }: mir.StaticAttr): StaticAttrArgs {\n  let out: StaticAttrArgs = [deflateAttrName(name.chars), value.chars];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nexport type DynamicAttrArgs = [\n  name: string | WellKnownAttrName,\n  value: WireFormat.Expression,\n  namespace?: string,\n];\n\nfunction dynamicAttr({ name, value, namespace }: mir.DynamicAttr): DynamicAttrArgs {\n  let out: DynamicAttrArgs = [deflateAttrName(name.chars), EXPR.expr(value)];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nfunction staticAttrOp(kind: { component: boolean }): StaticAttrOpcode | StaticComponentAttrOpcode;\nfunction staticAttrOp(kind: { component: boolean }): AttrOpcode {\n  if (kind.component) {\n    return SexpOpcodes.StaticComponentAttr;\n  } else {\n    return SexpOpcodes.StaticAttr;\n  }\n}\n\nfunction dynamicAttrOp(\n  kind: mir.AttrKind\n):\n  | TrustingComponentAttrOpcode\n  | TrustingDynamicAttrOpcode\n  | ComponentAttrOpcode\n  | DynamicAttrOpcode {\n  if (kind.component) {\n    return kind.trusting ? SexpOpcodes.TrustingComponentAttr : SexpOpcodes.ComponentAttr;\n  } else {\n    return kind.trusting ? SexpOpcodes.TrustingDynamicAttr : SexpOpcodes.DynamicAttr;\n  }\n}\n","import type {\n  Nullable,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  TemplateJavascript,\n} from '@glimmer/interfaces';\nimport type {\n  PrecompileOptions,\n  PrecompileOptionsWithLexicalScope,\n  TemplateIdFn,\n} from '@glimmer/syntax';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { normalize, src } from '@glimmer/syntax';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport pass0 from './passes/1-normalization/index';\nimport { visit as pass2 } from './passes/2-encoding/index';\n\ndeclare function require(id: 'crypto'): Crypto;\ndeclare function require(id: string): unknown;\n\ninterface Crypto {\n  createHash(alg: 'sha1'): {\n    update(src: string, encoding: 'utf8'): void;\n    digest(encoding: 'base64'): string;\n  };\n}\n\nexport const defaultId: TemplateIdFn = (() => {\n  const req: typeof require | undefined =\n    typeof module === 'object' && typeof module.require === 'function'\n      ? module.require\n      : globalThis.require;\n\n  if (req) {\n    try {\n      const crypto = req('crypto');\n\n      const idFn: TemplateIdFn = (src) => {\n        const hash = crypto.createHash('sha1');\n        hash.update(src, 'utf8');\n        // trim to 6 bytes of data (2^48 - 1)\n        return hash.digest('base64').substring(0, 8);\n      };\n\n      idFn('test');\n\n      return idFn;\n    } catch {\n      // do nothing\n    }\n  }\n\n  return function idFn() {\n    return null;\n  };\n})();\n\nconst defaultOptions: PrecompileOptions = {\n  id: defaultId,\n};\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompileJSON(\n  string: Nullable<string>,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): [block: SerializedTemplateBlock, usedLocals: string[]] {\n  const source = new src.Source(string ?? '', options.meta?.moduleName);\n  const [ast, locals] = normalize(source, { lexicalScope: () => false, ...options });\n  const block = pass0(source, ast, options.strictMode ?? false).mapOk((pass2In) => {\n    return pass2(pass2In);\n  });\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.log(`Template ->`, block);\n  }\n\n  if (block.isOk) {\n    return [block.value, locals];\n  } else {\n    throw block.reason;\n  }\n}\n\n// UUID used as a unique placeholder for placing a snippet of JS code into\n// the otherwise JSON stringified value below.\nconst SCOPE_PLACEHOLDER = '796d24e6-2450-4fb0-8cdf-b65638b5ef70';\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompile(\n  source: string,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): TemplateJavascript {\n  const [block, usedLocals] = precompileJSON(source, options);\n\n  const moduleName = options.meta?.moduleName;\n  const idFn = options.id || defaultId;\n  const blockJSON = JSON.stringify(block);\n  const templateJSONObject: SerializedTemplateWithLazyBlock = {\n    id: idFn(JSON.stringify(options.meta) + blockJSON),\n    block: blockJSON,\n    moduleName: moduleName ?? '(unknown template module)',\n    // lying to the type checker here because we're going to\n    // replace it just below, after stringification\n    scope: SCOPE_PLACEHOLDER as unknown as null,\n    isStrictMode: options.strictMode ?? false,\n  };\n\n  if (usedLocals.length === 0) {\n    delete templateJSONObject.scope;\n  }\n\n  // JSON is javascript\n  let stringified = JSON.stringify(templateJSONObject);\n\n  if (usedLocals.length > 0) {\n    const scopeFn = `()=>[${usedLocals.join(',')}]`;\n\n    stringified = stringified.replace(`\"${SCOPE_PLACEHOLDER}\"`, scopeFn);\n  }\n\n  return stringified;\n}\n\nexport type { PrecompileOptions };\n","import type { ASTv2, src } from '@glimmer/syntax';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type { Result } from '../../shared/result';\n\nimport * as mir from '../2-encoding/mir';\nimport { NormalizationState } from './context';\nimport { VISIT_STMTS } from './visitors/statements';\nimport StrictModeValidationPass from './visitors/strict-mode';\n\n/**\n * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special\n * instructions for keywords like `{{yield}}`, `(has-block)` and\n * `{{#in-element}}`.\n *\n * Most importantly, it also classifies HTML element syntax into:\n *\n * 1. simple HTML element (with optional splattributes)\n * 2. component invocation\n *\n * Because the @glimmer/syntax AST gives us a string for an element's tag,\n * this pass also normalizes that string into an expression.\n *\n * ```\n * // normalized into a path expression whose head is `this` and tail is\n * // `[\"x\"]`\n * <this.x />\n *\n * {{#let expr as |t|}}\n *   // `\"t\"` is normalized into a variable lookup.\n *   <t />\n *\n *   // normalized into a path expression whose head is the variable lookup\n *   // `t` and tail is `[\"input\"]`.\n *   <t.input />\n * {{/let}}\n *\n * // normalized into a free variable lookup for `SomeComponent` (with the\n * // context `ComponentHead`).\n * <SomeComponent />\n *\n * // normalized into a path expression whose head is the free variable\n * // `notInScope` (with the context `Expression`), and whose tail is\n * // `[\"SomeComponent\"]`. In resolver mode, this path will be rejected later,\n * // since it cannot serve as an input to the resolver.\n * <notInScope.SomeComponent />\n * ```\n */\nexport default function normalize(\n  source: src.Source,\n  root: ASTv2.Template,\n  isStrict: boolean\n): Result<mir.Template> {\n  // create a new context for the normalization pass\n  let state = new NormalizationState(root.table, isStrict);\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.groupCollapsed(`pass0: visiting`);\n    LOCAL_LOGGER.log('symbols', root.table);\n    LOCAL_LOGGER.log('source', source);\n    LOCAL_LOGGER.groupEnd();\n  }\n\n  let body = VISIT_STMTS.visitList(root.body, state);\n\n  if (LOCAL_SHOULD_LOG) {\n    if (body.isOk) {\n      LOCAL_LOGGER.log('-> pass0: out', body.value);\n    } else {\n      LOCAL_LOGGER.log('-> pass0: error', body.reason);\n    }\n  }\n\n  let template = body.mapOk(\n    (body) => new mir.Template({ loc: root.loc, scope: root.table, body: body.toArray() })\n  );\n\n  if (isStrict) {\n    template = template.andThen((template) => StrictModeValidationPass.validate(template));\n  }\n\n  return template;\n}\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type * as mir from './mir';\n\nimport WireFormatDebugger from '../../wire-format-debug';\nimport { CONTENT } from './content';\n\nexport function visit(template: mir.Template): WireFormat.SerializedTemplateBlock {\n  let statements = CONTENT.list(template.body);\n  let scope = template.scope;\n  let block: WireFormat.SerializedTemplateBlock = [\n    statements,\n    scope.symbols,\n    scope.hasEval,\n    scope.upvars,\n  ];\n\n  if (LOCAL_SHOULD_LOG) {\n    let debug = new WireFormatDebugger(block);\n    LOCAL_LOGGER.log(\n      `-> `,\n      statements.map((s) => debug.formatOpcode(s))\n    );\n  }\n\n  return block;\n}\n"],"names":["HeadKind","VariableKind","normalizeStatement","statement","Array","isArray","name","Builder","Literal","Get","Concat","HasBlock","HasBlockParams","statementIsExpression","normalizeAppendExpression","isSugaryArrayStatement","params","hash","length","normalizeParams","normalizeHash","kind","Call","head","normalizeCallHead","trusted","path","blocks","blockParams","normalizeBuilderBlockStatement","Block","slice","Keyword","attrs","dict","block","normalizeAttrs","normalizeBlock","Element","expect","extractElement","Error","JSON","stringify","normalizeSugaryArrayStatement","value","Append","Modifier","DynamicComponent","expr","normalizeExpression","Comment","normalizeVerboseStatement","normalizeAppendHead","normalizeDottedPath","assertNever","type","ExpressionKind","GetPath","AppendPath","AppendExpr","extractBlockHead","result","exec","normalizePath","tail","pathHead","normalizePathHead","isPresentArray","GetVar","variable","whole","rest","split","mode","test","This","Free","Arg","Local","normalizeBlocks","normalizeBlockHash","out","callback","Object","keys","forEach","key","entries","default","mapObject","map","s","a","normalizeAttr","attr","Splat","object","mapper","k","input","match","expression","forceTrusted","isBuilderCallExpression","normalizeCallExpression","ProgramSymbols","_freeVariables","_symbols","top","this","toSymbols","toUpvars","freeVar","addString","symbol","arg","local","hasLocal","_name","child","locals","LocalSymbols","constructor","parent","paramSymbols","values","array","item","index","indexOf","push","unimpl","message","buildStatements","statements","symbols","buildStatement","buildNormalizedStatements","normalized","Op","TrustingAppend","buildGetPath","buildExpression","builtParams","buildParams","builtHash","buildHash","builtExpr","buildCallHead","VariableResolutionContext","ResolveAsHelperHead","ResolveAsComponentOrHelperHead","buildBlock","buildBlocks","ResolveAsComponentHead","buildKeyword","hasSplat","OpenElementWithSplat","OpenElement","args","AttrSplat","buildAttributeValue","extractNamespace","buildElementParams","assert","FlushElement","CloseElement","buildElement","arr","interpolated","reduce","string","i","String","c","unicode","charCode","fromCharCode","parseInt","NEWLINE","childSymbols","inverse","Let","If","keyExpr","Each","some","NS_XMLNS","NS_XLINK","NS_XML","namespace","val","StaticAttr","undefined","DynamicAttr","varContext","context","bare","buildVar","buildConcat","Strict","Undefined","callHead","sym","op","GetSymbol","GetStrictKeyword","GetFreeAsComponentOrHelperHead","GetFreeAsHelperHead","ResolveAsModifierHead","GetFreeAsModifierHead","GetFreeAsComponentHead","exhausted","expressionContextOp","getSymbolForVar","exprs","e","Template","node","fields","InElement","Not","IfInline","WithDynamicVars","GetDynamicVar","Log","InvokeComponent","NamedBlocks","NamedBlock","AppendTrustedHTML","AppendTextNode","AppendComment","Component","SimpleElement","ElementParameters","Yield","Debugger","CallExpression","InvokeBlock","SplatAttr","PathExpression","Missing","InterpolateExpression","Curry","Positional","NamedArguments","NamedArgument","Args","Tail","PresentList","list","toArray","mapPresentArray","filter","predicate","OptionalList","toPresentArray","into","ifPresent","EmptyList","_callback","_predicate","ifEmpty","ResultImpl","all","results","isErr","cast","Ok","Result","OkImpl","isOk","super","_message","ifOk","andThen","mapOk","ifErr","mapErr","ErrImpl","reason","Err","ResultArray","items","add","err","toOptionalList","convertPathToCallIfKeyword","ref","KEYWORDS_TYPES","ASTv2","callee","empty","loc","VISIT_EXPRS","visit","state","Interpolate","translated","CALL_KEYWORDS","translate","visitList","nodes","VariableReference","tailLoc","extend","getLast","mir","members","literal","keyword","parts","positional","named","pairs","KeywordImpl","types","delegate","Set","nodeType","KEYWORD_NODES","has","getCalleeExpression","generateSyntaxError","asString","param","Keywords","_keywords","_type","kw","isKeyword","usedType","validTypes","includes","typesToReadableName","join","generateTypesMessage","keywords","toAppend","text","CurriedTypeToReadableType","CurriedTypes","Helper","assertCurryKeyword","curriedType","readableType","stringsAllowed","definition","nth","isStrict","PositionalArguments","translateCurryKeyword","definitionResult","argsResult","curryKeyword","getDynamicVarKeyword","call","positionals","isEmpty","varName","size","assertHasBlockKeyword","SourceSlice","synthetic","isLiteral","toSlice","translateHasBlockKeyword","scope","target","allocateBlock","chars","hasBlockKeyword","assertIfUnlessInlineKeyword","originalNode","inverted","condition","truthy","falsy","translateIfUnlessInlineKeyword","conditionResult","truthyResult","falsyResult","ifUnlessInlineKeyword","logKeyword","APPEND_KEYWORDS","src","SourceSpan","get","to","setHasDebugger","BLOCK_KEYWORDS","guid","insertBefore","destination","body","VISIT_STMTS","destinationResult","collapse","generateUniqueCursor","blockResult","inverseResult","every","valueResult","keyResult","positionalResult","namedResult","blocksResult","MODIFIER_KEYWORDS","XLINK","XML","XMLNS","WHITELIST","xmlns","DEFLATE_TAG_TABLE","div","WellKnownTagNames","span","p","INFLATE_TAG_TABLE","inflateTagName","tagName","DEFLATE_ATTR_TABLE","class","WellKnownAttrNames","id","style","href","INFLATE_ATTR_TABLE","deflateAttrName","attrName","inflateAttrName","ClassifiedElement","element","toStatement","prepare","prepared","rawValue","component","dynamicFeatures","isTrusting","trusting","modifier","typeAttr","simple","componentArgs","maybeLoc","NON_EXISTENT","modifiers","m","elementParams","ClassifiedComponent","tag","ClassifiedSimpleElement","isComponent","classified","AppendContent","TextNode","HtmlComment","b","visitBlock","hasDynamicFeatures","append","html","LiteralExpression","comment","NormalizationState","_currentScope","_cursorCount","oldBlock","ResolutionType","StrictModeValidationPass","validate","template","Statements","Statement","Expressions","expressions","Expression","resolution","errorFor","ElementParameter","inElement","ComponentOrHelper","Value","WireFormatDebugger","upvars","_statements","_hasEval","format","program","formatOpcode","opcode","formatParams","formatHash","formatBlocks","StaticComponentAttr","ComponentAttr","DynamicArg","StaticArg","TrustingDynamicAttr","TrustingComponentAttr","formatElementParams","formatCurryType","GetLexicalSymbol","formatBlock","opcodes","o","accum","parameters","EXPR","SexpOpcodes","isTemplateLocal","getOp","member","l","names","pair","assertPresentArray","WireStatements","CONTENT","content","stmt","visitContent","getDebugInfo","wireBlock","wireDestination","wireInsertBefore","wireTag","wirePositional","wireNamed","wireNamedBlocks","dynamicAttr","staticAttrOp","staticAttr","serializedBlocks","serializedBlock","nameChars","slots","defaultId","req","module","require","globalThis","crypto","idFn","createHash","update","digest","substring","defaultOptions","precompileJSON","options","source","Source","meta","moduleName","ast","normalize","lexicalScope","root","table","pass0","strictMode","pass2In","hasEval","pass2","SCOPE_PLACEHOLDER","precompile","usedLocals","blockJSON","templateJSONObject","isStrictMode","stringified","scopeFn","replace"],"mappings":"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"}