{"version":3,"file":"index.js","sources":["../../../debug/lib/opcode-metadata.ts","../../lib/scope.ts","../../lib/symbols.ts","../../lib/bounds.ts","../../lib/dom/normalize.ts","../../lib/dom/props.ts","../../lib/dom/sanitized-values.ts","../../lib/vm/attributes/dynamic.ts","../../lib/vm/element-builder.ts","../../lib/opcodes.ts","../../lib/curried-value.ts","../../lib/component/interfaces.ts","../../lib/compiled/opcodes/vm.ts","../../lib/compiled/opcodes/assert.ts","../../lib/compiled/opcodes/dom.ts","../../lib/compiled/opcodes/component.ts","../../lib/component/resolve.ts","../../lib/references/class-list.ts","../../lib/vm/arguments.ts","../../lib/compiled/expressions/concat.ts","../../lib/compiled/opcodes/expressions.ts","../../lib/references/curry-value.ts","../../lib/vm/content/text.ts","../../lib/compiled/opcodes/content.ts","../../lib/compiled/opcodes/debugger.ts","../../lib/compiled/opcodes/lists.ts","../../lib/component/template-only.ts","../../lib/dom/operations.ts","../../lib/compat/svg-inner-html-fix.ts","../../lib/compat/text-node-merging-fix.ts","../../lib/dom/api.ts","../../lib/dom/helper.ts","../../lib/debug-render-tree.ts","../../lib/environment.ts","../../lib/helpers/internal-helper.ts","../../lib/helpers/array.ts","../../lib/helpers/concat.ts","../../lib/helpers/fn.ts","../../lib/helpers/get.ts","../../lib/helpers/hash.ts","../../lib/helpers/invoke.ts","../../lib/modifiers/on.ts","../../lib/vm/low-level.ts","../../lib/vm/update.ts","../../lib/vm/render-result.ts","../../lib/vm/stack.ts","../../lib/vm/append.ts","../../lib/render.ts","../../lib/vm/rehydrate-builder.ts"],"sourcesContent":["/* This file is generated by build/debug.js */\n\nimport type { Nullable, VmMachineOp, VmOp } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { NormalizedMetadata } from './metadata';\n\nexport function opcodeMetadata(\n  op: VmMachineOp | VmOp,\n  isMachine: 0 | 1\n): Nullable<NormalizedMetadata> {\n  if (!LOCAL_DEBUG) {\n    return null;\n  }\n\n  let value = isMachine ? MACHINE_METADATA[op] : METADATA[op];\n\n  return value || null;\n}\n\nconst METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\nconst MACHINE_METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\n\nif (LOCAL_DEBUG) {\n  MACHINE_METADATA[MachineOp.PushFrame] = {\n    name: 'PushFrame',\n    mnemonic: 'pushf',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.PopFrame] = {\n    name: 'PopFrame',\n    mnemonic: 'popf',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeVirtual] = {\n    name: 'InvokeVirtual',\n    mnemonic: 'vcall',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeStatic] = {\n    name: 'InvokeStatic',\n    mnemonic: 'scall',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Jump] = {\n    name: 'Jump',\n    mnemonic: 'goto',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Return] = {\n    name: 'Return',\n    mnemonic: 'ret',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.ReturnTo] = {\n    name: 'ReturnTo',\n    mnemonic: 'setra',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'i32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n  METADATA[Op.Helper] = {\n    name: 'Helper',\n    mnemonic: 'ncall',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DynamicHelper] = {\n    name: 'DynamicHelper',\n    mnemonic: 'dynamiccall',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.SetNamedVariables] = {\n    name: 'SetNamedVariables',\n    mnemonic: 'vsargs',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlocks] = {\n    name: 'SetBlocks',\n    mnemonic: 'vbblocks',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetVariable] = {\n    name: 'SetVariable',\n    mnemonic: 'sbvar',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlock] = {\n    name: 'SetBlock',\n    mnemonic: 'sblock',\n    before: null,\n    stackChange: -3,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetVariable] = {\n    name: 'GetVariable',\n    mnemonic: 'symload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetProperty] = {\n    name: 'GetProperty',\n    mnemonic: 'getprop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'property',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetBlock] = {\n    name: 'GetBlock',\n    mnemonic: 'blockload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'block',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SpreadBlock] = {\n    name: 'SpreadBlock',\n    mnemonic: 'blockspread',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlock] = {\n    name: 'HasBlock',\n    mnemonic: 'hasblockload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlockParams] = {\n    name: 'HasBlockParams',\n    mnemonic: 'hasparamsload',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Concat] = {\n    name: 'Concat',\n    mnemonic: 'concat',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.IfInline] = {\n    name: 'IfInline',\n    mnemonic: 'ifinline',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Not] = {\n    name: 'Not',\n    mnemonic: 'not',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Constant] = {\n    name: 'Constant',\n    mnemonic: 'rconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ConstantReference] = {\n    name: 'ConstantReference',\n    mnemonic: 'rconstrefload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Primitive] = {\n    name: 'Primitive',\n    mnemonic: 'pconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'primitive',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PrimitiveReference] = {\n    name: 'PrimitiveReference',\n    mnemonic: 'ptoref',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ReifyU32] = {\n    name: 'ReifyU32',\n    mnemonic: 'reifyload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Dup] = {\n    name: 'Dup',\n    mnemonic: 'dup',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.Pop] = {\n    name: 'Pop',\n    mnemonic: 'pop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Load] = {\n    name: 'Load',\n    mnemonic: 'put',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Fetch] = {\n    name: 'Fetch',\n    mnemonic: 'regload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.RootScope] = {\n    name: 'RootScope',\n    mnemonic: 'rscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.VirtualRootScope] = {\n    name: 'VirtualRootScope',\n    mnemonic: 'vrscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ChildScope] = {\n    name: 'ChildScope',\n    mnemonic: 'cscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopScope] = {\n    name: 'PopScope',\n    mnemonic: 'scopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Text] = {\n    name: 'Text',\n    mnemonic: 'apnd_text',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Comment] = {\n    name: 'Comment',\n    mnemonic: 'apnd_comment',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.AppendHTML] = {\n    name: 'AppendHTML',\n    mnemonic: 'apnd_dynhtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendSafeHTML] = {\n    name: 'AppendSafeHTML',\n    mnemonic: 'apnd_dynshtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendDocumentFragment] = {\n    name: 'AppendDocumentFragment',\n    mnemonic: 'apnd_dynfrag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendNode] = {\n    name: 'AppendNode',\n    mnemonic: 'apnd_dynnode',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendText] = {\n    name: 'AppendText',\n    mnemonic: 'apnd_dyntext',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.OpenElement] = {\n    name: 'OpenElement',\n    mnemonic: 'apnd_tag',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'tag',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.OpenDynamicElement] = {\n    name: 'OpenDynamicElement',\n    mnemonic: 'apnd_dyntag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushRemoteElement] = {\n    name: 'PushRemoteElement',\n    mnemonic: 'apnd_remotetag',\n    before: null,\n    stackChange: -3,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.StaticAttr] = {\n    name: 'StaticAttr',\n    mnemonic: 'apnd_attr',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'value',\n        type: 'str',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.DynamicAttr] = {\n    name: 'DynamicAttr',\n    mnemonic: 'apnd_dynattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.ComponentAttr] = {\n    name: 'ComponentAttr',\n    mnemonic: 'apnd_cattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.FlushElement] = {\n    name: 'FlushElement',\n    mnemonic: 'apnd_flushtag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CloseElement] = {\n    name: 'CloseElement',\n    mnemonic: 'apnd_closetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopRemoteElement] = {\n    name: 'PopRemoteElement',\n    mnemonic: 'apnd_closeremotetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Modifier] = {\n    name: 'Modifier',\n    mnemonic: 'apnd_modifier',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindDynamicScope] = {\n    name: 'BindDynamicScope',\n    mnemonic: 'setdynscope',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicScope] = {\n    name: 'PushDynamicScope',\n    mnemonic: 'dynscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopDynamicScope] = {\n    name: 'PopDynamicScope',\n    mnemonic: 'dynscopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CompileBlock] = {\n    name: 'CompileBlock',\n    mnemonic: 'cmpblock',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushBlockScope] = {\n    name: 'PushBlockScope',\n    mnemonic: 'scopeload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'scope',\n        type: 'scope',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushSymbolTable] = {\n    name: 'PushSymbolTable',\n    mnemonic: 'dsymload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'table',\n        type: 'symbol-table',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeYield] = {\n    name: 'InvokeYield',\n    mnemonic: 'invokeyield',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.JumpIf] = {\n    name: 'JumpIf',\n    mnemonic: 'iftrue',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpUnless] = {\n    name: 'JumpUnless',\n    mnemonic: 'iffalse',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpEq] = {\n    name: 'JumpEq',\n    mnemonic: 'ifeq',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'i32',\n      },\n      {\n        name: 'comparison',\n        type: 'i32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.AssertSame] = {\n    name: 'AssertSame',\n    mnemonic: 'assert_eq',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Enter] = {\n    name: 'Enter',\n    mnemonic: 'blk_start',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'args',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Exit] = {\n    name: 'Exit',\n    mnemonic: 'blk_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ToBoolean] = {\n    name: 'ToBoolean',\n    mnemonic: 'anytobool',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.EnterList] = {\n    name: 'EnterList',\n    mnemonic: 'list_start',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'address',\n        type: 'u32',\n      },\n      {\n        name: 'address',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.ExitList] = {\n    name: 'ExitList',\n    mnemonic: 'list_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Iterate] = {\n    name: 'Iterate',\n    mnemonic: 'iter',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'end',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Main] = {\n    name: 'Main',\n    mnemonic: 'main',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ContentType] = {\n    name: 'ContentType',\n    mnemonic: 'ctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DynamicContentType] = {\n    name: 'DynamicContentType',\n    mnemonic: 'dctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Curry] = {\n    name: 'Curry',\n    mnemonic: 'curry',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'type',\n        type: 'u32',\n      },\n      {\n        name: 'is-strict',\n        type: 'bool',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.PushComponentDefinition] = {\n    name: 'PushComponentDefinition',\n    mnemonic: 'cmload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'spec',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicComponentInstance] = {\n    name: 'PushDynamicComponentInstance',\n    mnemonic: 'dciload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ResolveDynamicComponent] = {\n    name: 'ResolveDynamicComponent',\n    mnemonic: 'cdload',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'owner',\n        type: 'owner',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushArgs] = {\n    name: 'PushArgs',\n    mnemonic: 'argsload',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n      {\n        name: 'block-names',\n        type: 'str-array',\n      },\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.PushEmptyArgs] = {\n    name: 'PushEmptyArgs',\n    mnemonic: 'emptyargsload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopArgs] = {\n    name: 'PopArgs',\n    mnemonic: 'argspop',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PrepareArgs] = {\n    name: 'PrepareArgs',\n    mnemonic: 'argsprep',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.CaptureArgs] = {\n    name: 'CaptureArgs',\n    mnemonic: 'argscapture',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CreateComponent] = {\n    name: 'CreateComponent',\n    mnemonic: 'comp_create',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.RegisterComponentDestructor] = {\n    name: 'RegisterComponentDestructor',\n    mnemonic: 'comp_dest',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PutComponentOperations] = {\n    name: 'PutComponentOperations',\n    mnemonic: 'comp_elops',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentSelf] = {\n    name: 'GetComponentSelf',\n    mnemonic: 'comp_selfload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentTagName] = {\n    name: 'GetComponentTagName',\n    mnemonic: 'comp_tagload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentLayout] = {\n    name: 'GetComponentLayout',\n    mnemonic: 'comp_layoutload',\n    before: null,\n    stackChange: 2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindEvalScope] = {\n    name: 'BindEvalScope',\n    mnemonic: 'eval_scope',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetupForEval] = {\n    name: 'SetupForEval',\n    mnemonic: 'eval_setup',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PopulateLayout] = {\n    name: 'PopulateLayout',\n    mnemonic: 'comp_layoutput',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeComponentLayout] = {\n    name: 'InvokeComponentLayout',\n    mnemonic: 'comp_invokelayout',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BeginComponentTransaction] = {\n    name: 'BeginComponentTransaction',\n    mnemonic: 'comp_begin',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CommitComponentTransaction] = {\n    name: 'CommitComponentTransaction',\n    mnemonic: 'comp_commit',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DidCreateElement] = {\n    name: 'DidCreateElement',\n    mnemonic: 'comp_created',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DidRenderLayout] = {\n    name: 'DidRenderLayout',\n    mnemonic: 'comp_rendered',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ResolveMaybeLocal] = {\n    name: 'ResolveMaybeLocal',\n    mnemonic: 'eval_varload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'local',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Debugger] = {\n    name: 'Debugger',\n    mnemonic: 'debugger',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'str-array',\n      },\n      {\n        name: 'debugInfo',\n        type: 'array',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n}\n","import type {\n  Dict,\n  DynamicScope,\n  Nullable,\n  Owner,\n  PartialScope,\n  Scope,\n  ScopeBlock,\n  ScopeSlot,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { UNDEFINED_REFERENCE } from '@glimmer/reference';\nimport { assign, unwrap } from '@glimmer/util';\n\nexport class DynamicScopeImpl implements DynamicScope {\n  private bucket: Dict<Reference>;\n\n  constructor(bucket?: Dict<Reference>) {\n    if (bucket) {\n      this.bucket = assign({}, bucket);\n    } else {\n      this.bucket = {};\n    }\n  }\n\n  get(key: string): Reference {\n    return unwrap(this.bucket[key]);\n  }\n\n  set(key: string, reference: Reference): Reference {\n    return (this.bucket[key] = reference);\n  }\n\n  child(): DynamicScopeImpl {\n    return new DynamicScopeImpl(this.bucket);\n  }\n}\n\nexport function isScopeReference(s: ScopeSlot): s is Reference {\n  if (s === null || Array.isArray(s)) return false;\n  return true;\n}\n\nexport class PartialScopeImpl implements PartialScope {\n  static root(self: Reference<unknown>, size = 0, owner: Owner): PartialScope {\n    let refs: Reference<unknown>[] = new Array(size + 1).fill(UNDEFINED_REFERENCE);\n\n    return new PartialScopeImpl(refs, owner, null, null, null).init({ self });\n  }\n\n  static sized(size = 0, owner: Owner): Scope {\n    let refs: Reference<unknown>[] = new Array(size + 1).fill(UNDEFINED_REFERENCE);\n\n    return new PartialScopeImpl(refs, owner, null, null, null);\n  }\n\n  constructor(\n    // the 0th slot is `self`\n    readonly slots: Array<ScopeSlot>,\n    readonly owner: Owner,\n    private callerScope: Scope | null,\n    // named arguments and blocks passed to a layout that uses eval\n    private evalScope: Dict<ScopeSlot> | null,\n    // locals in scope when the partial was invoked\n    private partialMap: Dict<Reference<unknown>> | null\n  ) {}\n\n  init({ self }: { self: Reference<unknown> }): this {\n    this.slots[0] = self;\n    return this;\n  }\n\n  getSelf(): Reference<unknown> {\n    return this.get<Reference<unknown>>(0);\n  }\n\n  getSymbol(symbol: number): Reference<unknown> {\n    return this.get<Reference<unknown>>(symbol);\n  }\n\n  getBlock(symbol: number): Nullable<ScopeBlock> {\n    let block = this.get(symbol);\n    return block === UNDEFINED_REFERENCE ? null : (block as ScopeBlock);\n  }\n\n  getEvalScope(): Nullable<Dict<ScopeSlot>> {\n    return this.evalScope;\n  }\n\n  getPartialMap(): Nullable<Dict<Reference<unknown>>> {\n    return this.partialMap;\n  }\n\n  bind(symbol: number, value: ScopeSlot) {\n    this.set(symbol, value);\n  }\n\n  bindSelf(self: Reference<unknown>) {\n    this.set<Reference<unknown>>(0, self);\n  }\n\n  bindSymbol(symbol: number, value: Reference<unknown>) {\n    this.set(symbol, value);\n  }\n\n  bindBlock(symbol: number, value: Nullable<ScopeBlock>) {\n    this.set<Nullable<ScopeBlock>>(symbol, value);\n  }\n\n  bindEvalScope(map: Nullable<Dict<ScopeSlot>>) {\n    this.evalScope = map;\n  }\n\n  bindPartialMap(map: Dict<Reference<unknown>>) {\n    this.partialMap = map;\n  }\n\n  bindCallerScope(scope: Nullable<Scope>): void {\n    this.callerScope = scope;\n  }\n\n  getCallerScope(): Nullable<Scope> {\n    return this.callerScope;\n  }\n\n  child(): Scope {\n    return new PartialScopeImpl(\n      this.slots.slice(),\n      this.owner,\n      this.callerScope,\n      this.evalScope,\n      this.partialMap\n    );\n  }\n\n  private get<T extends ScopeSlot>(index: number): T {\n    if (index >= this.slots.length) {\n      throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    }\n\n    return this.slots[index] as T;\n  }\n\n  private set<T extends ScopeSlot>(index: number, value: T): void {\n    if (index >= this.slots.length) {\n      throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    }\n\n    this.slots[index] = value;\n  }\n}\n","// These symbols represent \"friend\" properties that are used inside of\n// the VM in other classes, but are not intended to be a part of\n// Glimmer's API.\n\nexport const INNER_VM: unique symbol = Symbol('INNER_VM');\nexport const DESTROYABLE_STACK: unique symbol = Symbol('DESTROYABLE_STACK');\nexport const STACKS: unique symbol = Symbol('STACKS');\nexport const REGISTERS: unique symbol = Symbol('REGISTERS');\nexport const HEAP: unique symbol = Symbol('HEAP');\nexport const CONSTANTS: unique symbol = Symbol('CONSTANTS');\nexport const ARGS: unique symbol = Symbol('ARGS');\nexport const PC: unique symbol = Symbol('PC');\n","import type { Bounds, Cursor, Nullable, SimpleElement, SimpleNode } from '@glimmer/interfaces';\nimport { expect } from '@glimmer/util';\n\nexport class CursorImpl implements Cursor {\n  constructor(\n    public element: SimpleElement,\n    public nextSibling: Nullable<SimpleNode>\n  ) {}\n}\n\nexport type DestroyableBounds = Bounds;\n\nexport class ConcreteBounds implements Bounds {\n  constructor(\n    public parentNode: SimpleElement,\n    private first: SimpleNode,\n    private last: SimpleNode\n  ) {}\n\n  parentElement(): SimpleElement {\n    return this.parentNode;\n  }\n\n  firstNode(): SimpleNode {\n    return this.first;\n  }\n\n  lastNode(): SimpleNode {\n    return this.last;\n  }\n}\n\nexport function move(bounds: Bounds, reference: Nullable<SimpleNode>): Nullable<SimpleNode> {\n  let parent = bounds.parentElement();\n  let first = bounds.firstNode();\n  let last = bounds.lastNode();\n\n  let current: SimpleNode = first;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let next = current.nextSibling;\n\n    parent.insertBefore(current, reference);\n\n    if (current === last) {\n      return next;\n    }\n\n    current = expect(next, 'invalid bounds');\n  }\n}\n\nexport function clear(bounds: Bounds): Nullable<SimpleNode> {\n  let parent = bounds.parentElement();\n  let first = bounds.firstNode();\n  let last = bounds.lastNode();\n\n  let current: SimpleNode = first;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let next = current.nextSibling;\n\n    parent.removeChild(current);\n\n    if (current === last) {\n      return next;\n    }\n\n    current = expect(next, 'invalid bounds');\n  }\n}\n","import type { Dict, SimpleDocumentFragment, SimpleNode } from '@glimmer/interfaces';\n\nexport interface SafeString {\n  toHTML(): string;\n}\n\nexport type Insertion = CautiousInsertion | TrustingInsertion;\nexport type CautiousInsertion = string | SafeString | SimpleNode;\nexport type TrustingInsertion = string | SimpleNode;\n\nexport function normalizeStringValue(value: unknown): string {\n  if (isEmpty(value)) {\n    return '';\n  }\n  return String(value);\n}\n\nexport function normalizeTrustedValue(value: unknown): TrustingInsertion {\n  if (isEmpty(value)) {\n    return '';\n  }\n  if (isString(value)) {\n    return value;\n  }\n  if (isSafeString(value)) {\n    return value.toHTML();\n  }\n  if (isNode(value)) {\n    return value;\n  }\n  return String(value);\n}\n\nexport function shouldCoerce(\n  value: unknown\n): value is string | number | boolean | null | undefined {\n  return (\n    isString(value) || isEmpty(value) || typeof value === 'boolean' || typeof value === 'number'\n  );\n}\n\nexport function isEmpty(value: unknown): boolean {\n  return value === null || value === undefined || typeof (value as Dict).toString !== 'function';\n}\n\nexport function isSafeString(value: unknown): value is SafeString {\n  return typeof value === 'object' && value !== null && typeof (value as any).toHTML === 'function';\n}\n\nexport function isNode(value: unknown): value is SimpleNode {\n  return typeof value === 'object' && value !== null && typeof (value as any).nodeType === 'number';\n}\n\nexport function isFragment(value: unknown): value is SimpleDocumentFragment {\n  return isNode(value) && value.nodeType === 11;\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n","import type { Dict, SimpleElement } from '@glimmer/interfaces';\n\n/*\n * @method normalizeProperty\n * @param element {HTMLElement}\n * @param slotName {String}\n * @returns {Object} { name, type }\n */\nexport function normalizeProperty(element: SimpleElement, slotName: string) {\n  let type, normalized;\n\n  if (slotName in element) {\n    normalized = slotName;\n    type = 'prop';\n  } else {\n    let lower = slotName.toLowerCase();\n    if (lower in element) {\n      type = 'prop';\n      normalized = lower;\n    } else {\n      type = 'attr';\n      normalized = slotName;\n    }\n  }\n\n  if (\n    type === 'prop' &&\n    (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))\n  ) {\n    type = 'attr';\n  }\n\n  return { normalized, type };\n}\n\nexport function normalizePropertyValue(value: unknown): unknown {\n  if (value === '') {\n    return true;\n  }\n\n  return value;\n}\n\n// properties that MUST be set as attributes, due to:\n// * browser bug\n// * strange spec outlier\nconst ATTR_OVERRIDES: Dict<Dict> = {\n  INPUT: {\n    form: true,\n    // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false\n    // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false\n    // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true\n    autocorrect: true,\n    // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true\n    // Safari 9.1.3: 'list' in document.createElement('input') === false\n    list: true,\n  },\n\n  // element.form is actually a legitimate readOnly property, that is to be\n  // mutated, but must be mutated by setAttribute...\n  SELECT: { form: true },\n  OPTION: { form: true },\n  TEXTAREA: { form: true },\n  LABEL: { form: true },\n  FIELDSET: { form: true },\n  LEGEND: { form: true },\n  OBJECT: { form: true },\n  OUTPUT: { form: true },\n  BUTTON: { form: true },\n};\n\nfunction preferAttr(tagName: string, propName: string) {\n  let tag = ATTR_OVERRIDES[tagName.toUpperCase()];\n  return (tag && tag[propName.toLowerCase()]) || false;\n}\n","import type { Nullable, SimpleElement } from '@glimmer/interfaces';\n\nimport { isSafeString, normalizeStringValue } from '../dom/normalize';\n\nconst badProtocols = ['javascript:', 'vbscript:'];\n\nconst badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];\n\nconst badTagsForDataURI = ['EMBED'];\n\nconst badAttributes = ['href', 'src', 'background', 'action'];\n\nconst badAttributesForDataURI = ['src'];\n\nfunction has(array: Array<string>, item: string): boolean {\n  return array.indexOf(item) !== -1;\n}\n\nfunction checkURI(tagName: Nullable<string>, attribute: string): boolean {\n  return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);\n}\n\nfunction checkDataURI(tagName: Nullable<string>, attribute: string): boolean {\n  if (tagName === null) return false;\n  return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);\n}\n\nexport function requiresSanitization(tagName: string, attribute: string): boolean {\n  return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);\n}\n\ninterface NodeUrlParseResult {\n  protocol: string | null;\n}\n\ninterface NodeUrlModule {\n  parse(url: string): NodeUrlParseResult;\n}\n\nfunction findProtocolForURL() {\n  if (\n    typeof URL === 'object' &&\n    URL !== null &&\n    // this is super annoying, TS thinks that URL **must** be a function so `URL.parse` check\n    // thinks it is `never` without this `as unknown as any`\n    typeof (URL as unknown as any).parse === 'function'\n  ) {\n    // In Ember-land the `fastboot` package sets the `URL` global to `require('url')`\n    // ultimately, this should be changed (so that we can either rely on the natural `URL` global\n    // that exists) but for now we have to detect the specific `FastBoot` case first\n    //\n    // a future version of `fastboot` will detect if this legacy URL setup is required (by\n    // inspecting Ember version) and if new enough, it will avoid shadowing the `URL` global\n    // constructor with `require('url')`.\n    let nodeURL = URL as NodeUrlModule;\n\n    return (url: string) => {\n      let protocol = null;\n\n      if (typeof url === 'string') {\n        protocol = nodeURL.parse(url).protocol;\n      }\n\n      return protocol === null ? ':' : protocol;\n    };\n  } else if (typeof URL === 'function') {\n    return (_url: string) => {\n      try {\n        let url = new URL(_url);\n\n        return url.protocol;\n      } catch (error) {\n        // any non-fully qualified url string will trigger an error (because there is no\n        // baseURI that we can provide; in that case we **know** that the protocol is\n        // \"safe\" because it isn't specifically one of the `badProtocols` listed above\n        // (and those protocols can never be the default baseURI)\n        return ':';\n      }\n    };\n  } else {\n    throw new Error(`@glimmer/runtime needs a valid \"globalThis.URL\"`);\n  }\n}\n\nlet _protocolForUrlImplementation: typeof protocolForUrl | undefined;\nfunction protocolForUrl(url: string): string {\n  if (!_protocolForUrlImplementation) {\n    _protocolForUrlImplementation = findProtocolForURL();\n  }\n  return _protocolForUrlImplementation(url);\n}\n\nexport function sanitizeAttributeValue(\n  element: SimpleElement,\n  attribute: string,\n  value: unknown\n): unknown {\n  let tagName: Nullable<string> = null;\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (isSafeString(value)) {\n    return value.toHTML();\n  }\n\n  if (!element) {\n    tagName = null;\n  } else {\n    tagName = element.tagName.toUpperCase();\n  }\n\n  let str = normalizeStringValue(value);\n\n  if (checkURI(tagName, attribute)) {\n    let protocol = protocolForUrl(str);\n    if (has(badProtocols, protocol)) {\n      return `unsafe:${str}`;\n    }\n  }\n\n  if (checkDataURI(tagName, attribute)) {\n    return `unsafe:${str}`;\n  }\n\n  return str;\n}\n","import type {\n  AttributeCursor,\n  AttributeOperation,\n  AttrNamespace,\n  Dict,\n  ElementBuilder,\n  Environment,\n  Nullable,\n  SimpleElement,\n} from '@glimmer/interfaces';\nimport { warnIfStyleNotTrusted } from '@glimmer/global-context';\nimport { castToBrowser, NS_SVG } from '@glimmer/util';\n\nimport { normalizeStringValue } from '../../dom/normalize';\nimport { normalizeProperty } from '../../dom/props';\nimport { requiresSanitization, sanitizeAttributeValue } from '../../dom/sanitized-values';\n\nexport function dynamicAttribute(\n  element: SimpleElement,\n  attr: string,\n  namespace: Nullable<AttrNamespace>,\n  isTrusting = false\n): DynamicAttribute {\n  const { tagName, namespaceURI } = element;\n  const attribute = { element, name: attr, namespace };\n\n  if (import.meta.env.DEV && attr === 'style' && !isTrusting) {\n    return new DebugStyleAttributeManager(attribute);\n  }\n\n  if (namespaceURI === NS_SVG) {\n    return buildDynamicAttribute(tagName, attr, attribute);\n  }\n\n  const { type, normalized } = normalizeProperty(element, attr);\n\n  if (type === 'attr') {\n    return buildDynamicAttribute(tagName, normalized, attribute);\n  } else {\n    return buildDynamicProperty(tagName, normalized, attribute);\n  }\n}\n\nfunction buildDynamicAttribute(\n  tagName: string,\n  name: string,\n  attribute: AttributeCursor\n): DynamicAttribute {\n  if (requiresSanitization(tagName, name)) {\n    return new SafeDynamicAttribute(attribute);\n  } else {\n    return new SimpleDynamicAttribute(attribute);\n  }\n}\n\nfunction buildDynamicProperty(\n  tagName: string,\n  name: string,\n  attribute: AttributeCursor\n): DynamicAttribute {\n  if (requiresSanitization(tagName, name)) {\n    return new SafeDynamicProperty(name, attribute);\n  }\n\n  if (isUserInputValue(tagName, name)) {\n    return new InputValueDynamicAttribute(name, attribute);\n  }\n\n  if (isOptionSelected(tagName, name)) {\n    return new OptionSelectedDynamicAttribute(name, attribute);\n  }\n\n  return new DefaultDynamicProperty(name, attribute);\n}\n\nexport abstract class DynamicAttribute implements AttributeOperation {\n  constructor(public attribute: AttributeCursor) {}\n\n  abstract set(dom: ElementBuilder, value: unknown, env: Environment): void;\n  abstract update(value: unknown, env: Environment): void;\n}\n\nexport class SimpleDynamicAttribute extends DynamicAttribute {\n  set(dom: ElementBuilder, value: unknown, _env: Environment): void {\n    const normalizedValue = normalizeValue(value);\n\n    if (normalizedValue !== null) {\n      const { name, namespace } = this.attribute;\n      dom.__setAttribute(name, normalizedValue, namespace);\n    }\n  }\n\n  update(value: unknown, _env: Environment): void {\n    const normalizedValue = normalizeValue(value);\n    const { element, name } = this.attribute;\n\n    if (normalizedValue === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, normalizedValue);\n    }\n  }\n}\n\nexport class DefaultDynamicProperty extends DynamicAttribute {\n  constructor(\n    private normalizedName: string,\n    attribute: AttributeCursor\n  ) {\n    super(attribute);\n  }\n\n  value: unknown;\n  set(dom: ElementBuilder, value: unknown, _env: Environment): void {\n    if (value !== null && value !== undefined) {\n      this.value = value;\n      dom.__setProperty(this.normalizedName, value);\n    }\n  }\n\n  update(value: unknown, _env: Environment): void {\n    const { element } = this.attribute;\n\n    if (this.value !== value) {\n      (element as any)[this.normalizedName] = this.value = value;\n\n      if (value === null || value === undefined) {\n        this.removeAttribute();\n      }\n    }\n  }\n\n  protected removeAttribute() {\n    // TODO this sucks but to preserve properties first and to meet current\n    // semantics we must do this.\n    const { element, namespace } = this.attribute;\n\n    if (namespace) {\n      element.removeAttributeNS(namespace, this.normalizedName);\n    } else {\n      element.removeAttribute(this.normalizedName);\n    }\n  }\n}\n\nexport class SafeDynamicProperty extends DefaultDynamicProperty {\n  override set(dom: ElementBuilder, value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.set(dom, sanitized, env);\n  }\n\n  override update(value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.update(sanitized, env);\n  }\n}\n\nexport class SafeDynamicAttribute extends SimpleDynamicAttribute {\n  override set(dom: ElementBuilder, value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.set(dom, sanitized, env);\n  }\n\n  override update(value: unknown, env: Environment): void {\n    const { element, name } = this.attribute;\n    const sanitized = sanitizeAttributeValue(element, name, value);\n    super.update(sanitized, env);\n  }\n}\n\nexport class InputValueDynamicAttribute extends DefaultDynamicProperty {\n  override set(dom: ElementBuilder, value: unknown) {\n    dom.__setProperty('value', normalizeStringValue(value));\n  }\n\n  override update(value: unknown) {\n    const input = castToBrowser(this.attribute.element, ['input', 'textarea']);\n    const currentValue = input.value;\n    const normalizedValue = normalizeStringValue(value);\n    if (currentValue !== normalizedValue) {\n      input.value = normalizedValue;\n    }\n  }\n}\n\nexport class OptionSelectedDynamicAttribute extends DefaultDynamicProperty {\n  override set(dom: ElementBuilder, value: unknown): void {\n    if (value !== null && value !== undefined && value !== false) {\n      dom.__setProperty('selected', true);\n    }\n  }\n\n  override update(value: unknown): void {\n    const option = castToBrowser(this.attribute.element, 'option');\n\n    if (value) {\n      option.selected = true;\n    } else {\n      option.selected = false;\n    }\n  }\n}\n\nfunction isOptionSelected(tagName: string, attribute: string) {\n  return tagName === 'OPTION' && attribute === 'selected';\n}\n\nfunction isUserInputValue(tagName: string, attribute: string) {\n  return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';\n}\n\nfunction normalizeValue(value: unknown): Nullable<string> {\n  if (\n    value === false ||\n    value === undefined ||\n    value === null ||\n    typeof (value as Dict).toString === 'undefined'\n  ) {\n    return null;\n  }\n  if (value === true) {\n    return '';\n  }\n  // onclick function etc in SSR\n  if (typeof value === 'function') {\n    return null;\n  }\n\n  return String(value);\n}\n\nlet DebugStyleAttributeManager: {\n  new (attribute: AttributeCursor): AttributeOperation;\n};\n\nif (import.meta.env.DEV) {\n  DebugStyleAttributeManager = class extends SimpleDynamicAttribute {\n    override set(dom: ElementBuilder, value: unknown, env: Environment): void {\n      warnIfStyleNotTrusted(value);\n\n      super.set(dom, value, env);\n    }\n    override update(value: unknown, env: Environment): void {\n      warnIfStyleNotTrusted(value);\n\n      super.update(value, env);\n    }\n  };\n}\n","import type {\n  AttrNamespace,\n  Bounds,\n  Cursor,\n  CursorStackSymbol,\n  ElementBuilder,\n  ElementOperations,\n  Environment,\n  GlimmerTreeChanges,\n  GlimmerTreeConstruction,\n  LiveBlock,\n  Maybe,\n  ModifierInstance,\n  Nullable,\n  SimpleComment,\n  SimpleDocumentFragment,\n  SimpleElement,\n  SimpleNode,\n  SimpleText,\n  UpdatableBlock,\n} from '@glimmer/interfaces';\nimport { destroy, registerDestructor } from '@glimmer/destroyable';\nimport { assert, expect, Stack } from '@glimmer/util';\n\nimport type { DynamicAttribute } from './attributes/dynamic';\n\nimport { clear, ConcreteBounds, CursorImpl } from '../bounds';\nimport { dynamicAttribute } from './attributes/dynamic';\n\nexport interface FirstNode {\n  firstNode(): SimpleNode;\n}\n\nexport interface LastNode {\n  lastNode(): SimpleNode;\n}\n\nclass First {\n  constructor(private node: SimpleNode) {}\n\n  firstNode(): SimpleNode {\n    return this.node;\n  }\n}\n\nclass Last {\n  constructor(private node: SimpleNode) {}\n\n  lastNode(): SimpleNode {\n    return this.node;\n  }\n}\n\nexport class Fragment implements Bounds {\n  private bounds: Bounds;\n\n  constructor(bounds: Bounds) {\n    this.bounds = bounds;\n  }\n\n  parentElement(): SimpleElement {\n    return this.bounds.parentElement();\n  }\n\n  firstNode(): SimpleNode {\n    return this.bounds.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    return this.bounds.lastNode();\n  }\n}\n\nexport const CURSOR_STACK: CursorStackSymbol = Symbol('CURSOR_STACK') as CursorStackSymbol;\n\nexport class NewElementBuilder implements ElementBuilder {\n  public dom: GlimmerTreeConstruction;\n  public updateOperations: GlimmerTreeChanges;\n  public constructing: Nullable<SimpleElement> = null;\n  public operations: Nullable<ElementOperations> = null;\n  private env: Environment;\n\n  [CURSOR_STACK] = new Stack<Cursor>();\n  private modifierStack = new Stack<Nullable<ModifierInstance[]>>();\n  private blockStack = new Stack<LiveBlock>();\n\n  static forInitialRender(env: Environment, cursor: CursorImpl) {\n    return new this(env, cursor.element, cursor.nextSibling).initialize();\n  }\n\n  static resume(env: Environment, block: UpdatableBlock): NewElementBuilder {\n    let parentNode = block.parentElement();\n    let nextSibling = block.reset(env);\n\n    let stack = new this(env, parentNode, nextSibling).initialize();\n    stack.pushLiveBlock(block);\n\n    return stack;\n  }\n\n  constructor(env: Environment, parentNode: SimpleElement, nextSibling: Nullable<SimpleNode>) {\n    this.pushElement(parentNode, nextSibling);\n    this.env = env;\n    this.dom = env.getAppendOperations();\n    this.updateOperations = env.getDOM();\n  }\n\n  protected initialize(): this {\n    this.pushSimpleBlock();\n    return this;\n  }\n\n  debugBlocks(): LiveBlock[] {\n    return this.blockStack.toArray();\n  }\n\n  get element(): SimpleElement {\n    return this[CURSOR_STACK].current!.element;\n  }\n\n  get nextSibling(): Nullable<SimpleNode> {\n    return this[CURSOR_STACK].current!.nextSibling;\n  }\n\n  get hasBlocks() {\n    return this.blockStack.size > 0;\n  }\n\n  protected block(): LiveBlock {\n    return expect(this.blockStack.current, 'Expected a current live block');\n  }\n\n  popElement() {\n    this[CURSOR_STACK].pop();\n    expect(this[CURSOR_STACK].current, \"can't pop past the last element\");\n  }\n\n  pushSimpleBlock(): LiveBlock {\n    return this.pushLiveBlock(new SimpleLiveBlock(this.element));\n  }\n\n  pushUpdatableBlock(): UpdatableBlockImpl {\n    return this.pushLiveBlock(new UpdatableBlockImpl(this.element));\n  }\n\n  pushBlockList(list: LiveBlock[]): LiveBlockList {\n    return this.pushLiveBlock(new LiveBlockList(this.element, list));\n  }\n\n  protected pushLiveBlock<T extends LiveBlock>(block: T, isRemote = false): T {\n    let current = this.blockStack.current;\n\n    if (current !== null) {\n      if (!isRemote) {\n        current.didAppendBounds(block);\n      }\n    }\n\n    this.__openBlock();\n    this.blockStack.push(block);\n    return block;\n  }\n\n  popBlock(): LiveBlock {\n    this.block().finalize(this);\n    this.__closeBlock();\n    return expect(this.blockStack.pop(), 'Expected popBlock to return a block');\n  }\n\n  __openBlock(): void {}\n  __closeBlock(): void {}\n\n  // todo return seems unused\n  openElement(tag: string): SimpleElement {\n    let element = this.__openElement(tag);\n    this.constructing = element;\n\n    return element;\n  }\n\n  __openElement(tag: string): SimpleElement {\n    return this.dom.createElement(tag, this.element);\n  }\n\n  flushElement(modifiers: Nullable<ModifierInstance[]>) {\n    let parent = this.element;\n    let element = expect(\n      this.constructing,\n      `flushElement should only be called when constructing an element`\n    );\n\n    this.__flushElement(parent, element);\n\n    this.constructing = null;\n    this.operations = null;\n\n    this.pushModifiers(modifiers);\n    this.pushElement(element, null);\n    this.didOpenElement(element);\n  }\n\n  __flushElement(parent: SimpleElement, constructing: SimpleElement) {\n    this.dom.insertBefore(parent, constructing, this.nextSibling);\n  }\n\n  closeElement(): Nullable<ModifierInstance[]> {\n    this.willCloseElement();\n    this.popElement();\n    return this.popModifiers();\n  }\n\n  pushRemoteElement(\n    element: SimpleElement,\n    guid: string,\n    insertBefore: Maybe<SimpleNode>\n  ): RemoteLiveBlock {\n    return this.__pushRemoteElement(element, guid, insertBefore);\n  }\n\n  __pushRemoteElement(\n    element: SimpleElement,\n    _guid: string,\n    insertBefore: Maybe<SimpleNode>\n  ): RemoteLiveBlock {\n    this.pushElement(element, insertBefore);\n\n    if (insertBefore === undefined) {\n      while (element.lastChild) {\n        element.removeChild(element.lastChild);\n      }\n    }\n\n    let block = new RemoteLiveBlock(element);\n\n    return this.pushLiveBlock(block, true);\n  }\n\n  popRemoteElement(): RemoteLiveBlock {\n    const block = this.popBlock();\n    assert(block instanceof RemoteLiveBlock, '[BUG] expecting a RemoteLiveBlock');\n    this.popElement();\n    return block;\n  }\n\n  protected pushElement(element: SimpleElement, nextSibling: Maybe<SimpleNode> = null): void {\n    this[CURSOR_STACK].push(new CursorImpl(element, nextSibling));\n  }\n\n  private pushModifiers(modifiers: Nullable<ModifierInstance[]>): void {\n    this.modifierStack.push(modifiers);\n  }\n\n  private popModifiers(): Nullable<ModifierInstance[]> {\n    return this.modifierStack.pop();\n  }\n\n  didAppendBounds(bounds: Bounds): Bounds {\n    this.block().didAppendBounds(bounds);\n    return bounds;\n  }\n\n  didAppendNode<T extends SimpleNode>(node: T): T {\n    this.block().didAppendNode(node);\n    return node;\n  }\n\n  didOpenElement(element: SimpleElement): SimpleElement {\n    this.block().openElement(element);\n    return element;\n  }\n\n  willCloseElement(): void {\n    this.block().closeElement();\n  }\n\n  appendText(string: string): SimpleText {\n    return this.didAppendNode(this.__appendText(string));\n  }\n\n  __appendText(text: string): SimpleText {\n    let { dom, element, nextSibling } = this;\n    let node = dom.createTextNode(text);\n    dom.insertBefore(element, node, nextSibling);\n    return node;\n  }\n\n  __appendNode(node: SimpleNode): SimpleNode {\n    this.dom.insertBefore(this.element, node, this.nextSibling);\n    return node;\n  }\n\n  __appendFragment(fragment: SimpleDocumentFragment): Bounds {\n    let first = fragment.firstChild;\n\n    if (first) {\n      let ret = new ConcreteBounds(this.element, first, fragment.lastChild!);\n      this.dom.insertBefore(this.element, fragment, this.nextSibling);\n      return ret;\n    } else {\n      const comment = this.__appendComment('');\n      return new ConcreteBounds(this.element, comment, comment);\n    }\n  }\n\n  __appendHTML(html: string): Bounds {\n    return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);\n  }\n\n  appendDynamicHTML(value: string): void {\n    let bounds = this.trustedContent(value);\n    this.didAppendBounds(bounds);\n  }\n\n  appendDynamicText(value: string): SimpleText {\n    let node = this.untrustedContent(value);\n    this.didAppendNode(node);\n    return node;\n  }\n\n  appendDynamicFragment(value: SimpleDocumentFragment): void {\n    let bounds = this.__appendFragment(value);\n    this.didAppendBounds(bounds);\n  }\n\n  appendDynamicNode(value: SimpleNode): void {\n    let node = this.__appendNode(value);\n    let bounds = new ConcreteBounds(this.element, node, node);\n    this.didAppendBounds(bounds);\n  }\n\n  private trustedContent(value: string): Bounds {\n    return this.__appendHTML(value);\n  }\n\n  private untrustedContent(value: string): SimpleText {\n    return this.__appendText(value);\n  }\n\n  appendComment(string: string): SimpleComment {\n    return this.didAppendNode(this.__appendComment(string));\n  }\n\n  __appendComment(string: string): SimpleComment {\n    let { dom, element, nextSibling } = this;\n    let node = dom.createComment(string);\n    dom.insertBefore(element, node, nextSibling);\n    return node;\n  }\n\n  __setAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void {\n    this.dom.setAttribute(this.constructing!, name, value, namespace);\n  }\n\n  __setProperty(name: string, value: unknown): void {\n    (this.constructing! as any)[name] = value;\n  }\n\n  setStaticAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void {\n    this.__setAttribute(name, value, namespace);\n  }\n\n  setDynamicAttribute(\n    name: string,\n    value: unknown,\n    trusting: boolean,\n    namespace: Nullable<AttrNamespace>\n  ): DynamicAttribute {\n    let element = this.constructing!;\n    let attribute = dynamicAttribute(element, name, namespace, trusting);\n    attribute.set(this, value, this.env);\n    return attribute;\n  }\n}\n\nexport class SimpleLiveBlock implements LiveBlock {\n  protected first: Nullable<FirstNode> = null;\n  protected last: Nullable<LastNode> = null;\n  protected nesting = 0;\n\n  constructor(private parent: SimpleElement) {}\n\n  parentElement() {\n    return this.parent;\n  }\n\n  firstNode(): SimpleNode {\n    let first = expect(\n      this.first,\n      'cannot call `firstNode()` while `SimpleLiveBlock` is still initializing'\n    );\n\n    return first.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    let last = expect(\n      this.last,\n      'cannot call `lastNode()` while `SimpleLiveBlock` is still initializing'\n    );\n\n    return last.lastNode();\n  }\n\n  openElement(element: SimpleElement) {\n    this.didAppendNode(element);\n    this.nesting++;\n  }\n\n  closeElement() {\n    this.nesting--;\n  }\n\n  didAppendNode(node: SimpleNode) {\n    if (this.nesting !== 0) return;\n\n    if (!this.first) {\n      this.first = new First(node);\n    }\n\n    this.last = new Last(node);\n  }\n\n  didAppendBounds(bounds: Bounds) {\n    if (this.nesting !== 0) return;\n\n    if (!this.first) {\n      this.first = bounds;\n    }\n\n    this.last = bounds;\n  }\n\n  finalize(stack: ElementBuilder) {\n    if (this.first === null) {\n      stack.appendComment('');\n    }\n  }\n}\n\nexport class RemoteLiveBlock extends SimpleLiveBlock {\n  constructor(parent: SimpleElement) {\n    super(parent);\n\n    registerDestructor(this, () => {\n      // In general, you only need to clear the root of a hierarchy, and should never\n      // need to clear any child nodes. This is an important constraint that gives us\n      // a strong guarantee that clearing a subtree is a single DOM operation.\n      //\n      // Because remote blocks are not normally physically nested inside of the tree\n      // that they are logically nested inside, we manually clear remote blocks when\n      // a logical parent is cleared.\n      //\n      // HOWEVER, it is currently possible for a remote block to be physically nested\n      // inside of the block it is logically contained inside of. This happens when\n      // the remote block is appended to the end of the application's entire element.\n      //\n      // The problem with that scenario is that Glimmer believes that it owns more of\n      // the DOM than it actually does. The code is attempting to write past the end\n      // of the Glimmer-managed root, but Glimmer isn't aware of that.\n      //\n      // The correct solution to that problem is for Glimmer to be aware of the end\n      // of the bounds that it owns, and once we make that change, this check could\n      // be removed.\n      //\n      // For now, a more targeted fix is to check whether the node was already removed\n      // and avoid clearing the node if it was. In most cases this shouldn't happen,\n      // so this might hide bugs where the code clears nested nodes unnecessarily,\n      // so we should eventually try to do the correct fix.\n      if (this.parentElement() === this.firstNode().parentNode) {\n        clear(this);\n      }\n    });\n  }\n}\n\nexport class UpdatableBlockImpl extends SimpleLiveBlock implements UpdatableBlock {\n  reset(): Nullable<SimpleNode> {\n    destroy(this);\n    let nextSibling = clear(this);\n\n    this.first = null;\n    this.last = null;\n    this.nesting = 0;\n\n    return nextSibling;\n  }\n}\n\n// FIXME: All the noops in here indicate a modelling problem\nexport class LiveBlockList implements LiveBlock {\n  constructor(\n    private readonly parent: SimpleElement,\n    public boundList: LiveBlock[]\n  ) {\n    this.parent = parent;\n    this.boundList = boundList;\n  }\n\n  parentElement() {\n    return this.parent;\n  }\n\n  firstNode(): SimpleNode {\n    let head = expect(\n      this.boundList[0],\n      'cannot call `firstNode()` while `LiveBlockList` is still initializing'\n    );\n\n    return head.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    let boundList = this.boundList;\n\n    let tail = expect(\n      boundList[boundList.length - 1],\n      'cannot call `lastNode()` while `LiveBlockList` is still initializing'\n    );\n\n    return tail.lastNode();\n  }\n\n  openElement(_element: SimpleElement) {\n    assert(false, 'Cannot openElement directly inside a block list');\n  }\n\n  closeElement() {\n    assert(false, 'Cannot closeElement directly inside a block list');\n  }\n\n  didAppendNode(_node: SimpleNode) {\n    assert(false, 'Cannot create a new node directly inside a block list');\n  }\n\n  didAppendBounds(_bounds: Bounds) {}\n\n  finalize(_stack: ElementBuilder) {\n    assert(this.boundList.length > 0, 'boundsList cannot be empty');\n  }\n}\n\nexport function clientBuilder(env: Environment, cursor: CursorImpl): ElementBuilder {\n  return NewElementBuilder.forInitialRender(env, cursor);\n}\n","import type {\n  Dict,\n  Maybe,\n  Nullable,\n  RuntimeOp,\n  SomeVmOp,\n  VmMachineOp,\n  VmOp,\n} from '@glimmer/interfaces';\nimport { debug, logOpcode, opcodeMetadata, recordStackSize } from '@glimmer/debug';\nimport { LOCAL_DEBUG, LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { valueForRef } from '@glimmer/reference';\nimport { assert, LOCAL_LOGGER, unwrap } from '@glimmer/util';\nimport { $fp, $pc, $ra, $sp, Op } from '@glimmer/vm';\n\nimport type { LowLevelVM, VM } from './vm';\nimport type { InternalVM } from './vm/append';\n\nimport { isScopeReference } from './scope';\nimport { CONSTANTS, DESTROYABLE_STACK, INNER_VM, STACKS } from './symbols';\nimport { CURSOR_STACK } from './vm/element-builder';\n\nexport interface OpcodeJSON {\n  type: number | string;\n  guid?: Nullable<number>;\n  deopted?: boolean;\n  args?: string[];\n  details?: Dict<Nullable<string>>;\n  children?: OpcodeJSON[];\n}\n\nexport type Operand1 = number;\nexport type Operand2 = number;\nexport type Operand3 = number;\n\nexport type Syscall = (vm: InternalVM, opcode: RuntimeOp) => void;\nexport type MachineOpcode = (vm: LowLevelVM, opcode: RuntimeOp) => void;\n\nexport type Evaluate =\n  | { syscall: true; evaluate: Syscall }\n  | { syscall: false; evaluate: MachineOpcode };\n\nexport type DebugState = {\n  pc: number;\n  sp: number;\n  type: VmMachineOp | VmOp;\n  isMachine: 0 | 1;\n  size: number;\n  params?: Maybe<Dict> | undefined;\n  name?: string | undefined;\n  state: unknown;\n};\n\nexport class AppendOpcodes {\n  private evaluateOpcode: Evaluate[] = new Array(Op.Size).fill(null);\n\n  add<Name extends VmOp>(name: Name, evaluate: Syscall): void;\n  add<Name extends VmMachineOp>(name: Name, evaluate: MachineOpcode, kind: 'machine'): void;\n  add<Name extends SomeVmOp>(\n    name: Name,\n    evaluate: Syscall | MachineOpcode,\n    kind = 'syscall'\n  ): void {\n    this.evaluateOpcode[name as number] = {\n      syscall: kind !== 'machine',\n      evaluate,\n    } as Evaluate;\n  }\n\n  debugBefore(vm: VM, opcode: RuntimeOp): DebugState {\n    let params: Maybe<Dict> = undefined;\n    let opName: string | undefined = undefined;\n\n    if (LOCAL_SHOULD_LOG) {\n      let pos = vm[INNER_VM].fetchRegister($pc) - opcode.size;\n\n      [opName, params] = debug(vm[CONSTANTS], opcode, opcode.isMachine)!;\n\n      // console.log(`${typePos(vm['pc'])}.`);\n      LOCAL_LOGGER.log(`${pos}. ${logOpcode(opName, params)}`);\n\n      let debugParams = [];\n      for (let prop in params) {\n        debugParams.push(prop, '=', params[prop]);\n      }\n\n      LOCAL_LOGGER.log(...debugParams);\n    }\n\n    let sp: number;\n\n    if (LOCAL_DEBUG) {\n      sp = vm.fetchValue($sp);\n    }\n\n    recordStackSize(vm.fetchValue($sp));\n    return {\n      sp: sp!,\n      pc: vm.fetchValue($pc),\n      name: opName,\n      params,\n      type: opcode.type,\n      isMachine: opcode.isMachine,\n      size: opcode.size,\n      state: undefined,\n    };\n  }\n\n  debugAfter(vm: VM, pre: DebugState) {\n    let { sp, type, isMachine, pc } = pre;\n\n    if (LOCAL_DEBUG) {\n      let meta = opcodeMetadata(type, isMachine);\n      let actualChange = vm.fetchValue($sp) - sp;\n      if (\n        meta &&\n        meta.check &&\n        typeof meta.stackChange! === 'number' &&\n        meta.stackChange !== actualChange\n      ) {\n        throw new Error(\n          `Error in ${pre.name}:\\n\\n${pc}. ${logOpcode(\n            pre.name!,\n            pre.params\n          )}\\n\\nStack changed by ${actualChange}, expected ${meta.stackChange}`\n        );\n      }\n\n      if (LOCAL_SHOULD_LOG) {\n        LOCAL_LOGGER.log(\n          '%c -> pc: %d, ra: %d, fp: %d, sp: %d, s0: %O, s1: %O, t0: %O, t1: %O, v0: %O',\n          'color: orange',\n          vm[INNER_VM].registers[$pc],\n          vm[INNER_VM].registers[$ra],\n          vm[INNER_VM].registers[$fp],\n          vm[INNER_VM].registers[$sp],\n          vm['s0'],\n          vm['s1'],\n          vm['t0'],\n          vm['t1'],\n          vm['v0']\n        );\n        LOCAL_LOGGER.log('%c -> eval stack', 'color: red', vm.stack.toArray());\n        LOCAL_LOGGER.log('%c -> block stack', 'color: magenta', vm.elements().debugBlocks());\n        LOCAL_LOGGER.log(\n          '%c -> destructor stack',\n          'color: violet',\n          vm[DESTROYABLE_STACK].toArray()\n        );\n        if (vm[STACKS].scope.current === null) {\n          LOCAL_LOGGER.log('%c -> scope', 'color: green', 'null');\n        } else {\n          LOCAL_LOGGER.log(\n            '%c -> scope',\n            'color: green',\n            vm.scope().slots.map((s) => (isScopeReference(s) ? valueForRef(s) : s))\n          );\n        }\n\n        LOCAL_LOGGER.log(\n          '%c -> elements',\n          'color: blue',\n          vm.elements()[CURSOR_STACK].current!.element\n        );\n\n        LOCAL_LOGGER.log('%c -> constructing', 'color: aqua', vm.elements()['constructing']);\n      }\n    }\n  }\n\n  evaluate(vm: VM, opcode: RuntimeOp, type: number) {\n    let operation = unwrap(this.evaluateOpcode[type]);\n\n    if (operation.syscall) {\n      assert(\n        !opcode.isMachine,\n        `BUG: Mismatch between operation.syscall (${operation.syscall}) and opcode.isMachine (${opcode.isMachine}) for ${opcode.type}`\n      );\n      operation.evaluate(vm, opcode);\n    } else {\n      assert(\n        opcode.isMachine,\n        `BUG: Mismatch between operation.syscall (${operation.syscall}) and opcode.isMachine (${opcode.isMachine}) for ${opcode.type}`\n      );\n      operation.evaluate(vm[INNER_VM], opcode);\n    }\n  }\n}\n\nexport const APPEND_OPCODES = new AppendOpcodes();\n","import type {\n  CapturedArguments,\n  CurriedComponent,\n  CurriedHelper,\n  CurriedModifier,\n  CurriedType,\n  Owner,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\n\nconst TYPE: unique symbol = Symbol('TYPE');\nconst INNER: unique symbol = Symbol('INNER');\nconst OWNER: unique symbol = Symbol('OWNER');\nconst ARGS: unique symbol = Symbol('ARGS');\nconst RESOLVED: unique symbol = Symbol('RESOLVED');\n\nconst CURRIED_VALUES = new WeakSet();\n\nexport function isCurriedValue(value: unknown): value is CurriedValue<CurriedType> {\n  return CURRIED_VALUES.has(value as object);\n}\n\nexport function isCurriedType<T extends CurriedType>(\n  value: unknown,\n  type: T\n): value is CurriedValue<T> {\n  return isCurriedValue(value) && value[TYPE] === type;\n}\n\nexport class CurriedValue<T extends CurriedType = CurriedType> {\n  [TYPE]: T;\n  [INNER]: object | string | CurriedValue<T>;\n  [OWNER]: Owner;\n  [ARGS]: CapturedArguments | null;\n  [RESOLVED]: boolean;\n\n  /** @internal */\n  constructor(\n    type: T,\n    inner: object | string | CurriedValue<T>,\n    owner: Owner,\n    args: CapturedArguments | null,\n    resolved = false\n  ) {\n    CURRIED_VALUES.add(this);\n    this[TYPE] = type;\n    this[INNER] = inner;\n    this[OWNER] = owner;\n    this[ARGS] = args;\n    this[RESOLVED] = resolved;\n  }\n}\n\ninterface ResolvedCurriedValue<T> {\n  definition: T;\n  owner: Owner;\n  resolved: boolean;\n  positional: Reference[] | undefined;\n  named: Record<string, Reference>[] | undefined;\n}\n\nexport function resolveCurriedValue(\n  curriedValue: CurriedValue<CurriedComponent>\n): ResolvedCurriedValue<object | string>;\nexport function resolveCurriedValue(\n  curriedValue: CurriedValue<CurriedHelper> | CurriedValue<CurriedModifier>\n): ResolvedCurriedValue<object>;\nexport function resolveCurriedValue(\n  curriedValue: CurriedValue<CurriedType>\n): ResolvedCurriedValue<object | string> {\n  let currentWrapper = curriedValue;\n  let positional: Reference[] | undefined;\n  let named: Record<string, Reference>[] | undefined;\n  let definition, owner, resolved;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let { [ARGS]: curriedArgs, [INNER]: inner } = currentWrapper;\n\n    if (curriedArgs !== null) {\n      let { named: curriedNamed, positional: curriedPositional } = curriedArgs;\n\n      if (curriedPositional.length > 0) {\n        positional =\n          positional === undefined ? curriedPositional : curriedPositional.concat(positional);\n      }\n\n      if (named === undefined) {\n        named = [];\n      }\n\n      named.unshift(curriedNamed);\n    }\n\n    if (!isCurriedValue(inner)) {\n      // Save off the owner that this helper was curried with. Later on,\n      // we'll fetch the value of this register and set it as the owner on the\n      // new root scope.\n      definition = inner;\n      owner = currentWrapper[OWNER];\n      resolved = currentWrapper[RESOLVED];\n      break;\n    }\n\n    currentWrapper = inner;\n  }\n\n  return { definition, owner, resolved, positional, named };\n}\n\nexport function curry<T extends CurriedType>(\n  type: T,\n  spec: object | string | CurriedValue<T>,\n  owner: Owner,\n  args: CapturedArguments | null,\n  resolved = false\n): CurriedValue<T> {\n  return new CurriedValue(type, spec, owner, args, resolved);\n}\n","import type {\n  ComponentDefinitionState,\n  ComponentInstanceState,\n  InternalComponentManager,\n  WithCustomDebugRenderTree,\n} from '@glimmer/interfaces';\n\n/** @internal */\nexport function hasCustomDebugRenderTreeLifecycle<\n  D extends ComponentDefinitionState,\n  I extends ComponentInstanceState,\n>(manager: InternalComponentManager<I, D>): manager is WithCustomDebugRenderTree<I, D> {\n  return 'getDebugCustomRenderTree' in manager;\n}\n","import type { CompilableTemplate, Nullable, UpdatingOpcode } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport type { Revision, Tag } from '@glimmer/validator';\nimport {\n  check,\n  CheckBlockSymbolTable,\n  CheckHandle,\n  CheckInstanceof,\n  CheckNumber,\n  CheckOption,\n  CheckPrimitive,\n} from '@glimmer/debug';\nimport { toBool } from '@glimmer/global-context';\nimport {\n  createComputeRef,\n  createConstRef,\n  createPrimitiveRef,\n  FALSE_REFERENCE,\n  isConstRef,\n  NULL_REFERENCE,\n  TRUE_REFERENCE,\n  UNDEFINED_REFERENCE,\n  valueForRef,\n} from '@glimmer/reference';\nimport { assert, decodeHandle, decodeImmediate, expect, isHandle, unwrap } from '@glimmer/util';\nimport {\n  beginTrackFrame,\n  CONSTANT_TAG,\n  consumeTag,\n  endTrackFrame,\n  INITIAL,\n  validateTag,\n  valueForTag,\n} from '@glimmer/validator';\nimport { Op } from '@glimmer/vm';\n\nimport type { UpdatingVM } from '../../vm';\nimport type { InternalVM } from '../../vm/append';\n\nimport { APPEND_OPCODES } from '../../opcodes';\nimport { CONSTANTS } from '../../symbols';\nimport { VMArgumentsImpl } from '../../vm/arguments';\nimport { CheckReference, CheckScope } from './-debug-strip';\nimport { stackAssert } from './assert';\n\nAPPEND_OPCODES.add(Op.ChildScope, (vm) => vm.pushChildScope());\n\nAPPEND_OPCODES.add(Op.PopScope, (vm) => vm.popScope());\n\nAPPEND_OPCODES.add(Op.PushDynamicScope, (vm) => vm.pushDynamicScope());\n\nAPPEND_OPCODES.add(Op.PopDynamicScope, (vm) => vm.popDynamicScope());\n\nAPPEND_OPCODES.add(Op.Constant, (vm, { op1: other }) => {\n  vm.stack.push(vm[CONSTANTS].getValue(decodeHandle(other)));\n});\n\nAPPEND_OPCODES.add(Op.ConstantReference, (vm, { op1: other }) => {\n  vm.stack.push(createConstRef(vm[CONSTANTS].getValue(decodeHandle(other)), false));\n});\n\nAPPEND_OPCODES.add(Op.Primitive, (vm, { op1: primitive }) => {\n  let stack = vm.stack;\n\n  if (isHandle(primitive)) {\n    // it is a handle which does not already exist on the stack\n    let value = vm[CONSTANTS].getValue(decodeHandle(primitive));\n    stack.push(value as object);\n  } else {\n    // is already an encoded immediate or primitive handle\n    stack.push(decodeImmediate(primitive));\n  }\n});\n\nAPPEND_OPCODES.add(Op.PrimitiveReference, (vm) => {\n  let stack = vm.stack;\n  let value = check(stack.pop(), CheckPrimitive);\n  let ref;\n\n  if (value === undefined) {\n    ref = UNDEFINED_REFERENCE;\n  } else if (value === null) {\n    ref = NULL_REFERENCE;\n  } else if (value === true) {\n    ref = TRUE_REFERENCE;\n  } else if (value === false) {\n    ref = FALSE_REFERENCE;\n  } else {\n    ref = createPrimitiveRef(value);\n  }\n\n  stack.push(ref);\n});\n\nAPPEND_OPCODES.add(Op.Dup, (vm, { op1: register, op2: offset }) => {\n  let position = check(vm.fetchValue(register), CheckNumber) - offset;\n  vm.stack.dup(position);\n});\n\nAPPEND_OPCODES.add(Op.Pop, (vm, { op1: count }) => {\n  vm.stack.pop(count);\n});\n\nAPPEND_OPCODES.add(Op.Load, (vm, { op1: register }) => {\n  vm.load(register);\n});\n\nAPPEND_OPCODES.add(Op.Fetch, (vm, { op1: register }) => {\n  vm.fetch(register);\n});\n\nAPPEND_OPCODES.add(Op.BindDynamicScope, (vm, { op1: _names }) => {\n  let names = vm[CONSTANTS].getArray<string>(_names);\n  vm.bindDynamicScope(names);\n});\n\nAPPEND_OPCODES.add(Op.Enter, (vm, { op1: args }) => {\n  vm.enter(args);\n});\n\nAPPEND_OPCODES.add(Op.Exit, (vm) => {\n  vm.exit();\n});\n\nAPPEND_OPCODES.add(Op.PushSymbolTable, (vm, { op1: _table }) => {\n  let stack = vm.stack;\n  stack.push(vm[CONSTANTS].getValue(_table));\n});\n\nAPPEND_OPCODES.add(Op.PushBlockScope, (vm) => {\n  let stack = vm.stack;\n  stack.push(vm.scope());\n});\n\nAPPEND_OPCODES.add(Op.CompileBlock, (vm: InternalVM) => {\n  let stack = vm.stack;\n  let block = stack.pop<Nullable<CompilableTemplate> | 0>();\n\n  if (block) {\n    stack.push(vm.compile(block));\n  } else {\n    stack.push(null);\n  }\n});\n\nAPPEND_OPCODES.add(Op.InvokeYield, (vm) => {\n  let { stack } = vm;\n\n  let handle = check(stack.pop(), CheckOption(CheckHandle));\n  let scope = check(stack.pop(), CheckOption(CheckScope));\n  let table = check(stack.pop(), CheckOption(CheckBlockSymbolTable));\n\n  assert(\n    table === null || (table && typeof table === 'object' && Array.isArray(table.parameters)),\n    stackAssert('Option<BlockSymbolTable>', table)\n  );\n\n  let args = check(stack.pop(), CheckInstanceof(VMArgumentsImpl));\n\n  if (table === null) {\n    // To balance the pop{Frame,Scope}\n    vm.pushFrame();\n    vm.pushScope(scope ?? vm.scope());\n\n    return;\n  }\n\n  let invokingScope = expect(scope, 'BUG: expected scope');\n\n  // If necessary, create a child scope\n  {\n    let locals = table.parameters;\n    let localsCount = locals.length;\n\n    if (localsCount > 0) {\n      invokingScope = invokingScope.child();\n\n      for (let i = 0; i < localsCount; i++) {\n        invokingScope.bindSymbol(unwrap(locals[i]), args.at(i));\n      }\n    }\n  }\n\n  vm.pushFrame();\n  vm.pushScope(invokingScope);\n  vm.call(handle!);\n});\n\nAPPEND_OPCODES.add(Op.JumpIf, (vm, { op1: target }) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n  let value = Boolean(valueForRef(reference));\n\n  if (isConstRef(reference)) {\n    if (value === true) {\n      vm.goto(target);\n    }\n  } else {\n    if (value === true) {\n      vm.goto(target);\n    }\n\n    vm.updateWith(new Assert(reference));\n  }\n});\n\nAPPEND_OPCODES.add(Op.JumpUnless, (vm, { op1: target }) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n  let value = Boolean(valueForRef(reference));\n\n  if (isConstRef(reference)) {\n    if (value === false) {\n      vm.goto(target);\n    }\n  } else {\n    if (value === false) {\n      vm.goto(target);\n    }\n\n    vm.updateWith(new Assert(reference));\n  }\n});\n\nAPPEND_OPCODES.add(Op.JumpEq, (vm, { op1: target, op2: comparison }) => {\n  let other = check(vm.stack.peek(), CheckNumber);\n\n  if (other === comparison) {\n    vm.goto(target);\n  }\n});\n\nAPPEND_OPCODES.add(Op.AssertSame, (vm) => {\n  let reference = check(vm.stack.peek(), CheckReference);\n\n  if (isConstRef(reference) === false) {\n    vm.updateWith(new Assert(reference));\n  }\n});\n\nAPPEND_OPCODES.add(Op.ToBoolean, (vm) => {\n  let { stack } = vm;\n  let valueRef = check(stack.pop(), CheckReference);\n\n  stack.push(createComputeRef(() => toBool(valueForRef(valueRef))));\n});\n\nexport class Assert implements UpdatingOpcode {\n  private last: unknown;\n\n  constructor(private ref: Reference) {\n    this.last = valueForRef(ref);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { last, ref } = this;\n    let current = valueForRef(ref);\n\n    if (last !== current) {\n      vm.throw();\n    }\n  }\n}\n\nexport class AssertFilter<T, U> implements UpdatingOpcode {\n  private last: U;\n\n  constructor(\n    private ref: Reference<T>,\n    private filter: (from: T) => U\n  ) {\n    this.last = filter(valueForRef(ref));\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { last, ref, filter } = this;\n    let current = filter(valueForRef(ref));\n\n    if (last !== current) {\n      vm.throw();\n    }\n  }\n}\n\nexport class JumpIfNotModifiedOpcode implements UpdatingOpcode {\n  private tag: Tag = CONSTANT_TAG;\n  private lastRevision: Revision = INITIAL;\n  private target?: number;\n\n  finalize(tag: Tag, target: number) {\n    this.target = target;\n    this.didModify(tag);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { tag, target, lastRevision } = this;\n\n    if (!vm.alwaysRevalidate && validateTag(tag, lastRevision)) {\n      consumeTag(tag);\n      vm.goto(expect(target, 'VM BUG: Target must be set before attempting to jump'));\n    }\n  }\n\n  didModify(tag: Tag) {\n    this.tag = tag;\n    this.lastRevision = valueForTag(this.tag);\n    consumeTag(tag);\n  }\n}\n\nexport class BeginTrackFrameOpcode implements UpdatingOpcode {\n  constructor(private debugLabel?: string) {}\n\n  evaluate() {\n    beginTrackFrame(this.debugLabel);\n  }\n}\n\nexport class EndTrackFrameOpcode implements UpdatingOpcode {\n  constructor(private target: JumpIfNotModifiedOpcode) {}\n\n  evaluate() {\n    let tag = endTrackFrame();\n    this.target.didModify(tag);\n  }\n}\n","export function stackAssert(name: string, top: unknown) {\n  return `Expected top of stack to be ${name}, was ${String(top)}`;\n}\n","import type {\n  CapturedPositionalArguments,\n  Environment,\n  ModifierDefinition,\n  ModifierDefinitionState,\n  ModifierInstance,\n  Nullable,\n  Owner,\n  UpdatingOpcode,\n  UpdatingVM,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport type { Revision, Tag } from '@glimmer/validator';\nimport {\n  check,\n  CheckElement,\n  CheckMaybe,\n  CheckNode,\n  CheckOption,\n  CheckString,\n} from '@glimmer/debug';\nimport { associateDestroyableChild, destroy, registerDestructor } from '@glimmer/destroyable';\nimport { getInternalModifierManager } from '@glimmer/manager';\nimport { createComputeRef, isConstRef, valueForRef } from '@glimmer/reference';\nimport { debugToString, expect, isObject } from '@glimmer/util';\nimport { consumeTag, CURRENT_TAG, validateTag, valueForTag } from '@glimmer/validator';\nimport { $t0, CurriedTypes, Op } from '@glimmer/vm';\n\nimport type { CurriedValue } from '../../curried-value';\nimport type { DynamicAttribute } from '../../vm/attributes/dynamic';\n\nimport { isCurriedType, resolveCurriedValue } from '../../curried-value';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport { CONSTANTS } from '../../symbols';\nimport { createCapturedArgs } from '../../vm/arguments';\nimport { CheckArguments, CheckOperations, CheckReference } from './-debug-strip';\nimport { Assert } from './vm';\n\nAPPEND_OPCODES.add(Op.Text, (vm, { op1: text }) => {\n  vm.elements().appendText(vm[CONSTANTS].getValue(text));\n});\n\nAPPEND_OPCODES.add(Op.Comment, (vm, { op1: text }) => {\n  vm.elements().appendComment(vm[CONSTANTS].getValue(text));\n});\n\nAPPEND_OPCODES.add(Op.OpenElement, (vm, { op1: tag }) => {\n  vm.elements().openElement(vm[CONSTANTS].getValue(tag));\n});\n\nAPPEND_OPCODES.add(Op.OpenDynamicElement, (vm) => {\n  let tagName = check(valueForRef(check(vm.stack.pop(), CheckReference)), CheckString);\n  vm.elements().openElement(tagName);\n});\n\nAPPEND_OPCODES.add(Op.PushRemoteElement, (vm) => {\n  let elementRef = check(vm.stack.pop(), CheckReference);\n  let insertBeforeRef = check(vm.stack.pop(), CheckReference);\n  let guidRef = check(vm.stack.pop(), CheckReference);\n\n  let element = check(valueForRef(elementRef), CheckElement);\n  let insertBefore = check(valueForRef(insertBeforeRef), CheckMaybe(CheckOption(CheckNode)));\n  let guid = valueForRef(guidRef) as string;\n\n  if (!isConstRef(elementRef)) {\n    vm.updateWith(new Assert(elementRef));\n  }\n\n  if (insertBefore !== undefined && !isConstRef(insertBeforeRef)) {\n    vm.updateWith(new Assert(insertBeforeRef));\n  }\n\n  let block = vm.elements().pushRemoteElement(element, guid, insertBefore);\n  if (block) vm.associateDestroyable(block);\n\n  if (vm.env.debugRenderTree !== undefined) {\n    // Note that there is nothing to update  when the args for an\n    // {{#in-element}} changes it gets torn down and a new one is\n    // re-created/rendered in its place (see the `Assert`s above)\n    let args = createCapturedArgs(\n      insertBefore === undefined ? {} : { insertBefore: insertBeforeRef },\n      [elementRef]\n    );\n\n    vm.env.debugRenderTree.create(block, {\n      type: 'keyword',\n      name: 'in-element',\n      args,\n      instance: null,\n    });\n\n    registerDestructor(block, () => {\n      vm.env.debugRenderTree?.willDestroy(block);\n    });\n  }\n});\n\nAPPEND_OPCODES.add(Op.PopRemoteElement, (vm) => {\n  let bounds = vm.elements().popRemoteElement();\n\n  if (vm.env.debugRenderTree !== undefined) {\n    // The RemoteLiveBlock is also its bounds\n    vm.env.debugRenderTree.didRender(bounds, bounds);\n  }\n});\n\nAPPEND_OPCODES.add(Op.FlushElement, (vm) => {\n  let operations = check(vm.fetchValue($t0), CheckOperations);\n  let modifiers: Nullable<ModifierInstance[]> = null;\n\n  if (operations) {\n    modifiers = operations.flush(vm);\n    vm.loadValue($t0, null);\n  }\n\n  vm.elements().flushElement(modifiers);\n});\n\nAPPEND_OPCODES.add(Op.CloseElement, (vm) => {\n  let modifiers = vm.elements().closeElement();\n\n  if (modifiers !== null) {\n    modifiers.forEach((modifier) => {\n      vm.env.scheduleInstallModifier(modifier);\n      const d = modifier.manager.getDestroyable(modifier.state);\n\n      if (d !== null) {\n        vm.associateDestroyable(d);\n      }\n    });\n  }\n});\n\nAPPEND_OPCODES.add(Op.Modifier, (vm, { op1: handle }) => {\n  if (vm.env.isInteractive === false) {\n    return;\n  }\n\n  let owner = vm.getOwner();\n  let args = check(vm.stack.pop(), CheckArguments);\n  let definition = vm[CONSTANTS].getValue<ModifierDefinition>(handle);\n\n  let { manager } = definition;\n\n  let { constructing } = vm.elements();\n\n  let capturedArgs = args.capture();\n  let state = manager.create(\n    owner,\n    expect(constructing, 'BUG: ElementModifier could not find the element it applies to'),\n    definition.state,\n    capturedArgs\n  );\n\n  let instance: ModifierInstance = {\n    manager,\n    state,\n    definition,\n  };\n\n  let operations = expect(\n    check(vm.fetchValue($t0), CheckOperations),\n    'BUG: ElementModifier could not find operations to append to'\n  );\n\n  operations.addModifier(vm, instance, capturedArgs);\n\n  let tag = manager.getTag(state);\n\n  if (tag !== null) {\n    consumeTag(tag);\n    return vm.updateWith(new UpdateModifierOpcode(tag, instance));\n  }\n});\n\nAPPEND_OPCODES.add(Op.DynamicModifier, (vm) => {\n  if (vm.env.isInteractive === false) {\n    return;\n  }\n\n  let { stack } = vm;\n  let ref = check(stack.pop(), CheckReference);\n  let args = check(stack.pop(), CheckArguments).capture();\n  let { positional: outerPositional, named: outerNamed } = args;\n\n  let { constructing } = vm.elements();\n  let initialOwner = vm.getOwner();\n\n  let instanceRef = createComputeRef(() => {\n    let value = valueForRef(ref);\n    let owner: Owner;\n\n    if (!isObject(value)) {\n      return;\n    }\n\n    let hostDefinition: CurriedValue | ModifierDefinitionState;\n\n    if (isCurriedType(value, CurriedTypes.Modifier)) {\n      let {\n        definition: resolvedDefinition,\n        owner: curriedOwner,\n        positional,\n        named,\n      } = resolveCurriedValue(value);\n\n      hostDefinition = resolvedDefinition;\n      owner = curriedOwner;\n\n      if (positional !== undefined) {\n        args.positional = positional.concat(outerPositional) as CapturedPositionalArguments;\n      }\n\n      if (named !== undefined) {\n        args.named = Object.assign({}, ...named, outerNamed);\n      }\n    } else {\n      hostDefinition = value;\n      owner = initialOwner;\n    }\n\n    let manager = getInternalModifierManager(hostDefinition, true);\n\n    if (manager === null) {\n      if (import.meta.env.DEV) {\n        throw new Error(\n          `Expected a dynamic modifier definition, but received an object or function that did not have a modifier manager associated with it. The dynamic invocation was \\`{{${\n            ref.debugLabel\n          }}}\\`, and the incorrect definition is the value at the path \\`${\n            ref.debugLabel\n          }\\`, which was: ${debugToString!(hostDefinition)}`\n        );\n      } else {\n        throw new Error('BUG: modifier manager expected');\n      }\n    }\n\n    let definition = {\n      resolvedName: null,\n      manager,\n      state: hostDefinition,\n    };\n\n    let state = manager.create(\n      owner,\n      expect(constructing, 'BUG: ElementModifier could not find the element it applies to'),\n      definition.state,\n      args\n    );\n\n    return {\n      manager,\n      state,\n      definition,\n    };\n  });\n\n  let instance = valueForRef(instanceRef);\n  let tag = null;\n\n  if (instance !== undefined) {\n    let operations = expect(\n      check(vm.fetchValue($t0), CheckOperations),\n      'BUG: ElementModifier could not find operations to append to'\n    );\n\n    operations.addModifier(vm, instance, args);\n\n    tag = instance.manager.getTag(instance.state);\n\n    if (tag !== null) {\n      consumeTag(tag);\n    }\n  }\n\n  if (!isConstRef(ref) || tag) {\n    return vm.updateWith(new UpdateDynamicModifierOpcode(tag, instance, instanceRef));\n  }\n});\n\nexport class UpdateModifierOpcode implements UpdatingOpcode {\n  private lastUpdated: Revision;\n\n  constructor(\n    private tag: Tag,\n    private modifier: ModifierInstance\n  ) {\n    this.lastUpdated = valueForTag(tag);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { modifier, tag, lastUpdated } = this;\n\n    consumeTag(tag);\n\n    if (!validateTag(tag, lastUpdated)) {\n      vm.env.scheduleUpdateModifier(modifier);\n      this.lastUpdated = valueForTag(tag);\n    }\n  }\n}\n\nexport class UpdateDynamicModifierOpcode implements UpdatingOpcode {\n  private lastUpdated: Revision;\n\n  constructor(\n    private tag: Tag | null,\n    private instance: ModifierInstance | undefined,\n    private instanceRef: Reference<ModifierInstance | undefined>\n  ) {\n    this.lastUpdated = valueForTag(tag ?? CURRENT_TAG);\n  }\n\n  evaluate(vm: UpdatingVM) {\n    let { tag, lastUpdated, instance, instanceRef } = this;\n\n    let newInstance = valueForRef(instanceRef);\n\n    if (newInstance !== instance) {\n      if (instance !== undefined) {\n        let destroyable = instance.manager.getDestroyable(instance.state);\n\n        if (destroyable !== null) {\n          destroy(destroyable);\n        }\n      }\n\n      if (newInstance !== undefined) {\n        let { manager, state } = newInstance;\n        let destroyable = manager.getDestroyable(state);\n\n        if (destroyable !== null) {\n          associateDestroyableChild(this, destroyable);\n        }\n\n        tag = manager.getTag(state);\n\n        if (tag !== null) {\n          this.lastUpdated = valueForTag(tag);\n        }\n\n        this.tag = tag;\n        vm.env.scheduleInstallModifier(newInstance);\n      }\n\n      this.instance = newInstance;\n    } else if (tag !== null && !validateTag(tag, lastUpdated)) {\n      vm.env.scheduleUpdateModifier(instance!);\n      this.lastUpdated = valueForTag(tag);\n    }\n\n    if (tag !== null) {\n      consumeTag(tag);\n    }\n  }\n}\n\nAPPEND_OPCODES.add(Op.StaticAttr, (vm, { op1: _name, op2: _value, op3: _namespace }) => {\n  let name = vm[CONSTANTS].getValue<string>(_name);\n  let value = vm[CONSTANTS].getValue<string>(_value);\n  let namespace = _namespace ? vm[CONSTANTS].getValue<string>(_namespace) : null;\n\n  vm.elements().setStaticAttribute(name, value, namespace);\n});\n\nAPPEND_OPCODES.add(Op.DynamicAttr, (vm, { op1: _name, op2: _trusting, op3: _namespace }) => {\n  let name = vm[CONSTANTS].getValue<string>(_name);\n  let trusting = vm[CONSTANTS].getValue<boolean>(_trusting);\n  let reference = check(vm.stack.pop(), CheckReference);\n  let value = valueForRef(reference);\n  let namespace = _namespace ? vm[CONSTANTS].getValue<string>(_namespace) : null;\n\n  let attribute = vm.elements().setDynamicAttribute(name, value, trusting, namespace);\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute, vm.env));\n  }\n});\n\nexport class UpdateDynamicAttributeOpcode implements UpdatingOpcode {\n  private updateRef: Reference;\n\n  constructor(reference: Reference<unknown>, attribute: DynamicAttribute, env: Environment) {\n    let initialized = false;\n\n    this.updateRef = createComputeRef(() => {\n      let value = valueForRef(reference);\n\n      if (initialized === true) {\n        attribute.update(value, env);\n      } else {\n        initialized = true;\n      }\n    });\n\n    valueForRef(this.updateRef);\n  }\n\n  evaluate() {\n    valueForRef(this.updateRef);\n  }\n}\n","import type {\n  Bounds,\n  CapabilityMask,\n  CapturedArguments,\n  CompilableProgram,\n  ComponentDefinition,\n  ComponentDefinitionState,\n  ComponentInstance,\n  ComponentInstanceState,\n  ComponentInstanceWithCreate,\n  Dict,\n  DynamicScope,\n  ElementOperations,\n  InternalComponentManager,\n  ModifierInstance,\n  Nullable,\n  Owner,\n  ProgramSymbolTable,\n  Recast,\n  ScopeSlot,\n  UpdatingOpcode,\n  VMArguments,\n  WithDynamicTagName,\n  WithElementHook,\n  WithUpdateHook,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport {\n  check,\n  CheckFunction,\n  CheckHandle,\n  CheckInstanceof,\n  CheckInterface,\n  CheckOr,\n  CheckProgramSymbolTable,\n  CheckString,\n} from '@glimmer/debug';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { managerHasCapability } from '@glimmer/manager';\nimport { isConstRef, valueForRef } from '@glimmer/reference';\nimport {\n  assert,\n  assign,\n  debugToString,\n  dict,\n  EMPTY_STRING_ARRAY,\n  enumerate,\n  expect,\n  unwrap,\n  unwrapTemplate,\n} from '@glimmer/util';\nimport { $t0, $t1, CurriedTypes, InternalComponentCapabilities, Op } from '@glimmer/vm';\n\nimport type { CurriedValue } from '../../curried-value';\nimport type { UpdatingVM } from '../../vm';\nimport type { InternalVM } from '../../vm/append';\nimport type { BlockArgumentsImpl } from '../../vm/arguments';\n\nimport { ConcreteBounds } from '../../bounds';\nimport { hasCustomDebugRenderTreeLifecycle } from '../../component/interfaces';\nimport { resolveComponent } from '../../component/resolve';\nimport { isCurriedType, isCurriedValue, resolveCurriedValue } from '../../curried-value';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport createClassListRef from '../../references/class-list';\nimport { ARGS, CONSTANTS } from '../../symbols';\nimport { EMPTY_ARGS, VMArgumentsImpl } from '../../vm/arguments';\nimport {\n  CheckArguments,\n  CheckComponentDefinition,\n  CheckComponentInstance,\n  CheckCurriedComponentDefinition,\n  CheckFinishedComponentInstance,\n  CheckInvocation,\n  CheckReference,\n} from './-debug-strip';\nimport { UpdateDynamicAttributeOpcode } from './dom';\n\n/**\n * The VM creates a new ComponentInstance data structure for every component\n * invocation it encounters.\n *\n * Similar to how a ComponentDefinition contains state about all components of a\n * particular type, a ComponentInstance contains state specific to a particular\n * instance of a component type. It also contains a pointer back to its\n * component type's ComponentDefinition.\n */\n\nexport interface InitialComponentInstance {\n  definition: ComponentDefinition;\n  manager: Nullable<InternalComponentManager>;\n  capabilities: Nullable<CapabilityMask>;\n  state: null;\n  handle: Nullable<number>;\n  table: Nullable<ProgramSymbolTable>;\n  lookup: Nullable<Dict<ScopeSlot>>;\n}\n\nexport interface PopulatedComponentInstance {\n  definition: ComponentDefinition;\n  manager: InternalComponentManager;\n  capabilities: CapabilityMask;\n  state: null;\n  handle: number;\n  table: Nullable<ProgramSymbolTable>;\n  lookup: Nullable<Dict<ScopeSlot>>;\n}\n\nexport interface PartialComponentDefinition {\n  state: Nullable<ComponentDefinitionState>;\n  manager: InternalComponentManager;\n}\n\nAPPEND_OPCODES.add(Op.PushComponentDefinition, (vm, { op1: handle }) => {\n  let definition = vm[CONSTANTS].getValue<ComponentDefinition>(handle);\n  assert(!!definition, `Missing component for ${handle}`);\n\n  let { manager, capabilities } = definition;\n\n  let instance: InitialComponentInstance = {\n    definition,\n    manager,\n    capabilities,\n    state: null,\n    handle: null,\n    table: null,\n    lookup: null,\n  };\n\n  vm.stack.push(instance);\n});\n\nAPPEND_OPCODES.add(Op.ResolveDynamicComponent, (vm, { op1: _isStrict }) => {\n  let stack = vm.stack;\n  let component = check(\n    valueForRef(check(stack.pop(), CheckReference)),\n    CheckOr(CheckString, CheckCurriedComponentDefinition)\n  );\n  let constants = vm[CONSTANTS];\n  let owner = vm.getOwner();\n  let isStrict = constants.getValue<boolean>(_isStrict);\n\n  vm.loadValue($t1, null); // Clear the temp register\n\n  let definition: ComponentDefinition | CurriedValue;\n\n  if (typeof component === 'string') {\n    if (import.meta.env.DEV && isStrict) {\n      throw new Error(\n        `Attempted to resolve a dynamic component with a string definition, \\`${component}\\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`\n      );\n    }\n\n    let resolvedDefinition = resolveComponent(vm.runtime.resolver, constants, component, owner);\n\n    definition = expect(resolvedDefinition, `Could not find a component named \"${component}\"`);\n  } else if (isCurriedValue(component)) {\n    definition = component;\n  } else {\n    definition = constants.component(component, owner);\n  }\n\n  stack.push(definition);\n});\n\nAPPEND_OPCODES.add(Op.ResolveCurriedComponent, (vm) => {\n  let stack = vm.stack;\n  let ref = check(stack.pop(), CheckReference);\n  let value = valueForRef(ref);\n  let constants = vm[CONSTANTS];\n\n  let definition: CurriedValue | ComponentDefinition | null;\n\n  if (\n    import.meta.env.DEV &&\n    !(typeof value === 'function' || (typeof value === 'object' && value !== null))\n  ) {\n    throw new Error(\n      `Expected a component definition, but received ${value}. You may have accidentally done <${ref.debugLabel}>, where \"${ref.debugLabel}\" was a string instead of a curried component definition. You must either use the component definition directly, or use the {{component}} helper to create a curried component definition when invoking dynamically.`\n    );\n  }\n\n  if (isCurriedValue(value)) {\n    definition = value;\n  } else {\n    definition = constants.component(value as object, vm.getOwner(), true);\n\n    if (import.meta.env.DEV && definition === null) {\n      throw new Error(\n        `Expected a dynamic component definition, but received an object or function that did not have a component manager associated with it. The dynamic invocation was \\`<${\n          ref.debugLabel\n        }>\\` or \\`{{${\n          ref.debugLabel\n        }}}\\`, and the incorrect definition is the value at the path \\`${\n          ref.debugLabel\n        }\\`, which was: ${debugToString!(value)}`\n      );\n    }\n  }\n\n  stack.push(definition);\n});\n\nAPPEND_OPCODES.add(Op.PushDynamicComponentInstance, (vm) => {\n  let { stack } = vm;\n  let definition = stack.pop<ComponentDefinition>();\n\n  let capabilities, manager;\n\n  if (isCurriedValue(definition)) {\n    manager = capabilities = null;\n  } else {\n    manager = definition.manager;\n    capabilities = definition.capabilities;\n  }\n\n  stack.push({ definition, capabilities, manager, state: null, handle: null, table: null });\n});\n\nAPPEND_OPCODES.add(Op.PushArgs, (vm, { op1: _names, op2: _blockNames, op3: flags }) => {\n  let stack = vm.stack;\n  let names = vm[CONSTANTS].getArray<string>(_names);\n\n  let positionalCount = flags >> 4;\n  let atNames = flags & 0b1000;\n  let blockNames =\n    flags & 0b0111 ? vm[CONSTANTS].getArray<string>(_blockNames) : EMPTY_STRING_ARRAY;\n\n  vm[ARGS].setup(stack, names, blockNames, positionalCount, !!atNames);\n  stack.push(vm[ARGS]);\n});\n\nAPPEND_OPCODES.add(Op.PushEmptyArgs, (vm) => {\n  let { stack } = vm;\n\n  stack.push(vm[ARGS].empty(stack));\n});\n\nAPPEND_OPCODES.add(Op.CaptureArgs, (vm) => {\n  let stack = vm.stack;\n\n  let args = check(stack.pop(), CheckInstanceof(VMArgumentsImpl));\n  let capturedArgs = args.capture();\n  stack.push(capturedArgs);\n});\n\nAPPEND_OPCODES.add(Op.PrepareArgs, (vm, { op1: _state }) => {\n  let stack = vm.stack;\n  let instance = vm.fetchValue<ComponentInstance>(_state);\n  let args = check(stack.pop(), CheckInstanceof(VMArgumentsImpl));\n\n  let { definition } = instance;\n\n  if (isCurriedType(definition, CurriedTypes.Component)) {\n    assert(\n      !definition.manager,\n      \"If the component definition was curried, we don't yet have a manager\"\n    );\n\n    let constants = vm[CONSTANTS];\n\n    let {\n      definition: resolvedDefinition,\n      owner,\n      resolved,\n      positional,\n      named,\n    } = resolveCurriedValue(definition);\n\n    if (resolved === true) {\n      definition = resolvedDefinition as ComponentDefinition;\n    } else if (typeof resolvedDefinition === 'string') {\n      let resolvedValue = vm.runtime.resolver.lookupComponent(resolvedDefinition, owner);\n\n      definition = constants.resolvedComponent(\n        expect(resolvedValue, 'BUG: expected resolved component'),\n        resolvedDefinition\n      );\n    } else {\n      definition = constants.component(resolvedDefinition, owner);\n    }\n\n    if (named !== undefined) {\n      args.named.merge(assign({}, ...named));\n    }\n\n    if (positional !== undefined) {\n      args.realloc(positional.length);\n      args.positional.prepend(positional);\n    }\n\n    let { manager } = definition;\n\n    assert(instance.manager === null, 'component instance manager should not be populated yet');\n    assert(\n      instance.capabilities === null,\n      'component instance manager should not be populated yet'\n    );\n\n    instance.definition = definition;\n    instance.manager = manager;\n    instance.capabilities = definition.capabilities;\n\n    // Save off the owner that this component was curried with. Later on,\n    // we'll fetch the value of this register and set it as the owner on the\n    // new root scope.\n    vm.loadValue($t1, owner);\n  }\n\n  let { manager, state } = definition;\n  let capabilities = instance.capabilities;\n\n  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.prepareArgs)) {\n    stack.push(args);\n    return;\n  }\n\n  let blocks = args.blocks.values;\n  let blockNames = args.blocks.names;\n  let preparedArgs = manager.prepareArgs(state, args);\n\n  if (preparedArgs) {\n    args.clear();\n\n    for (let i = 0; i < blocks.length; i++) {\n      stack.push(blocks[i]);\n    }\n\n    let { positional, named } = preparedArgs;\n\n    let positionalCount = positional.length;\n\n    for (let i = 0; i < positionalCount; i++) {\n      stack.push(positional[i]);\n    }\n\n    let names = Object.keys(named);\n\n    for (let i = 0; i < names.length; i++) {\n      stack.push(named[unwrap(names[i])]);\n    }\n\n    args.setup(stack, names, blockNames, positionalCount, false);\n  }\n\n  stack.push(args);\n});\n\nAPPEND_OPCODES.add(Op.CreateComponent, (vm, { op1: flags, op2: _state }) => {\n  let instance = check(vm.fetchValue(_state), CheckComponentInstance);\n  let { definition, manager, capabilities } = instance;\n\n  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance)) {\n    // TODO: Closure and Main components are always invoked dynamically, so this\n    // opcode may run even if this capability is not enabled. In the future we\n    // should handle this in a better way.\n    return;\n  }\n\n  let dynamicScope: Nullable<DynamicScope> = null;\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicScope)) {\n    dynamicScope = vm.dynamicScope();\n  }\n\n  let hasDefaultBlock = flags & 1;\n  let args: Nullable<VMArguments> = null;\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.createArgs)) {\n    args = check(vm.stack.peek(), CheckArguments);\n  }\n\n  let self: Nullable<Reference> = null;\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.createCaller)) {\n    self = vm.getSelf();\n  }\n\n  let state = manager.create(\n    vm.getOwner(),\n    definition.state,\n    args,\n    vm.env,\n    dynamicScope,\n    self,\n    !!hasDefaultBlock\n  );\n\n  // We want to reuse the `state` POJO here, because we know that the opcodes\n  // only transition at exactly one place.\n  instance.state = state;\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.updateHook)) {\n    vm.updateWith(new UpdateComponentOpcode(state, manager, dynamicScope));\n  }\n});\n\nAPPEND_OPCODES.add(Op.RegisterComponentDestructor, (vm, { op1: _state }) => {\n  let { manager, state, capabilities } = check(vm.fetchValue(_state), CheckComponentInstance);\n\n  let d = manager.getDestroyable(state);\n\n  if (\n    import.meta.env.DEV &&\n    !managerHasCapability(manager, capabilities, InternalComponentCapabilities.willDestroy) &&\n    d !== null &&\n    (typeof 'willDestroy') in d\n  ) {\n    throw new Error(\n      'BUG: Destructor has willDestroy, but the willDestroy capability was not enabled for this component. Pre-destruction hooks must be explicitly opted into'\n    );\n  }\n\n  if (d) vm.associateDestroyable(d);\n});\n\nAPPEND_OPCODES.add(Op.BeginComponentTransaction, (vm, { op1: _state }) => {\n  let name;\n\n  if (import.meta.env.DEV) {\n    let { definition, manager } = check(vm.fetchValue(_state), CheckComponentInstance);\n\n    name = definition.resolvedName ?? manager.getDebugName(definition.state);\n  }\n\n  vm.beginCacheGroup(name);\n  vm.elements().pushSimpleBlock();\n});\n\nAPPEND_OPCODES.add(Op.PutComponentOperations, (vm) => {\n  vm.loadValue($t0, new ComponentElementOperations());\n});\n\nAPPEND_OPCODES.add(Op.ComponentAttr, (vm, { op1: _name, op2: _trusting, op3: _namespace }) => {\n  let name = vm[CONSTANTS].getValue<string>(_name);\n  let trusting = vm[CONSTANTS].getValue<boolean>(_trusting);\n  let reference = check(vm.stack.pop(), CheckReference);\n  let namespace = _namespace ? vm[CONSTANTS].getValue<string>(_namespace) : null;\n\n  check(vm.fetchValue($t0), CheckInstanceof(ComponentElementOperations)).setAttribute(\n    name,\n    reference,\n    trusting,\n    namespace\n  );\n});\n\nAPPEND_OPCODES.add(Op.StaticComponentAttr, (vm, { op1: _name, op2: _value, op3: _namespace }) => {\n  let name = vm[CONSTANTS].getValue<string>(_name);\n  let value = vm[CONSTANTS].getValue<string>(_value);\n  let namespace = _namespace ? vm[CONSTANTS].getValue<string>(_namespace) : null;\n\n  check(vm.fetchValue($t0), CheckInstanceof(ComponentElementOperations)).setStaticAttribute(\n    name,\n    value,\n    namespace\n  );\n});\n\ntype DeferredAttribute = {\n  value: string | Reference<unknown>;\n  namespace: Nullable<string>;\n  trusting?: boolean;\n};\n\nexport class ComponentElementOperations implements ElementOperations {\n  private attributes = dict<DeferredAttribute>();\n  private classes: (string | Reference<unknown>)[] = [];\n  private modifiers: ModifierInstance[] = [];\n\n  setAttribute(\n    name: string,\n    value: Reference<unknown>,\n    trusting: boolean,\n    namespace: Nullable<string>\n  ) {\n    let deferred = { value, namespace, trusting };\n\n    if (name === 'class') {\n      this.classes.push(value);\n    }\n\n    this.attributes[name] = deferred;\n  }\n\n  setStaticAttribute(name: string, value: string, namespace: Nullable<string>): void {\n    let deferred = { value, namespace };\n\n    if (name === 'class') {\n      this.classes.push(value);\n    }\n\n    this.attributes[name] = deferred;\n  }\n\n  addModifier(vm: InternalVM, modifier: ModifierInstance, capturedArgs: CapturedArguments): void {\n    this.modifiers.push(modifier);\n\n    if (vm.env.debugRenderTree !== undefined) {\n      const { manager, definition, state } = modifier;\n\n      // TODO: we need a stable object for the debugRenderTree as the key, add support for\n      // the case where the state is a primitive, or if in practice we always have/require\n      // an object, then change the internal types to reflect that\n      if (state === null || (typeof state !== 'object' && typeof state !== 'function')) {\n        return;\n      }\n\n      let { element, constructing } = vm.elements();\n      let name = manager.getDebugName(definition.state);\n      let instance = manager.getDebugInstance(state);\n\n      assert(constructing, `Expected a constructing element in addModifier`);\n\n      let bounds = new ConcreteBounds(element, constructing, constructing);\n\n      vm.env.debugRenderTree.create(state, {\n        type: 'modifier',\n        name,\n        args: capturedArgs,\n        instance,\n      });\n\n      vm.env.debugRenderTree.didRender(state, bounds);\n\n      // For tearing down the debugRenderTree\n      vm.associateDestroyable(state);\n\n      vm.updateWith(new DebugRenderTreeUpdateOpcode(state));\n      vm.updateWith(new DebugRenderTreeDidRenderOpcode(state, bounds));\n\n      registerDestructor(state, () => {\n        vm.env.debugRenderTree?.willDestroy(state);\n      });\n    }\n  }\n\n  flush(vm: InternalVM): ModifierInstance[] {\n    let type: DeferredAttribute | undefined;\n    let attributes = this.attributes;\n\n    for (let name in this.attributes) {\n      if (name === 'type') {\n        type = attributes[name];\n        continue;\n      }\n\n      let attr = unwrap(this.attributes[name]);\n      if (name === 'class') {\n        setDeferredAttr(vm, 'class', mergeClasses(this.classes), attr.namespace, attr.trusting);\n      } else {\n        setDeferredAttr(vm, name, attr.value, attr.namespace, attr.trusting);\n      }\n    }\n\n    if (type !== undefined) {\n      setDeferredAttr(vm, 'type', type.value, type.namespace, type.trusting);\n    }\n\n    return this.modifiers;\n  }\n}\n\nfunction mergeClasses(classes: (string | Reference)[]): string | Reference<unknown> {\n  if (classes.length === 0) {\n    return '';\n  }\n  if (classes.length === 1) {\n    return unwrap(classes[0]);\n  }\n  if (allStringClasses(classes)) {\n    return classes.join(' ');\n  }\n\n  return createClassListRef(classes as Reference[]);\n}\n\nfunction allStringClasses(classes: (string | Reference<unknown>)[]): classes is string[] {\n  return classes.every((c) => typeof c === 'string');\n}\n\nfunction setDeferredAttr(\n  vm: InternalVM,\n  name: string,\n  value: string | Reference<unknown>,\n  namespace: Nullable<string>,\n  trusting = false\n) {\n  if (typeof value === 'string') {\n    vm.elements().setStaticAttribute(name, value, namespace);\n  } else {\n    let attribute = vm\n      .elements()\n      .setDynamicAttribute(name, valueForRef(value), trusting, namespace);\n    if (!isConstRef(value)) {\n      vm.updateWith(new UpdateDynamicAttributeOpcode(value, attribute, vm.env));\n    }\n  }\n}\n\nAPPEND_OPCODES.add(Op.DidCreateElement, (vm, { op1: _state }) => {\n  let { definition, state } = check(vm.fetchValue(_state), CheckComponentInstance);\n  let { manager } = definition;\n\n  let operations = check(vm.fetchValue($t0), CheckInstanceof(ComponentElementOperations));\n\n  (manager as WithElementHook<unknown>).didCreateElement(\n    state,\n    expect(vm.elements().constructing, `Expected a constructing element in DidCreateOpcode`),\n    operations\n  );\n});\n\nAPPEND_OPCODES.add(Op.GetComponentSelf, (vm, { op1: _state, op2: _names }) => {\n  let instance = check(vm.fetchValue(_state), CheckComponentInstance);\n  let { definition, state } = instance;\n  let { manager } = definition;\n  let selfRef = manager.getSelf(state);\n\n  if (vm.env.debugRenderTree !== undefined) {\n    let instance = check(vm.fetchValue(_state), CheckComponentInstance);\n    let { definition, manager } = instance;\n\n    let args: CapturedArguments;\n\n    if (vm.stack.peek() === vm[ARGS]) {\n      args = vm[ARGS].capture();\n    } else {\n      let names = vm[CONSTANTS].getArray<string>(_names);\n      vm[ARGS].setup(vm.stack, names, [], 0, true);\n      args = vm[ARGS].capture();\n    }\n\n    let moduleName: string;\n    let compilable: CompilableProgram | null = definition.compilable;\n\n    if (compilable === null) {\n      assert(\n        managerHasCapability(\n          manager,\n          instance.capabilities,\n          InternalComponentCapabilities.dynamicLayout\n        ),\n        'BUG: No template was found for this component, and the component did not have the dynamic layout capability'\n      );\n\n      compilable = manager.getDynamicLayout(state, vm.runtime.resolver);\n\n      if (compilable !== null) {\n        moduleName = compilable.moduleName;\n      } else {\n        moduleName = '__default__.hbs';\n      }\n    } else {\n      moduleName = compilable.moduleName;\n    }\n\n    // For tearing down the debugRenderTree\n    vm.associateDestroyable(instance);\n\n    if (hasCustomDebugRenderTreeLifecycle(manager)) {\n      let nodes = manager.getDebugCustomRenderTree(\n        instance.definition.state,\n        instance.state,\n        args,\n        moduleName\n      );\n\n      nodes.forEach((node) => {\n        let { bucket } = node;\n        vm.env.debugRenderTree!.create(bucket, node);\n\n        registerDestructor(instance, () => {\n          vm.env.debugRenderTree?.willDestroy(bucket);\n        });\n\n        vm.updateWith(new DebugRenderTreeUpdateOpcode(bucket));\n      });\n    } else {\n      let name = definition.resolvedName ?? manager.getDebugName(definition.state);\n\n      vm.env.debugRenderTree.create(instance, {\n        type: 'component',\n        name,\n        args,\n        template: moduleName,\n        instance: valueForRef(selfRef),\n      });\n\n      registerDestructor(instance, () => {\n        vm.env.debugRenderTree?.willDestroy(instance);\n      });\n\n      vm.updateWith(new DebugRenderTreeUpdateOpcode(instance));\n    }\n  }\n\n  vm.stack.push(selfRef);\n});\n\nAPPEND_OPCODES.add(Op.GetComponentTagName, (vm, { op1: _state }) => {\n  let { definition, state } = check(vm.fetchValue(_state), CheckComponentInstance);\n  let { manager } = definition;\n\n  let tagName = (\n    manager as Recast<InternalComponentManager, WithDynamicTagName<unknown>>\n  ).getTagName(state);\n\n  // User provided value from JS, so we don't bother to encode\n  vm.stack.push(tagName);\n});\n\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(Op.GetComponentLayout, (vm, { op1: _state }) => {\n  let instance = check(vm.fetchValue(_state), CheckComponentInstance);\n\n  let { manager, definition } = instance;\n  let { stack } = vm;\n\n  let { compilable } = definition;\n\n  if (compilable === null) {\n    let { capabilities } = instance;\n\n    assert(\n      managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout),\n      'BUG: No template was found for this component, and the component did not have the dynamic layout capability'\n    );\n\n    compilable = manager.getDynamicLayout(instance.state, vm.runtime.resolver);\n\n    if (compilable === null) {\n      if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped)) {\n        compilable = unwrapTemplate(vm[CONSTANTS].defaultTemplate).asWrappedLayout();\n      } else {\n        compilable = unwrapTemplate(vm[CONSTANTS].defaultTemplate).asLayout();\n      }\n    }\n  }\n\n  let handle = compilable.compile(vm.context);\n\n  stack.push(compilable.symbolTable);\n  stack.push(handle);\n});\n\nAPPEND_OPCODES.add(Op.Main, (vm, { op1: register }) => {\n  let definition = check(vm.stack.pop(), CheckComponentDefinition);\n  let invocation = check(vm.stack.pop(), CheckInvocation);\n\n  let { manager, capabilities } = definition;\n\n  let state: PopulatedComponentInstance = {\n    definition,\n    manager,\n    capabilities,\n    state: null,\n    handle: invocation.handle,\n    table: invocation.symbolTable,\n    lookup: null,\n  };\n\n  vm.loadValue(register, state);\n});\n\nAPPEND_OPCODES.add(Op.PopulateLayout, (vm, { op1: _state }) => {\n  let { stack } = vm;\n\n  // In import.meta.env.DEV handles could be ErrHandle objects\n  let handle = check(stack.pop(), CheckHandle);\n  let table = check(stack.pop(), CheckProgramSymbolTable);\n\n  let state = check(vm.fetchValue(_state), CheckComponentInstance);\n\n  state.handle = handle;\n  state.table = table;\n});\n\nAPPEND_OPCODES.add(Op.VirtualRootScope, (vm, { op1: _state }) => {\n  let { table, manager, capabilities, state } = check(\n    vm.fetchValue(_state),\n    CheckFinishedComponentInstance\n  );\n\n  let owner;\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.hasSubOwner)) {\n    owner = manager.getOwner(state);\n    vm.loadValue($t1, null); // Clear the temp register\n  } else {\n    // Check the temp register to see if an owner was resolved from currying\n    owner = vm.fetchValue<Owner | null>($t1);\n\n    if (owner === null) {\n      // If an owner wasn't found, default to using the current owner. This\n      // will happen for normal dynamic component invocation,\n      // e.g. <SomeClassicEmberComponent/>\n      owner = vm.getOwner();\n    } else {\n      // Else the owner was found, so clear the temp register. This will happen\n      // if we are loading a curried component, e.g. <@someCurriedComponent/>\n      vm.loadValue($t1, null);\n    }\n  }\n\n  vm.pushRootScope(table.symbols.length + 1, owner);\n});\n\nAPPEND_OPCODES.add(Op.SetupForEval, (vm, { op1: _state }) => {\n  let state = check(vm.fetchValue(_state), CheckFinishedComponentInstance);\n\n  if (state.table.hasEval) {\n    let lookup = (state.lookup = dict<ScopeSlot>());\n    vm.scope().bindEvalScope(lookup);\n  }\n});\n\nAPPEND_OPCODES.add(Op.SetNamedVariables, (vm, { op1: _state }) => {\n  let state = check(vm.fetchValue(_state), CheckFinishedComponentInstance);\n  let scope = vm.scope();\n\n  let args = check(vm.stack.peek(), CheckArguments);\n  let callerNames = args.named.atNames;\n\n  for (let i = callerNames.length - 1; i >= 0; i--) {\n    let atName = unwrap(callerNames[i]);\n    let symbol = state.table.symbols.indexOf(atName);\n    let value = args.named.get(atName, true);\n\n    if (symbol !== -1) scope.bindSymbol(symbol + 1, value);\n    if (state.lookup) state.lookup[atName] = value;\n  }\n});\n\nfunction bindBlock(\n  symbolName: string,\n  blockName: string,\n  state: ComponentInstance,\n  blocks: BlockArgumentsImpl,\n  vm: InternalVM\n) {\n  let symbol = state.table.symbols.indexOf(symbolName);\n  let block = blocks.get(blockName);\n\n  if (symbol !== -1) vm.scope().bindBlock(symbol + 1, block);\n  if (state.lookup) state.lookup[symbolName] = block;\n}\n\nAPPEND_OPCODES.add(Op.SetBlocks, (vm, { op1: _state }) => {\n  let state = check(vm.fetchValue(_state), CheckFinishedComponentInstance);\n  let { blocks } = check(vm.stack.peek(), CheckArguments);\n\n  for (const [i] of enumerate(blocks.names)) {\n    bindBlock(unwrap(blocks.symbolNames[i]), unwrap(blocks.names[i]), state, blocks, vm);\n  }\n});\n\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(Op.InvokeComponentLayout, (vm, { op1: _state }) => {\n  let state = check(vm.fetchValue(_state), CheckFinishedComponentInstance);\n\n  vm.call(state.handle);\n});\n\nAPPEND_OPCODES.add(Op.DidRenderLayout, (vm, { op1: _state }) => {\n  let instance = check(vm.fetchValue(_state), CheckComponentInstance);\n  let { manager, state, capabilities } = instance;\n  let bounds = vm.elements().popBlock();\n\n  if (vm.env.debugRenderTree !== undefined) {\n    if (hasCustomDebugRenderTreeLifecycle(manager)) {\n      let nodes = manager.getDebugCustomRenderTree(instance.definition.state, state, EMPTY_ARGS);\n\n      nodes.reverse().forEach((node) => {\n        let { bucket } = node;\n\n        vm.env.debugRenderTree!.didRender(bucket, bounds);\n\n        vm.updateWith(new DebugRenderTreeDidRenderOpcode(bucket, bounds));\n      });\n    } else {\n      vm.env.debugRenderTree.didRender(instance, bounds);\n\n      vm.updateWith(new DebugRenderTreeDidRenderOpcode(instance, bounds));\n    }\n  }\n\n  if (managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance)) {\n    let mgr = check(manager, CheckInterface({ didRenderLayout: CheckFunction }));\n    mgr.didRenderLayout(state, bounds);\n\n    vm.env.didCreate(instance as ComponentInstanceWithCreate);\n    vm.updateWith(new DidUpdateLayoutOpcode(instance as ComponentInstanceWithCreate, bounds));\n  }\n});\n\nAPPEND_OPCODES.add(Op.CommitComponentTransaction, (vm) => {\n  vm.commitCacheGroup();\n});\n\nexport class UpdateComponentOpcode implements UpdatingOpcode {\n  constructor(\n    private component: ComponentInstanceState,\n    private manager: WithUpdateHook,\n    private dynamicScope: Nullable<DynamicScope>\n  ) {}\n\n  evaluate(_vm: UpdatingVM) {\n    let { component, manager, dynamicScope } = this;\n\n    manager.update(component, dynamicScope);\n  }\n}\n\nexport class DidUpdateLayoutOpcode implements UpdatingOpcode {\n  constructor(\n    private component: ComponentInstanceWithCreate,\n    private bounds: Bounds\n  ) {}\n\n  evaluate(vm: UpdatingVM) {\n    let { component, bounds } = this;\n    let { manager, state } = component;\n\n    manager.didUpdateLayout(state, bounds);\n\n    vm.env.didUpdate(component);\n  }\n}\n\nclass DebugRenderTreeUpdateOpcode implements UpdatingOpcode {\n  constructor(private bucket: object) {}\n\n  evaluate(vm: UpdatingVM) {\n    vm.env.debugRenderTree?.update(this.bucket);\n  }\n}\n\nclass DebugRenderTreeDidRenderOpcode implements UpdatingOpcode {\n  constructor(\n    private bucket: object,\n    private bounds: Bounds\n  ) {}\n\n  evaluate(vm: UpdatingVM) {\n    vm.env.debugRenderTree?.didRender(this.bucket, this.bounds);\n  }\n}\n","import type {\n  ComponentDefinition,\n  Nullable,\n  Owner,\n  ResolutionTimeConstants,\n  RuntimeResolver,\n} from '@glimmer/interfaces';\nimport { expect } from '@glimmer/util';\n\nexport function resolveComponent(\n  resolver: RuntimeResolver,\n  constants: ResolutionTimeConstants,\n  name: string,\n  owner: Owner | null\n): Nullable<ComponentDefinition> {\n  let definition = resolver.lookupComponent(\n    name,\n    expect(owner, 'BUG: expected owner when looking up component')\n  );\n\n  if (import.meta.env.DEV && !definition) {\n    throw new Error(\n      `Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`\n    );\n  }\n\n  return constants.resolvedComponent(definition!, name);\n}\n","import type { Reference } from '@glimmer/reference';\nimport { createComputeRef, valueForRef } from '@glimmer/reference';\n\nimport { normalizeStringValue } from '../dom/normalize';\n\nexport default function createClassListRef(list: Reference[]) {\n  return createComputeRef(() => {\n    let ret: string[] = [];\n\n    for (const ref of list) {\n      let value = normalizeStringValue(typeof ref === 'string' ? ref : valueForRef(ref));\n      if (value) ret.push(value);\n    }\n\n    return ret.length === 0 ? null : ret.join(' ');\n  });\n}\n","import type {\n  ArgumentError,\n  BlockArguments,\n  BlockSymbolTable,\n  BlockValue,\n  CapturedArguments,\n  CapturedBlockArguments,\n  CapturedNamedArguments,\n  CapturedPositionalArguments,\n  CompilableBlock,\n  Dict,\n  NamedArguments,\n  Nullable,\n  PositionalArguments,\n  Scope,\n  ScopeBlock,\n  VMArguments,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport type { Tag } from '@glimmer/validator';\nimport { check, CheckBlockSymbolTable, CheckHandle, CheckOption, CheckOr } from '@glimmer/debug';\nimport { createDebugAliasRef, UNDEFINED_REFERENCE, valueForRef } from '@glimmer/reference';\nimport { dict, EMPTY_STRING_ARRAY, emptyArray, enumerate, unwrap } from '@glimmer/util';\nimport { CONSTANT_TAG } from '@glimmer/validator';\nimport { $sp } from '@glimmer/vm';\n\nimport type { EvaluationStack } from './stack';\n\nimport { CheckCompilableBlock, CheckReference, CheckScope } from '../compiled/opcodes/-debug-strip';\nimport { REGISTERS } from '../symbols';\n\n/*\n  The calling convention is:\n\n  * 0-N block arguments at the bottom\n  * 0-N positional arguments next (left-to-right)\n  * 0-N named arguments next\n*/\n\nexport class VMArgumentsImpl implements VMArguments {\n  private stack: Nullable<EvaluationStack> = null;\n  public positional = new PositionalArgumentsImpl();\n  public named = new NamedArgumentsImpl();\n  public blocks = new BlockArgumentsImpl();\n\n  empty(stack: EvaluationStack): this {\n    let base = stack[REGISTERS][$sp] + 1;\n\n    this.named.empty(stack, base);\n    this.positional.empty(stack, base);\n    this.blocks.empty(stack, base);\n\n    return this;\n  }\n\n  setup(\n    stack: EvaluationStack,\n    names: readonly string[],\n    blockNames: readonly string[],\n    positionalCount: number,\n    atNames: boolean\n  ) {\n    this.stack = stack;\n\n    /*\n           | ... | blocks      | positional  | named |\n           | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |\n     index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |\n                   ^             ^             ^  ^\n                 bbase         pbase       nbase  sp\n    */\n\n    let named = this.named;\n    let namedCount = names.length;\n    let namedBase = stack[REGISTERS][$sp] - namedCount + 1;\n\n    named.setup(stack, namedBase, namedCount, names, atNames);\n\n    let positional = this.positional;\n    let positionalBase = namedBase - positionalCount;\n\n    positional.setup(stack, positionalBase, positionalCount);\n\n    let blocks = this.blocks;\n    let blocksCount = blockNames.length;\n    let blocksBase = positionalBase - blocksCount * 3;\n\n    blocks.setup(stack, blocksBase, blocksCount, blockNames);\n  }\n\n  get base(): number {\n    return this.blocks.base;\n  }\n\n  get length(): number {\n    return this.positional.length + this.named.length + this.blocks.length * 3;\n  }\n\n  at(pos: number): Reference {\n    return this.positional.at(pos);\n  }\n\n  realloc(offset: number) {\n    let { stack } = this;\n    if (offset > 0 && stack !== null) {\n      let { positional, named } = this;\n      let newBase = positional.base + offset;\n      let length = positional.length + named.length;\n\n      for (let i = length - 1; i >= 0; i--) {\n        stack.copy(i + positional.base, i + newBase);\n      }\n\n      positional.base += offset;\n      named.base += offset;\n      stack[REGISTERS][$sp] += offset;\n    }\n  }\n\n  capture(): CapturedArguments {\n    let positional = this.positional.length === 0 ? EMPTY_POSITIONAL : this.positional.capture();\n    let named = this.named.length === 0 ? EMPTY_NAMED : this.named.capture();\n\n    return { named, positional } as CapturedArguments;\n  }\n\n  clear(): void {\n    let { stack, length } = this;\n    if (length > 0 && stack !== null) stack.pop(length);\n  }\n}\n\nconst EMPTY_REFERENCES = emptyArray<Reference>();\n\nexport class PositionalArgumentsImpl implements PositionalArguments {\n  public base = 0;\n  public length = 0;\n\n  private stack: EvaluationStack = null as any;\n\n  private _references: Nullable<readonly Reference[]> = null;\n\n  empty(stack: EvaluationStack, base: number) {\n    this.stack = stack;\n    this.base = base;\n    this.length = 0;\n\n    this._references = EMPTY_REFERENCES;\n  }\n\n  setup(stack: EvaluationStack, base: number, length: number) {\n    this.stack = stack;\n    this.base = base;\n    this.length = length;\n\n    if (length === 0) {\n      this._references = EMPTY_REFERENCES;\n    } else {\n      this._references = null;\n    }\n  }\n\n  at(position: number): Reference {\n    let { base, length, stack } = this;\n\n    if (position < 0 || position >= length) {\n      return UNDEFINED_REFERENCE;\n    }\n\n    return check(stack.get(position, base), CheckReference);\n  }\n\n  capture(): CapturedPositionalArguments {\n    return this.references as CapturedPositionalArguments;\n  }\n\n  prepend(other: Reference[]) {\n    let additions = other.length;\n\n    if (additions > 0) {\n      let { base, length, stack } = this;\n\n      this.base = base = base - additions;\n      this.length = length + additions;\n\n      for (let i = 0; i < additions; i++) {\n        stack.set(other[i], i, base);\n      }\n\n      this._references = null;\n    }\n  }\n\n  private get references(): readonly Reference[] {\n    let references = this._references;\n\n    if (!references) {\n      let { stack, base, length } = this;\n      references = this._references = stack.slice<Reference>(base, base + length);\n    }\n\n    return references;\n  }\n}\n\nexport class NamedArgumentsImpl implements NamedArguments {\n  public base = 0;\n  public length = 0;\n\n  private declare stack: EvaluationStack;\n\n  private _references: Nullable<readonly Reference[]> = null;\n\n  private _names: Nullable<readonly string[]> = EMPTY_STRING_ARRAY;\n  private _atNames: Nullable<readonly string[]> = EMPTY_STRING_ARRAY;\n\n  empty(stack: EvaluationStack, base: number) {\n    this.stack = stack;\n    this.base = base;\n    this.length = 0;\n\n    this._references = EMPTY_REFERENCES;\n    this._names = EMPTY_STRING_ARRAY;\n    this._atNames = EMPTY_STRING_ARRAY;\n  }\n\n  setup(\n    stack: EvaluationStack,\n    base: number,\n    length: number,\n    names: readonly string[],\n    atNames: boolean\n  ) {\n    this.stack = stack;\n    this.base = base;\n    this.length = length;\n\n    if (length === 0) {\n      this._references = EMPTY_REFERENCES;\n      this._names = EMPTY_STRING_ARRAY;\n      this._atNames = EMPTY_STRING_ARRAY;\n    } else {\n      this._references = null;\n\n      if (atNames) {\n        this._names = null;\n        this._atNames = names;\n      } else {\n        this._names = names;\n        this._atNames = null;\n      }\n    }\n  }\n\n  get names(): readonly string[] {\n    let names = this._names;\n\n    if (!names) {\n      names = this._names = this._atNames!.map(this.toSyntheticName);\n    }\n\n    return names;\n  }\n\n  get atNames(): readonly string[] {\n    let atNames = this._atNames;\n\n    if (!atNames) {\n      atNames = this._atNames = this._names!.map(this.toAtName);\n    }\n\n    return atNames;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get(name: string, atNames = false): Reference {\n    let { base, stack } = this;\n\n    let names = atNames ? this.atNames : this.names;\n\n    let idx = names.indexOf(name);\n\n    if (idx === -1) {\n      return UNDEFINED_REFERENCE;\n    }\n\n    let ref = stack.get<Reference>(idx, base);\n\n    if (import.meta.env.DEV) {\n      return createDebugAliasRef!(atNames ? name : `@${name}`, ref);\n    } else {\n      return ref;\n    }\n  }\n\n  capture(): CapturedNamedArguments {\n    let { names, references } = this;\n    let map = dict<Reference>();\n\n    for (const [i, name] of enumerate(names)) {\n      if (import.meta.env.DEV) {\n        map[name] = createDebugAliasRef!(`@${name}`, unwrap(references[i]));\n      } else {\n        map[name] = unwrap(references[i]);\n      }\n    }\n\n    return map as CapturedNamedArguments;\n  }\n\n  merge(other: Record<string, Reference>) {\n    let keys = Object.keys(other);\n\n    if (keys.length > 0) {\n      let { names, length, stack } = this;\n      let newNames = names.slice();\n\n      for (const name of keys) {\n        let idx = newNames.indexOf(name);\n\n        if (idx === -1) {\n          length = newNames.push(name);\n          stack.push(other[name]);\n        }\n      }\n\n      this.length = length;\n      this._references = null;\n      this._names = newNames;\n      this._atNames = null;\n    }\n  }\n\n  private get references(): readonly Reference[] {\n    let references = this._references;\n\n    if (!references) {\n      let { base, length, stack } = this;\n      references = this._references = stack.slice<Reference>(base, base + length);\n    }\n\n    return references;\n  }\n\n  private toSyntheticName(this: void, name: string): string {\n    return name.slice(1);\n  }\n\n  private toAtName(this: void, name: string): string {\n    return `@${name}`;\n  }\n}\n\nfunction toSymbolName(name: string): string {\n  return `&${name}`;\n}\n\nconst EMPTY_BLOCK_VALUES = emptyArray<BlockValue>();\n\nexport class BlockArgumentsImpl implements BlockArguments {\n  private declare stack: EvaluationStack;\n  private internalValues: Nullable<readonly BlockValue[]> = null;\n  private _symbolNames: Nullable<readonly string[]> = null;\n\n  public internalTag: Nullable<Tag> = null;\n  public names: readonly string[] = EMPTY_STRING_ARRAY;\n\n  public length = 0;\n  public base = 0;\n\n  empty(stack: EvaluationStack, base: number) {\n    this.stack = stack;\n    this.names = EMPTY_STRING_ARRAY;\n    this.base = base;\n    this.length = 0;\n    this._symbolNames = null;\n\n    this.internalTag = CONSTANT_TAG;\n    this.internalValues = EMPTY_BLOCK_VALUES;\n  }\n\n  setup(stack: EvaluationStack, base: number, length: number, names: readonly string[]) {\n    this.stack = stack;\n    this.names = names;\n    this.base = base;\n    this.length = length;\n    this._symbolNames = null;\n\n    if (length === 0) {\n      this.internalTag = CONSTANT_TAG;\n      this.internalValues = EMPTY_BLOCK_VALUES;\n    } else {\n      this.internalTag = null;\n      this.internalValues = null;\n    }\n  }\n\n  get values(): readonly BlockValue[] {\n    let values = this.internalValues;\n\n    if (!values) {\n      let { base, length, stack } = this;\n      values = this.internalValues = stack.slice<BlockValue>(base, base + length * 3);\n    }\n\n    return values;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get(name: string): Nullable<ScopeBlock> {\n    let idx = this.names.indexOf(name);\n\n    if (idx === -1) {\n      return null;\n    }\n\n    let { base, stack } = this;\n\n    let table = check(stack.get(idx * 3, base), CheckOption(CheckBlockSymbolTable));\n    let scope = check(stack.get(idx * 3 + 1, base), CheckOption(CheckScope));\n    let handle = check(\n      stack.get(idx * 3 + 2, base),\n      CheckOption(CheckOr(CheckHandle, CheckCompilableBlock))\n    );\n\n    return handle === null ? null : ([handle, scope!, table!] as ScopeBlock);\n  }\n\n  capture(): CapturedBlockArguments {\n    return new CapturedBlockArgumentsImpl(this.names, this.values);\n  }\n\n  get symbolNames(): readonly string[] {\n    let symbolNames = this._symbolNames;\n\n    if (symbolNames === null) {\n      symbolNames = this._symbolNames = this.names.map(toSymbolName);\n    }\n\n    return symbolNames;\n  }\n}\n\nclass CapturedBlockArgumentsImpl implements CapturedBlockArguments {\n  public length: number;\n\n  constructor(\n    public names: readonly string[],\n    public values: readonly Nullable<BlockValue>[]\n  ) {\n    this.length = names.length;\n  }\n\n  has(name: string): boolean {\n    return this.names.indexOf(name) !== -1;\n  }\n\n  get(name: string): Nullable<ScopeBlock> {\n    let idx = this.names.indexOf(name);\n\n    if (idx === -1) return null;\n\n    return [\n      this.values[idx * 3 + 2] as CompilableBlock,\n      this.values[idx * 3 + 1] as Scope,\n      this.values[idx * 3] as BlockSymbolTable,\n    ];\n  }\n}\n\nexport function createCapturedArgs(named: Dict<Reference>, positional: Reference[]) {\n  return {\n    named,\n    positional,\n  } as CapturedArguments;\n}\n\nexport function reifyNamed(named: CapturedNamedArguments) {\n  let reified = dict();\n\n  for (const [key, value] of Object.entries(named)) {\n    reified[key] = valueForRef(value);\n  }\n\n  return reified;\n}\n\nexport function reifyPositional(positional: CapturedPositionalArguments) {\n  return positional.map(valueForRef);\n}\n\nexport function reifyArgs(args: CapturedArguments) {\n  return {\n    named: reifyNamed(args.named),\n    positional: reifyPositional(args.positional),\n  };\n}\n\nconst ARGUMENT_ERROR = Symbol('ARGUMENT_ERROR');\n\nexport function isArgumentError(arg: unknown): arg is ArgumentError {\n  return (\n    arg !== null &&\n    typeof arg === 'object' &&\n    (arg as { [ARGUMENT_ERROR]: boolean })[ARGUMENT_ERROR]\n  );\n}\n\nfunction ArgumentErrorImpl(error: any) {\n  return {\n    [ARGUMENT_ERROR]: true,\n    error,\n  };\n}\n\nexport function reifyNamedDebug(named: CapturedNamedArguments) {\n  let reified = dict();\n  for (const [key, value] of Object.entries(named)) {\n    try {\n      reified[key] = valueForRef(value);\n    } catch (e) {\n      reified[key] = ArgumentErrorImpl(e);\n    }\n  }\n\n  return reified;\n}\n\nexport function reifyPositionalDebug(positional: CapturedPositionalArguments) {\n  return positional.map((p) => {\n    try {\n      return valueForRef(p);\n    } catch (e) {\n      return ArgumentErrorImpl(e);\n    }\n  });\n}\n\nexport function reifyArgsDebug(args: CapturedArguments) {\n  let named = reifyNamedDebug(args.named);\n  let positional = reifyPositionalDebug(args.positional);\n  return {\n    named,\n    positional,\n  };\n}\n\nexport const EMPTY_NAMED = Object.freeze(Object.create(null)) as CapturedNamedArguments;\nexport const EMPTY_POSITIONAL = EMPTY_REFERENCES as CapturedPositionalArguments;\nexport const EMPTY_ARGS = createCapturedArgs(EMPTY_NAMED, EMPTY_POSITIONAL);\n","import type { Reference } from '@glimmer/reference';\nimport { createComputeRef, valueForRef } from '@glimmer/reference';\n\nexport function createConcatRef(partsRefs: Reference[]) {\n  return createComputeRef(() => {\n    const parts: string[] = [];\n\n    for (const ref of partsRefs) {\n      const value = valueForRef(ref);\n\n      if (value !== null && value !== undefined) {\n        parts.push(castToString(value));\n      }\n    }\n\n    if (parts.length > 0) {\n      return parts.join('');\n    }\n\n    return null;\n  });\n}\n\nfunction castToString(value: string | object) {\n  if (typeof value === 'string') {\n    return value;\n  } else if (typeof value.toString !== 'function') {\n    return '';\n  }\n\n  return String(value);\n}\n","import type {\n  CapturedPositionalArguments,\n  CurriedType,\n  Helper,\n  HelperDefinitionState,\n  Owner,\n  ScopeBlock,\n  VM as PublicVM,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport {\n  check,\n  CheckBlockSymbolTable,\n  CheckHandle,\n  CheckMaybe,\n  CheckOption,\n  CheckOr,\n} from '@glimmer/debug';\nimport { _hasDestroyableChildren, associateDestroyableChild, destroy } from '@glimmer/destroyable';\nimport { toBool } from '@glimmer/global-context';\nimport { getInternalHelperManager } from '@glimmer/manager';\nimport {\n  childRefFor,\n  createComputeRef,\n  FALSE_REFERENCE,\n  TRUE_REFERENCE,\n  UNDEFINED_REFERENCE,\n  valueForRef,\n} from '@glimmer/reference';\nimport { assert, assign, debugToString, decodeHandle, isObject } from '@glimmer/util';\nimport { $v0, CurriedTypes, Op } from '@glimmer/vm';\n\nimport { isCurriedType, resolveCurriedValue } from '../../curried-value';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport createCurryRef from '../../references/curry-value';\nimport { CONSTANTS } from '../../symbols';\nimport { reifyPositional } from '../../vm/arguments';\nimport { createConcatRef } from '../expressions/concat';\nimport {\n  CheckArguments,\n  CheckCapturedArguments,\n  CheckCompilableBlock,\n  CheckHelper,\n  CheckReference,\n  CheckScope,\n  CheckScopeBlock,\n  CheckUndefinedReference,\n} from './-debug-strip';\n\nexport type FunctionExpression<T> = (vm: PublicVM) => Reference<T>;\n\nAPPEND_OPCODES.add(Op.Curry, (vm, { op1: type, op2: _isStrict }) => {\n  let stack = vm.stack;\n\n  let definition = check(stack.pop(), CheckReference);\n  let capturedArgs = check(stack.pop(), CheckCapturedArguments);\n\n  let owner = vm.getOwner();\n  let resolver = vm.runtime.resolver;\n\n  let isStrict = false;\n\n  if (import.meta.env.DEV) {\n    // strict check only happens in import.meta.env.DEV builds, no reason to load it otherwise\n    isStrict = vm[CONSTANTS].getValue<boolean>(decodeHandle(_isStrict));\n  }\n\n  vm.loadValue(\n    $v0,\n    createCurryRef(type as CurriedType, definition, owner, capturedArgs, resolver, isStrict)\n  );\n});\n\nAPPEND_OPCODES.add(Op.DynamicHelper, (vm) => {\n  let stack = vm.stack;\n  let ref = check(stack.pop(), CheckReference);\n  let args = check(stack.pop(), CheckArguments).capture();\n\n  let helperRef: Reference;\n  let initialOwner: Owner = vm.getOwner();\n\n  let helperInstanceRef = createComputeRef(() => {\n    if (helperRef !== undefined) {\n      destroy(helperRef);\n    }\n\n    let definition = valueForRef(ref);\n\n    if (isCurriedType(definition, CurriedTypes.Helper)) {\n      let { definition: resolvedDef, owner, positional, named } = resolveCurriedValue(definition);\n\n      let helper = resolveHelper(resolvedDef, ref);\n\n      if (named !== undefined) {\n        args.named = assign({}, ...named, args.named);\n      }\n\n      if (positional !== undefined) {\n        args.positional = positional.concat(args.positional) as CapturedPositionalArguments;\n      }\n\n      helperRef = helper(args, owner);\n\n      associateDestroyableChild(helperInstanceRef, helperRef);\n    } else if (isObject(definition)) {\n      let helper = resolveHelper(definition, ref);\n      helperRef = helper(args, initialOwner);\n\n      if (_hasDestroyableChildren(helperRef)) {\n        associateDestroyableChild(helperInstanceRef, helperRef);\n      }\n    } else {\n      helperRef = UNDEFINED_REFERENCE;\n    }\n  });\n\n  let helperValueRef = createComputeRef(() => {\n    valueForRef(helperInstanceRef);\n    return valueForRef(helperRef);\n  });\n\n  vm.associateDestroyable(helperInstanceRef);\n  vm.loadValue($v0, helperValueRef);\n});\n\nfunction resolveHelper(definition: HelperDefinitionState, ref: Reference): Helper {\n  let managerOrHelper = getInternalHelperManager(definition, true);\n  let helper;\n  if (managerOrHelper === null) {\n    helper = null;\n  } else {\n    helper =\n      typeof managerOrHelper === 'function'\n        ? managerOrHelper\n        : managerOrHelper.getHelper(definition);\n    assert(managerOrHelper, 'BUG: expected manager or helper');\n  }\n\n  if (import.meta.env.DEV && helper === null) {\n    throw new Error(\n      `Expected a dynamic helper definition, but received an object or function that did not have a helper manager associated with it. The dynamic invocation was \\`{{${\n        ref.debugLabel\n      }}}\\` or \\`(${ref.debugLabel})\\`, and the incorrect definition is the value at the path \\`${\n        ref.debugLabel\n      }\\`, which was: ${debugToString!(definition)}`\n    );\n  }\n\n  return helper!;\n}\n\nAPPEND_OPCODES.add(Op.Helper, (vm, { op1: handle }) => {\n  let stack = vm.stack;\n  let helper = check(vm[CONSTANTS].getValue(handle), CheckHelper);\n  let args = check(stack.pop(), CheckArguments);\n  let value = helper(args.capture(), vm.getOwner(), vm.dynamicScope());\n\n  if (_hasDestroyableChildren(value)) {\n    vm.associateDestroyable(value);\n  }\n\n  vm.loadValue($v0, value);\n});\n\nAPPEND_OPCODES.add(Op.GetVariable, (vm, { op1: symbol }) => {\n  let expr = vm.referenceForSymbol(symbol);\n\n  vm.stack.push(expr);\n});\n\nAPPEND_OPCODES.add(Op.SetVariable, (vm, { op1: symbol }) => {\n  let expr = check(vm.stack.pop(), CheckReference);\n  vm.scope().bindSymbol(symbol, expr);\n});\n\nAPPEND_OPCODES.add(Op.SetBlock, (vm, { op1: symbol }) => {\n  let handle = check(vm.stack.pop(), CheckCompilableBlock);\n  let scope = check(vm.stack.pop(), CheckScope);\n  let table = check(vm.stack.pop(), CheckBlockSymbolTable);\n\n  vm.scope().bindBlock(symbol, [handle, scope, table]);\n});\n\nAPPEND_OPCODES.add(Op.ResolveMaybeLocal, (vm, { op1: _name }) => {\n  let name = vm[CONSTANTS].getValue<string>(_name);\n  let locals = vm.scope().getPartialMap()!;\n\n  let ref = locals[name];\n  if (ref === undefined) {\n    ref = childRefFor(vm.getSelf(), name);\n  }\n\n  vm.stack.push(ref);\n});\n\nAPPEND_OPCODES.add(Op.RootScope, (vm, { op1: symbols }) => {\n  vm.pushRootScope(symbols, vm.getOwner());\n});\n\nAPPEND_OPCODES.add(Op.GetProperty, (vm, { op1: _key }) => {\n  let key = vm[CONSTANTS].getValue<string>(_key);\n  let expr = check(vm.stack.pop(), CheckReference);\n  vm.stack.push(childRefFor(expr, key));\n});\n\nAPPEND_OPCODES.add(Op.GetBlock, (vm, { op1: _block }) => {\n  let { stack } = vm;\n  let block = vm.scope().getBlock(_block);\n\n  stack.push(block);\n});\n\nAPPEND_OPCODES.add(Op.SpreadBlock, (vm) => {\n  let { stack } = vm;\n  let block = check(stack.pop(), CheckOption(CheckOr(CheckScopeBlock, CheckUndefinedReference)));\n\n  if (block && !isUndefinedReference(block)) {\n    let [handleOrCompilable, scope, table] = block;\n\n    stack.push(table);\n    stack.push(scope);\n    stack.push(handleOrCompilable);\n  } else {\n    stack.push(null);\n    stack.push(null);\n    stack.push(null);\n  }\n});\n\nfunction isUndefinedReference(input: ScopeBlock | Reference): input is Reference {\n  assert(\n    Array.isArray(input) || input === UNDEFINED_REFERENCE,\n    'a reference other than UNDEFINED_REFERENCE is illegal here'\n  );\n  return input === UNDEFINED_REFERENCE;\n}\n\nAPPEND_OPCODES.add(Op.HasBlock, (vm) => {\n  let { stack } = vm;\n  let block = check(stack.pop(), CheckOption(CheckOr(CheckScopeBlock, CheckUndefinedReference)));\n\n  if (block && !isUndefinedReference(block)) {\n    stack.push(TRUE_REFERENCE);\n  } else {\n    stack.push(FALSE_REFERENCE);\n  }\n});\n\nAPPEND_OPCODES.add(Op.HasBlockParams, (vm) => {\n  // FIXME(mmun): should only need to push the symbol table\n  let block = vm.stack.pop();\n  let scope = vm.stack.pop();\n\n  check(block, CheckMaybe(CheckOr(CheckHandle, CheckCompilableBlock)));\n  check(scope, CheckMaybe(CheckScope));\n  let table = check(vm.stack.pop(), CheckMaybe(CheckBlockSymbolTable));\n\n  let hasBlockParams = table && table.parameters.length;\n  vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);\n});\n\nAPPEND_OPCODES.add(Op.Concat, (vm, { op1: count }) => {\n  let out: Array<Reference<unknown>> = new Array(count);\n\n  for (let i = count; i > 0; i--) {\n    let offset = i - 1;\n    out[offset] = check(vm.stack.pop(), CheckReference);\n  }\n\n  vm.stack.push(createConcatRef(out));\n});\n\nAPPEND_OPCODES.add(Op.IfInline, (vm) => {\n  let condition = check(vm.stack.pop(), CheckReference);\n  let truthy = check(vm.stack.pop(), CheckReference);\n  let falsy = check(vm.stack.pop(), CheckReference);\n\n  vm.stack.push(\n    createComputeRef(() => {\n      if (toBool(valueForRef(condition)) === true) {\n        return valueForRef(truthy);\n      } else {\n        return valueForRef(falsy);\n      }\n    })\n  );\n});\n\nAPPEND_OPCODES.add(Op.Not, (vm) => {\n  let ref = check(vm.stack.pop(), CheckReference);\n\n  vm.stack.push(\n    createComputeRef(() => {\n      return !toBool(valueForRef(ref));\n    })\n  );\n});\n\nAPPEND_OPCODES.add(Op.GetDynamicVar, (vm) => {\n  let scope = vm.dynamicScope();\n  let stack = vm.stack;\n  let nameRef = check(stack.pop(), CheckReference);\n\n  stack.push(\n    createComputeRef(() => {\n      let name = String(valueForRef(nameRef));\n      return valueForRef(scope.get(name));\n    })\n  );\n});\n\nAPPEND_OPCODES.add(Op.Log, (vm) => {\n  let { positional } = check(vm.stack.pop(), CheckArguments).capture();\n\n  vm.loadValue(\n    $v0,\n    createComputeRef(() => {\n      // eslint-disable-next-line no-console\n      console.log(...reifyPositional(positional));\n    })\n  );\n});\n","import type {\n  CapturedArguments,\n  CurriedType,\n  Dict,\n  Maybe,\n  Nullable,\n  Owner,\n  RuntimeResolver,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { createComputeRef, valueForRef } from '@glimmer/reference';\nimport { expect, isObject } from '@glimmer/util';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport { curry, isCurriedType } from '../curried-value';\n\nexport default function createCurryRef(\n  type: CurriedType,\n  inner: Reference,\n  owner: Owner,\n  args: Nullable<CapturedArguments>,\n  resolver: RuntimeResolver,\n  isStrict: boolean\n) {\n  let lastValue: Maybe<Dict> | string, curriedDefinition: object | string | null;\n\n  return createComputeRef(() => {\n    let value = valueForRef(inner) as Maybe<Dict> | string;\n\n    if (value === lastValue) {\n      return curriedDefinition;\n    }\n\n    if (isCurriedType(value, type)) {\n      curriedDefinition = args ? curry(type, value, owner, args) : args;\n    } else if (type === CurriedTypes.Component && typeof value === 'string' && value) {\n      // Only components should enter this path, as helpers and modifiers do not\n      // support string based resolution\n\n      if (import.meta.env.DEV) {\n        if (isStrict) {\n          throw new Error(\n            `Attempted to resolve a dynamic component with a string definition, \\`${value}\\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`\n          );\n        }\n\n        let resolvedDefinition = expect(\n          resolver,\n          'BUG: expected resolver for curried component definitions'\n        ).lookupComponent(value, owner);\n\n        if (!resolvedDefinition) {\n          throw new Error(\n            `Attempted to resolve \\`${value}\\`, which was expected to be a component, but nothing was found.`\n          );\n        }\n      }\n\n      curriedDefinition = curry(type, value, owner, args);\n    } else if (isObject(value)) {\n      curriedDefinition = curry(type, value, owner, args);\n    } else {\n      curriedDefinition = null;\n    }\n\n    lastValue = value;\n\n    return curriedDefinition;\n  });\n}\n","import type { SimpleText, UpdatingOpcode } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { valueForRef } from '@glimmer/reference';\n\nimport { isEmpty, isString } from '../../dom/normalize';\n\nexport default class DynamicTextContent implements UpdatingOpcode {\n  constructor(\n    public node: SimpleText,\n    private reference: Reference<unknown>,\n    private lastValue: string\n  ) {}\n\n  evaluate() {\n    let value = valueForRef(this.reference);\n\n    let { lastValue } = this;\n\n    if (value === lastValue) return;\n\n    let normalized: string;\n\n    if (isEmpty(value)) {\n      normalized = '';\n    } else if (isString(value)) {\n      normalized = value;\n    } else {\n      normalized = String(value);\n    }\n\n    if (normalized !== lastValue) {\n      let textNode = this.node;\n      textNode.nodeValue = this.lastValue = normalized;\n    }\n  }\n}\n","import {\n  check,\n  CheckDocumentFragment,\n  CheckNode,\n  CheckSafeString,\n  CheckString,\n} from '@glimmer/debug';\nimport { hasInternalComponentManager, hasInternalHelperManager } from '@glimmer/manager';\nimport { isConstRef, valueForRef } from '@glimmer/reference';\nimport { isObject } from '@glimmer/util';\nimport { ContentType, CurriedType, Op } from '@glimmer/vm';\n\nimport { isCurriedType } from '../../curried-value';\nimport { isEmpty, isFragment, isNode, isSafeString, shouldCoerce } from '../../dom/normalize';\nimport { APPEND_OPCODES } from '../../opcodes';\nimport DynamicTextContent from '../../vm/content/text';\nimport { CheckReference } from './-debug-strip';\nimport { AssertFilter } from './vm';\n\nfunction toContentType(value: unknown) {\n  if (shouldCoerce(value)) {\n    return ContentType.String;\n  } else if (\n    isCurriedType(value, CurriedType.Component) ||\n    hasInternalComponentManager(value as object)\n  ) {\n    return ContentType.Component;\n  } else if (\n    isCurriedType(value, CurriedType.Helper) ||\n    hasInternalHelperManager(value as object)\n  ) {\n    return ContentType.Helper;\n  } else if (isSafeString(value)) {\n    return ContentType.SafeString;\n  } else if (isFragment(value)) {\n    return ContentType.Fragment;\n  } else if (isNode(value)) {\n    return ContentType.Node;\n  } else {\n    return ContentType.String;\n  }\n}\n\nfunction toDynamicContentType(value: unknown) {\n  if (!isObject(value)) {\n    return ContentType.String;\n  }\n\n  if (isCurriedType(value, CurriedType.Component) || hasInternalComponentManager(value)) {\n    return ContentType.Component;\n  } else {\n    if (\n      import.meta.env.DEV &&\n      !isCurriedType(value, CurriedType.Helper) &&\n      !hasInternalHelperManager(value)\n    ) {\n      throw new Error(\n        `Attempted use a dynamic value as a component or helper, but that value did not have an associated component or helper manager. The value was: ${value}`\n      );\n    }\n\n    return ContentType.Helper;\n  }\n}\n\nAPPEND_OPCODES.add(Op.ContentType, (vm) => {\n  let reference = check(vm.stack.peek(), CheckReference);\n\n  vm.stack.push(toContentType(valueForRef(reference)));\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new AssertFilter(reference, toContentType));\n  }\n});\n\nAPPEND_OPCODES.add(Op.DynamicContentType, (vm) => {\n  let reference = check(vm.stack.peek(), CheckReference);\n\n  vm.stack.push(toDynamicContentType(valueForRef(reference)));\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new AssertFilter(reference, toDynamicContentType));\n  }\n});\n\nAPPEND_OPCODES.add(Op.AppendHTML, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let rawValue = valueForRef(reference);\n  let value = isEmpty(rawValue) ? '' : String(rawValue);\n\n  vm.elements().appendDynamicHTML(value);\n});\n\nAPPEND_OPCODES.add(Op.AppendSafeHTML, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let rawValue = check(valueForRef(reference), CheckSafeString).toHTML();\n  let value = isEmpty(rawValue) ? '' : check(rawValue, CheckString);\n\n  vm.elements().appendDynamicHTML(value);\n});\n\nAPPEND_OPCODES.add(Op.AppendText, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let rawValue = valueForRef(reference);\n  let value = isEmpty(rawValue) ? '' : String(rawValue);\n\n  let node = vm.elements().appendDynamicText(value);\n\n  if (!isConstRef(reference)) {\n    vm.updateWith(new DynamicTextContent(node, reference, value));\n  }\n});\n\nAPPEND_OPCODES.add(Op.AppendDocumentFragment, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let value = check(valueForRef(reference), CheckDocumentFragment);\n\n  vm.elements().appendDynamicFragment(value);\n});\n\nAPPEND_OPCODES.add(Op.AppendNode, (vm) => {\n  let reference = check(vm.stack.pop(), CheckReference);\n\n  let value = check(valueForRef(reference), CheckNode);\n\n  vm.elements().appendDynamicNode(value);\n});\n","import type { Scope } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { childRefFor, valueForRef } from '@glimmer/reference';\nimport { decodeHandle, dict, unwrap } from '@glimmer/util';\nimport { Op } from '@glimmer/vm';\n\nimport { APPEND_OPCODES } from '../../opcodes';\nimport { CONSTANTS } from '../../symbols';\n\nexport type DebugGet = (path: string) => unknown;\n\nexport type DebugCallback = (context: unknown, get: DebugGet) => void;\n\nfunction debugCallback(context: unknown, get: DebugGet): void {\n  // eslint-disable-next-line no-console\n  console.info('Use `context`, and `get(<path>)` to debug this template.');\n\n  // for example...\n  context === get('this');\n\n  // eslint-disable-next-line no-debugger\n  debugger;\n}\n\nlet callback = debugCallback;\n\n// For testing purposes\nexport function setDebuggerCallback(cb: DebugCallback) {\n  callback = cb;\n}\n\nexport function resetDebuggerCallback() {\n  callback = debugCallback;\n}\n\nclass ScopeInspector {\n  private locals = dict<Reference>();\n\n  constructor(\n    private scope: Scope,\n    symbols: string[],\n    debugInfo: number[]\n  ) {\n    for (const slot of debugInfo) {\n      let name = unwrap(symbols[slot - 1]);\n      let ref = scope.getSymbol(slot);\n      this.locals[name] = ref;\n    }\n  }\n\n  get(path: string): Reference {\n    let { scope, locals } = this;\n    let parts = path.split('.');\n    let [head, ...tail] = path.split('.') as [string, ...string[]];\n\n    let evalScope = scope.getEvalScope()!;\n    let ref: Reference;\n\n    if (head === 'this') {\n      ref = scope.getSelf();\n    } else if (locals[head]) {\n      ref = unwrap(locals[head]);\n    } else if (head.indexOf('@') === 0 && evalScope[head]) {\n      ref = evalScope[head] as Reference;\n    } else {\n      ref = this.scope.getSelf();\n      tail = parts;\n    }\n\n    return tail.reduce((r, part) => childRefFor(r, part), ref);\n  }\n}\n\nAPPEND_OPCODES.add(Op.Debugger, (vm, { op1: _symbols, op2: _debugInfo }) => {\n  let symbols = vm[CONSTANTS].getArray<string>(_symbols);\n  let debugInfo = vm[CONSTANTS].getArray<number>(decodeHandle(_debugInfo));\n  let inspector = new ScopeInspector(vm.scope(), symbols, debugInfo);\n  callback(valueForRef(vm.getSelf()), (path) => valueForRef(inspector.get(path)));\n});\n","import { check } from '@glimmer/debug';\nimport { createIteratorRef, valueForRef } from '@glimmer/reference';\nimport { Op } from '@glimmer/vm';\n\nimport { APPEND_OPCODES } from '../../opcodes';\nimport { CheckIterator, CheckReference } from './-debug-strip';\nimport { AssertFilter } from './vm';\n\nAPPEND_OPCODES.add(Op.EnterList, (vm, { op1: relativeStart, op2: elseTarget }) => {\n  let stack = vm.stack;\n  let listRef = check(stack.pop(), CheckReference);\n  let keyRef = check(stack.pop(), CheckReference);\n\n  let keyValue = valueForRef(keyRef);\n  let key = keyValue === null ? '@identity' : String(keyValue);\n\n  let iteratorRef = createIteratorRef(listRef, key);\n  let iterator = valueForRef(iteratorRef);\n\n  vm.updateWith(new AssertFilter(iteratorRef, (iterator) => iterator.isEmpty()));\n\n  if (iterator.isEmpty() === true) {\n    // TODO: Fix this offset, should be accurate\n    vm.goto(elseTarget + 1);\n  } else {\n    vm.enterList(iteratorRef, relativeStart);\n    vm.stack.push(iterator);\n  }\n});\n\nAPPEND_OPCODES.add(Op.ExitList, (vm) => {\n  vm.exitList();\n});\n\nAPPEND_OPCODES.add(Op.Iterate, (vm, { op1: breaks }) => {\n  let stack = vm.stack;\n  let iterator = check(stack.peek(), CheckIterator);\n  let item = iterator.next();\n\n  if (item !== null) {\n    vm.registerItem(vm.enterItem(item));\n  } else {\n    vm.goto(breaks);\n  }\n});\n","import type { InternalComponentCapabilities, InternalComponentManager } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { setInternalComponentManager } from '@glimmer/manager';\nimport { NULL_REFERENCE } from '@glimmer/reference';\n\nconst CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  createCaller: false,\n  dynamicScope: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport class TemplateOnlyComponentManager implements InternalComponentManager {\n  getCapabilities(): InternalComponentCapabilities {\n    return CAPABILITIES;\n  }\n\n  getDebugName({ name }: TemplateOnlyComponentDefinition): string {\n    return name;\n  }\n\n  getSelf(): Reference {\n    return NULL_REFERENCE;\n  }\n\n  getDestroyable(): null {\n    return null;\n  }\n}\n\nexport const TEMPLATE_ONLY_COMPONENT_MANAGER = new TemplateOnlyComponentManager();\n\n// This is only exported for types, don't use this class directly\nexport class TemplateOnlyComponentDefinition {\n  constructor(\n    public moduleName = '@glimmer/component/template-only',\n    public name = '(unknown template-only component)'\n  ) {}\n\n  toString() {\n    return this.moduleName;\n  }\n}\n\nsetInternalComponentManager(\n  TEMPLATE_ONLY_COMPONENT_MANAGER,\n  TemplateOnlyComponentDefinition.prototype\n);\n\n/**\n  This utility function is used to declare a given component has no backing class. When the rendering engine detects this it\n  is able to perform a number of optimizations. Templates that are associated with `templateOnly()` will be rendered _as is_\n  without adding a wrapping `<div>` (or any of the other element customization behaviors of [@ember/component](/ember/release/classes/Component)).\n  Specifically, this means that the template will be rendered as \"outer HTML\".\n\n  In general, this method will be used by build time tooling and would not be directly written in an application. However,\n  at times it may be useful to use directly to leverage the \"outer HTML\" semantics mentioned above. For example, if an addon would like\n  to use these semantics for its templates but cannot be certain it will only be consumed by applications that have enabled the\n  `template-only-glimmer-components` optional feature.\n\n  @example\n\n  ```js\n  import { templateOnlyComponent } from '@glimmer/runtime';\n\n  export default templateOnlyComponent();\n  ```\n\n  @public\n  @method templateOnly\n  @param {String} moduleName the module name that the template only component represents, this will be used for debugging purposes\n  @category EMBER_GLIMMER_SET_COMPONENT_TEMPLATE\n*/\n\nexport function templateOnlyComponent(\n  moduleName?: string,\n  name?: string\n): TemplateOnlyComponentDefinition {\n  return new TemplateOnlyComponentDefinition(moduleName, name);\n}\n","import type {\n  Bounds,\n  Dict,\n  Nullable,\n  SimpleComment,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n  SimpleText,\n} from '@glimmer/interfaces';\nimport { expect, INSERT_BEFORE_BEGIN, INSERT_BEFORE_END, NS_SVG } from '@glimmer/util';\n\nimport { ConcreteBounds } from '../bounds';\n\n// http://www.w3.org/TR/html/syntax.html#html-integration-point\nconst SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };\n\n// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes\n// TODO: Adjust SVG attributes\n\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\n// TODO: Adjust SVG elements\n\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\nexport const BLACKLIST_TABLE = Object.create(null);\n\nexport class DOMOperations {\n  protected declare uselessElement: SimpleElement; // Set by this.setupUselessElement() in constructor\n\n  constructor(protected document: SimpleDocument) {\n    this.setupUselessElement();\n  }\n\n  // split into separate method so that NodeDOMTreeConstruction\n  // can override it.\n  protected setupUselessElement() {\n    this.uselessElement = this.document.createElement('div');\n  }\n\n  createElement(tag: string, context?: SimpleElement): SimpleElement {\n    let isElementInSVGNamespace: boolean, isHTMLIntegrationPoint: boolean;\n\n    if (context) {\n      isElementInSVGNamespace = context.namespaceURI === NS_SVG || tag === 'svg';\n      isHTMLIntegrationPoint = !!(SVG_INTEGRATION_POINTS as Dict<number>)[context.tagName];\n    } else {\n      isElementInSVGNamespace = tag === 'svg';\n      isHTMLIntegrationPoint = false;\n    }\n\n    if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {\n      // FIXME: This does not properly handle <font> with color, face, or\n      // size attributes, which is also disallowed by the spec. We should fix\n      // this.\n      if (BLACKLIST_TABLE[tag]) {\n        throw new Error(`Cannot create a ${tag} inside an SVG context`);\n      }\n\n      return this.document.createElementNS(NS_SVG, tag);\n    } else {\n      return this.document.createElement(tag);\n    }\n  }\n\n  insertBefore(parent: SimpleElement, node: SimpleNode, reference: Nullable<SimpleNode>) {\n    parent.insertBefore(node, reference);\n  }\n\n  insertHTMLBefore(parent: SimpleElement, nextSibling: Nullable<SimpleNode>, html: string): Bounds {\n    if (html === '') {\n      const comment = this.createComment('');\n      parent.insertBefore(comment, nextSibling);\n      return new ConcreteBounds(parent, comment, comment);\n    }\n\n    const prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n    let last: SimpleNode;\n\n    if (nextSibling === null) {\n      parent.insertAdjacentHTML(INSERT_BEFORE_END, html);\n      last = expect(parent.lastChild, 'bug in insertAdjacentHTML?');\n    } else if (nextSibling instanceof HTMLElement) {\n      nextSibling.insertAdjacentHTML('beforebegin', html);\n      last = expect(nextSibling.previousSibling, 'bug in insertAdjacentHTML?');\n    } else {\n      // Non-element nodes do not support insertAdjacentHTML, so add an\n      // element and call it on that element. Then remove the element.\n      //\n      // This also protects Edge, IE and Firefox w/o the inspector open\n      // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts\n      const { uselessElement } = this;\n\n      parent.insertBefore(uselessElement, nextSibling);\n      uselessElement.insertAdjacentHTML(INSERT_BEFORE_BEGIN, html);\n      last = expect(uselessElement.previousSibling, 'bug in insertAdjacentHTML?');\n      parent.removeChild(uselessElement);\n    }\n\n    const first = expect(prev ? prev.nextSibling : parent.firstChild, 'bug in insertAdjacentHTML?');\n    return new ConcreteBounds(parent, first, last);\n  }\n\n  createTextNode(text: string): SimpleText {\n    return this.document.createTextNode(text);\n  }\n\n  createComment(data: string): SimpleComment {\n    return this.document.createComment(data);\n  }\n}\n\nexport function moveNodesBefore(\n  source: SimpleNode,\n  target: SimpleElement,\n  nextSibling: Nullable<SimpleNode>\n): Bounds {\n  const first = expect(source.firstChild, 'source is empty');\n  let last: SimpleNode = first;\n  let current: Nullable<SimpleNode> = first;\n\n  while (current) {\n    const next: Nullable<SimpleNode> = current.nextSibling;\n\n    target.insertBefore(current, nextSibling);\n\n    last = current;\n    current = next;\n  }\n\n  return new ConcreteBounds(target, first, last);\n}\n","import type {\n  Bounds,\n  Nullable,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport {\n  assert,\n  castToBrowser,\n  clearElement,\n  INSERT_AFTER_BEGIN,\n  INSERT_BEFORE_END,\n  NS_SVG,\n  unwrap,\n} from '@glimmer/util';\n\nimport type { DOMOperations } from '../dom/operations';\n\nimport { moveNodesBefore } from '../dom/operations';\n\nexport enum InsertPosition {\n  beforebegin = 'beforebegin',\n  afterbegin = 'afterbegin',\n  beforeend = 'beforeend',\n  afterend = 'afterend',\n}\n\n// Patch:    insertAdjacentHTML on SVG Fix\n// Browsers: Safari, IE, Edge, Firefox ~33-34\n// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is\n//           present but throws an exception on IE and Edge. Old versions of\n//           Firefox create nodes in the incorrect namespace.\n// Fix:      Since IE and Edge silently fail to create SVG nodes using\n//           innerHTML, and because Firefox may create nodes in the incorrect\n//           namespace using innerHTML on SVG elements, an HTML-string wrapping\n//           approach is used. A pre/post SVG tag is added to the string, then\n//           that whole string is added to a div. The created nodes are plucked\n//           out and applied to the target location on DOM.\nexport function applySVGInnerHTMLFix(\n  document: Nullable<SimpleDocument>,\n  DOMClass: typeof DOMOperations,\n  svgNamespace: typeof NS_SVG\n): typeof DOMOperations {\n  if (!document) return DOMClass;\n\n  if (!shouldApplyFix(document, svgNamespace)) {\n    return DOMClass;\n  }\n\n  const div = document.createElement('div');\n\n  return class DOMChangesWithSVGInnerHTMLFix extends DOMClass {\n    override insertHTMLBefore(\n      parent: SimpleElement,\n      nextSibling: Nullable<SimpleNode>,\n      html: string\n    ): Bounds {\n      if (html === '') {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      if (parent.namespaceURI !== svgNamespace) {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      return fixSVG(parent, div, html, nextSibling);\n    }\n  };\n}\n\nfunction fixSVG(\n  parent: SimpleElement,\n  div: SimpleElement,\n  html: string,\n  reference: Nullable<SimpleNode>\n): Bounds {\n  assert(html !== '', 'html cannot be empty');\n\n  let source: SimpleNode;\n\n  // This is important, because descendants of the <foreignObject> integration\n  // point are parsed in the HTML namespace\n  if (parent.tagName.toUpperCase() === 'FOREIGNOBJECT') {\n    // IE, Edge: also do not correctly support using `innerHTML` on SVG\n    // namespaced elements. So here a wrapper is used.\n    const wrappedHtml = '<svg><foreignObject>' + html + '</foreignObject></svg>';\n\n    clearElement(div);\n    div.insertAdjacentHTML(INSERT_AFTER_BEGIN, wrappedHtml);\n\n    source = div.firstChild!.firstChild!;\n  } else {\n    // IE, Edge: also do not correctly support using `innerHTML` on SVG\n    // namespaced elements. So here a wrapper is used.\n    const wrappedHtml = '<svg>' + html + '</svg>';\n\n    clearElement(div);\n    div.insertAdjacentHTML(INSERT_AFTER_BEGIN, wrappedHtml);\n\n    source = div.firstChild!;\n  }\n\n  return moveNodesBefore(source, parent, reference);\n}\n\nfunction shouldApplyFix(document: SimpleDocument, svgNamespace: typeof NS_SVG) {\n  const svg = document.createElementNS(svgNamespace, 'svg');\n\n  try {\n    svg.insertAdjacentHTML(INSERT_BEFORE_END, '<circle></circle>');\n  } catch (e) {\n    // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG\n    // Safari: Will throw, insertAdjacentHTML is not present on SVG\n  } finally {\n    // FF: Old versions will create a node in the wrong namespace\n    if (\n      svg.childNodes.length === 1 &&\n      castToBrowser(unwrap(svg.firstChild), 'SVG').namespaceURI === NS_SVG\n    ) {\n      // The test worked as expected, no fix required\n      // eslint-disable-next-line no-unsafe-finally\n      return false;\n    }\n\n    // eslint-disable-next-line no-unsafe-finally\n    return true;\n  }\n}\n","import type {\n  Bounds,\n  Nullable,\n  SimpleComment,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport { INSERT_BEFORE_END } from '@glimmer/util';\n\nimport type { DOMOperations } from '../dom/operations';\n\n// Patch:    Adjacent text node merging fix\n// Browsers: IE, Edge, Firefox w/o inspector open\n// Reason:   These browsers will merge adjacent text nodes. For example given\n//           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers\n//           with proper behavior will populate div.childNodes with two items.\n//           These browsers will populate it with one merged node instead.\n// Fix:      Add these nodes to a wrapper element, then iterate the childNodes\n//           of that wrapper and move the nodes to their target location. Note\n//           that potential SVG bugs will have been handled before this fix.\n//           Note that this fix must only apply to the previous text node, as\n//           the base implementation of `insertHTMLBefore` already handles\n//           following text nodes correctly.\nexport function applyTextNodeMergingFix(\n  document: Nullable<SimpleDocument>,\n  DOMClass: typeof DOMOperations\n): typeof DOMOperations {\n  if (!document) return DOMClass;\n\n  if (!shouldApplyFix(document)) {\n    return DOMClass;\n  }\n\n  return class DOMChangesWithTextNodeMergingFix extends DOMClass {\n    private uselessComment: SimpleComment;\n\n    constructor(document: SimpleDocument) {\n      super(document);\n      this.uselessComment = document.createComment('');\n    }\n\n    override insertHTMLBefore(\n      parent: SimpleElement,\n      nextSibling: Nullable<SimpleNode>,\n      html: string\n    ): Bounds {\n      if (html === '') {\n        return super.insertHTMLBefore(parent, nextSibling, html);\n      }\n\n      let didSetUselessComment = false;\n\n      const nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n\n      if (nextPrevious && nextPrevious instanceof Text) {\n        didSetUselessComment = true;\n        parent.insertBefore(this.uselessComment, nextSibling);\n      }\n\n      const bounds = super.insertHTMLBefore(parent, nextSibling, html);\n\n      if (didSetUselessComment) {\n        parent.removeChild(this.uselessComment);\n      }\n\n      return bounds;\n    }\n  };\n}\n\nfunction shouldApplyFix(document: SimpleDocument) {\n  const mergingTextDiv = document.createElement('div');\n\n  mergingTextDiv.appendChild(document.createTextNode('first'));\n  mergingTextDiv.insertAdjacentHTML(INSERT_BEFORE_END, 'second');\n\n  if (mergingTextDiv.childNodes.length === 2) {\n    // It worked as expected, no fix required\n    return false;\n  }\n\n  return true;\n}\n","import type {\n  AttrNamespace,\n  ElementNamespace,\n  GlimmerTreeConstruction,\n  Nullable,\n  SimpleDocument,\n  SimpleElement,\n} from '@glimmer/interfaces';\nimport { castToSimple, NS_SVG } from '@glimmer/util';\n\nimport { applySVGInnerHTMLFix } from '../compat/svg-inner-html-fix';\nimport { applyTextNodeMergingFix } from '../compat/text-node-merging-fix';\nimport { DOMOperations } from './operations';\n\nconst doc: Nullable<SimpleDocument> =\n  typeof document === 'undefined' ? null : castToSimple(document);\n\nexport class TreeConstruction extends DOMOperations implements GlimmerTreeConstruction {\n  createElementNS(namespace: ElementNamespace, tag: string): SimpleElement {\n    return this.document.createElementNS(namespace, tag);\n  }\n\n  setAttribute(\n    element: SimpleElement,\n    name: string,\n    value: string,\n    namespace: Nullable<AttrNamespace> = null\n  ) {\n    if (namespace) {\n      element.setAttributeNS(namespace, name, value);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n}\n\nlet appliedTreeConstruction = TreeConstruction;\nappliedTreeConstruction = applyTextNodeMergingFix(\n  doc,\n  appliedTreeConstruction\n) as typeof TreeConstruction;\nappliedTreeConstruction = applySVGInnerHTMLFix(\n  doc,\n  appliedTreeConstruction,\n  NS_SVG\n) as typeof TreeConstruction;\n\nexport const DOMTreeConstruction = appliedTreeConstruction;\nexport type DOMTreeConstruction = TreeConstruction;\n","import type {\n  GlimmerTreeChanges,\n  Nullable,\n  SimpleDocument,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport { castToSimple, NS_SVG } from '@glimmer/util';\n\nimport { applySVGInnerHTMLFix } from '../compat/svg-inner-html-fix';\nimport { applyTextNodeMergingFix } from '../compat/text-node-merging-fix';\nimport { BLACKLIST_TABLE, DOMOperations } from './operations';\n\n[\n  'b',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'center',\n  'code',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'hr',\n  'i',\n  'img',\n  'li',\n  'listing',\n  'main',\n  'meta',\n  'nobr',\n  'ol',\n  'p',\n  'pre',\n  'ruby',\n  's',\n  'small',\n  'span',\n  'strong',\n  'strike',\n  'sub',\n  'sup',\n  'table',\n  'tt',\n  'u',\n  'ul',\n  'var',\n].forEach((tag) => (BLACKLIST_TABLE[tag] = 1));\n\nconst WHITESPACE =\n  /[\\t\\n\\v\\f\\r \\xA0\\u{1680}\\u{180e}\\u{2000}-\\u{200a}\\u{2028}\\u{2029}\\u{202f}\\u{205f}\\u{3000}\\u{feff}]/u;\n\nconst doc: Nullable<SimpleDocument> =\n  typeof document === 'undefined' ? null : castToSimple(document);\n\nexport function isWhitespace(string: string) {\n  return WHITESPACE.test(string);\n}\n\nexport class DOMChangesImpl extends DOMOperations implements GlimmerTreeChanges {\n  protected namespace: Nullable<string>;\n\n  constructor(protected override document: SimpleDocument) {\n    super(document);\n    this.namespace = null;\n  }\n\n  setAttribute(element: SimpleElement, name: string, value: string) {\n    element.setAttribute(name, value);\n  }\n\n  removeAttribute(element: SimpleElement, name: string) {\n    element.removeAttribute(name);\n  }\n\n  insertAfter(element: SimpleElement, node: SimpleNode, reference: SimpleNode) {\n    this.insertBefore(element, node, reference.nextSibling);\n  }\n}\n\nlet helper = DOMChangesImpl;\n\nhelper = applyTextNodeMergingFix(doc, helper) as typeof DOMChangesImpl;\nhelper = applySVGInnerHTMLFix(doc, helper, NS_SVG) as typeof DOMChangesImpl;\n\nexport const DOMChanges = helper;\nexport { DOMTreeConstruction } from './api';\n","import type {\n  Bounds,\n  CapturedRenderNode,\n  DebugRenderTree,\n  Nullable,\n  RenderNode,\n} from '@glimmer/interfaces';\nimport { assign, expect, Stack } from '@glimmer/util';\n\nimport { reifyArgsDebug } from './vm/arguments';\n\ninterface InternalRenderNode<T extends object> extends RenderNode {\n  bounds: Nullable<Bounds>;\n  refs: Set<Ref<T>>;\n  parent?: InternalRenderNode<T>;\n}\n\nlet GUID = 0;\n\nexport class Ref<T extends object> {\n  readonly id: number = GUID++;\n  private value: Nullable<T>;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  get(): Nullable<T> {\n    return this.value;\n  }\n\n  release(): void {\n    if (import.meta.env.DEV && this.value === null) {\n      throw new Error('BUG: double release?');\n    }\n\n    this.value = null;\n  }\n\n  toString(): String {\n    let label = `Ref ${this.id}`;\n\n    if (this.value === null) {\n      return `${label} (released)`;\n    } else {\n      try {\n        return `${label}: ${this.value}`;\n      } catch {\n        return label;\n      }\n    }\n  }\n}\n\nexport default class DebugRenderTreeImpl<TBucket extends object>\n  implements DebugRenderTree<TBucket>\n{\n  private stack = new Stack<TBucket>();\n\n  private refs = new WeakMap<TBucket, Ref<TBucket>>();\n  private roots = new Set<Ref<TBucket>>();\n  private nodes = new WeakMap<TBucket, InternalRenderNode<TBucket>>();\n\n  begin(): void {\n    this.reset();\n  }\n\n  create(state: TBucket, node: RenderNode): void {\n    let internalNode: InternalRenderNode<TBucket> = assign({}, node, {\n      bounds: null,\n      refs: new Set<Ref<TBucket>>(),\n    });\n    this.nodes.set(state, internalNode);\n    this.appendChild(internalNode, state);\n    this.enter(state);\n  }\n\n  update(state: TBucket): void {\n    this.enter(state);\n  }\n\n  didRender(state: TBucket, bounds: Bounds): void {\n    if (import.meta.env.DEV && this.stack.current !== state) {\n      throw new Error(`BUG: expecting ${this.stack.current}, got ${state}`);\n    }\n\n    this.nodeFor(state).bounds = bounds;\n    this.exit();\n  }\n\n  willDestroy(state: TBucket): void {\n    expect(this.refs.get(state), 'BUG: missing ref').release();\n  }\n\n  commit(): void {\n    this.reset();\n  }\n\n  capture(): CapturedRenderNode[] {\n    return this.captureRefs(this.roots);\n  }\n\n  private reset(): void {\n    if (this.stack.size !== 0) {\n      // We probably encountered an error during the rendering loop. This will\n      // likely trigger undefined behavior and memory leaks as the error left\n      // things in an inconsistent state. It is recommended that the user\n      // refresh the page.\n\n      // TODO: We could warn here? But this happens all the time in our tests?\n\n      // Clean up the root reference to prevent errors from happening if we\n      // attempt to capture the render tree (Ember Inspector may do this)\n      let root = expect(this.stack.toArray()[0], 'expected root state when resetting render tree');\n      let ref = this.refs.get(root);\n\n      if (ref !== undefined) {\n        this.roots.delete(ref);\n      }\n\n      while (!this.stack.isEmpty()) {\n        this.stack.pop();\n      }\n    }\n  }\n\n  private enter(state: TBucket): void {\n    this.stack.push(state);\n  }\n\n  private exit(): void {\n    if (import.meta.env.DEV && this.stack.size === 0) {\n      throw new Error('BUG: unbalanced pop');\n    }\n\n    this.stack.pop();\n  }\n\n  private nodeFor(state: TBucket): InternalRenderNode<TBucket> {\n    return expect(this.nodes.get(state), 'BUG: missing node');\n  }\n\n  private appendChild(node: InternalRenderNode<TBucket>, state: TBucket): void {\n    if (import.meta.env.DEV && this.refs.has(state)) {\n      throw new Error('BUG: child already appended');\n    }\n\n    let parent = this.stack.current;\n    let ref = new Ref(state);\n\n    this.refs.set(state, ref);\n\n    if (parent) {\n      let parentNode = this.nodeFor(parent);\n      parentNode.refs.add(ref);\n      node.parent = parentNode;\n    } else {\n      this.roots.add(ref);\n    }\n  }\n\n  private captureRefs(refs: Set<Ref<TBucket>>): CapturedRenderNode[] {\n    let captured: CapturedRenderNode[] = [];\n\n    refs.forEach((ref) => {\n      let state = ref.get();\n\n      if (state) {\n        captured.push(this.captureNode(`render-node:${ref.id}`, state));\n      } else {\n        refs.delete(ref);\n      }\n    });\n\n    return captured;\n  }\n\n  private captureNode(id: string, state: TBucket): CapturedRenderNode {\n    let node = this.nodeFor(state);\n    let { type, name, args, instance, refs } = node;\n    let template = this.captureTemplate(node);\n    let bounds = this.captureBounds(node);\n    let children = this.captureRefs(refs);\n    return { id, type, name, args: reifyArgsDebug(args), instance, template, bounds, children };\n  }\n\n  private captureTemplate({ template }: InternalRenderNode<TBucket>): Nullable<string> {\n    return template || null;\n  }\n\n  private captureBounds(node: InternalRenderNode<TBucket>): CapturedRenderNode['bounds'] {\n    let bounds = expect(node.bounds, 'BUG: missing bounds');\n    let parentElement = bounds.parentElement();\n    let firstNode = bounds.firstNode();\n    let lastNode = bounds.lastNode();\n    return { parentElement, firstNode, lastNode };\n  }\n}\n","import type {\n  ComponentInstanceWithCreate,\n  Environment,\n  EnvironmentOptions,\n  GlimmerTreeChanges,\n  GlimmerTreeConstruction,\n  ModifierInstance,\n  Nullable,\n  RuntimeArtifacts,\n  RuntimeContext,\n  RuntimeResolver,\n  Transaction,\n  TransactionSymbol,\n} from '@glimmer/interfaces';\nimport { RuntimeProgramImpl } from '@glimmer/program';\nimport { assert, expect } from '@glimmer/util';\nimport { track, updateTag } from '@glimmer/validator';\n\nimport DebugRenderTree from './debug-render-tree';\nimport { DOMChangesImpl, DOMTreeConstruction } from './dom/helper';\nimport { isArgumentError } from './vm/arguments';\n\nexport const TRANSACTION: TransactionSymbol = Symbol('TRANSACTION') as TransactionSymbol;\n\nclass TransactionImpl implements Transaction {\n  public scheduledInstallModifiers: ModifierInstance[] = [];\n  public scheduledUpdateModifiers: ModifierInstance[] = [];\n  public createdComponents: ComponentInstanceWithCreate[] = [];\n  public updatedComponents: ComponentInstanceWithCreate[] = [];\n\n  didCreate(component: ComponentInstanceWithCreate) {\n    this.createdComponents.push(component);\n  }\n\n  didUpdate(component: ComponentInstanceWithCreate) {\n    this.updatedComponents.push(component);\n  }\n\n  scheduleInstallModifier(modifier: ModifierInstance) {\n    this.scheduledInstallModifiers.push(modifier);\n  }\n\n  scheduleUpdateModifier(modifier: ModifierInstance) {\n    this.scheduledUpdateModifiers.push(modifier);\n  }\n\n  commit() {\n    let { createdComponents, updatedComponents } = this;\n\n    for (const { manager, state } of createdComponents) {\n      manager.didCreate(state);\n    }\n\n    for (const { manager, state } of updatedComponents) {\n      manager.didUpdate(state);\n    }\n\n    let { scheduledInstallModifiers, scheduledUpdateModifiers } = this;\n\n    for (const { manager, state, definition } of scheduledInstallModifiers) {\n      let modifierTag = manager.getTag(state);\n\n      if (modifierTag !== null) {\n        let tag = track(\n          () => manager.install(state),\n          import.meta.env.DEV &&\n            `- While rendering:\\n  (instance of a \\`${\n              definition.resolvedName || manager.getDebugName(definition.state)\n            }\\` modifier)`\n        );\n        updateTag(modifierTag, tag);\n      } else {\n        manager.install(state);\n      }\n    }\n\n    for (const { manager, state, definition } of scheduledUpdateModifiers) {\n      let modifierTag = manager.getTag(state);\n\n      if (modifierTag !== null) {\n        let tag = track(\n          () => manager.update(state),\n          import.meta.env.DEV &&\n            `- While rendering:\\n  (instance of a \\`${\n              definition.resolvedName || manager.getDebugName(definition.state)\n            }\\` modifier)`\n        );\n        updateTag(modifierTag, tag);\n      } else {\n        manager.update(state);\n      }\n    }\n  }\n}\n\nexport class EnvironmentImpl implements Environment {\n  [TRANSACTION]: Nullable<TransactionImpl> = null;\n\n  protected declare appendOperations: GlimmerTreeConstruction;\n  protected updateOperations?: GlimmerTreeChanges | undefined;\n\n  // Delegate methods and values\n  public isInteractive: boolean;\n\n  isArgumentCaptureError: ((error: any) => boolean) | undefined;\n  debugRenderTree: DebugRenderTree<object> | undefined;\n\n  constructor(\n    options: EnvironmentOptions,\n    private delegate: EnvironmentDelegate\n  ) {\n    this.isInteractive = delegate.isInteractive;\n    this.debugRenderTree = this.delegate.enableDebugTooling ? new DebugRenderTree() : undefined;\n    this.isArgumentCaptureError = this.delegate.enableDebugTooling ? isArgumentError : undefined;\n    if (options.appendOperations) {\n      this.appendOperations = options.appendOperations;\n      this.updateOperations = options.updateOperations;\n    } else if (options.document) {\n      this.appendOperations = new DOMTreeConstruction(options.document);\n      this.updateOperations = new DOMChangesImpl(options.document);\n    } else if (import.meta.env.DEV) {\n      throw new Error('you must pass document or appendOperations to a new runtime');\n    }\n  }\n\n  getAppendOperations(): GlimmerTreeConstruction {\n    return this.appendOperations;\n  }\n\n  getDOM(): GlimmerTreeChanges {\n    return expect(\n      this.updateOperations,\n      'Attempted to get DOM updateOperations, but they were not provided by the environment. You may be attempting to rerender in an environment which does not support rerendering, such as SSR.'\n    );\n  }\n\n  begin() {\n    assert(\n      !this[TRANSACTION],\n      'A glimmer transaction was begun, but one already exists. You may have a nested transaction, possibly caused by an earlier runtime exception while rendering. Please check your console for the stack trace of any prior exceptions.'\n    );\n\n    this.debugRenderTree?.begin();\n\n    this[TRANSACTION] = new TransactionImpl();\n  }\n\n  private get transaction(): TransactionImpl {\n    return expect(this[TRANSACTION]!, 'must be in a transaction');\n  }\n\n  didCreate(component: ComponentInstanceWithCreate) {\n    this.transaction.didCreate(component);\n  }\n\n  didUpdate(component: ComponentInstanceWithCreate) {\n    this.transaction.didUpdate(component);\n  }\n\n  scheduleInstallModifier(modifier: ModifierInstance) {\n    if (this.isInteractive) {\n      this.transaction.scheduleInstallModifier(modifier);\n    }\n  }\n\n  scheduleUpdateModifier(modifier: ModifierInstance) {\n    if (this.isInteractive) {\n      this.transaction.scheduleUpdateModifier(modifier);\n    }\n  }\n\n  commit() {\n    let transaction = this.transaction;\n    this[TRANSACTION] = null;\n    transaction.commit();\n\n    this.debugRenderTree?.commit();\n\n    this.delegate.onTransactionCommit();\n  }\n}\n\nexport interface EnvironmentDelegate {\n  /**\n   * Used to determine the the environment is interactive (e.g. SSR is not\n   * interactive). Interactive environments schedule modifiers, among other things.\n   */\n  isInteractive: boolean;\n\n  /**\n   * Used to enable debug tooling\n   */\n  enableDebugTooling: boolean;\n\n  /**\n   * Callback to be called when an environment transaction commits\n   */\n  onTransactionCommit: () => void;\n}\n\nexport function runtimeContext(\n  options: EnvironmentOptions,\n  delegate: EnvironmentDelegate,\n  artifacts: RuntimeArtifacts,\n  resolver: RuntimeResolver\n): RuntimeContext {\n  return {\n    env: new EnvironmentImpl(options, delegate),\n    program: new RuntimeProgramImpl(artifacts.constants, artifacts.heap),\n    resolver: resolver,\n  };\n}\n\nexport function inTransaction(env: Environment, block: () => void): void {\n  if (!env[TRANSACTION]) {\n    env.begin();\n    try {\n      block();\n    } finally {\n      env.commit();\n    }\n  } else {\n    block();\n  }\n}\n\nexport default EnvironmentImpl;\n","import type { Helper, HelperDefinitionState } from '@glimmer/interfaces';\nimport { setInternalHelperManager } from '@glimmer/manager';\n\nexport function internalHelper(helper: Helper): HelperDefinitionState {\n  return setInternalHelperManager(helper, {});\n}\n","import type { CapturedArguments } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { createComputeRef } from '@glimmer/reference';\n\nimport { reifyPositional } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\n/**\n   Use the `{{array}}` helper to create an array to pass as an option to your\n   components.\n\n   ```handlebars\n   <MyComponent @people={{array\n     'Tom Dale'\n     'Yehuda Katz'\n     this.myOtherPerson}}\n   />\n   ```\n    or\n   ```handlebars\n   {{my-component people=(array\n     'Tom Dale'\n     'Yehuda Katz'\n     this.myOtherPerson)\n   }}\n   ```\n\n   Would result in an object such as:\n\n   ```js\n   ['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]\n   ```\n\n   Where the 3rd item in the array is bound to updates of the `myOtherPerson` property.\n\n   @method array\n   @param {Array} options\n   @return {Array} Array\n   @public\n */\n\nexport const array = internalHelper(({ positional }: CapturedArguments): Reference<unknown[]> => {\n  return createComputeRef(() => reifyPositional(positional), null, 'array');\n});\n","import type { CapturedArguments } from '@glimmer/interfaces';\nimport { createComputeRef } from '@glimmer/reference';\n\nimport { reifyPositional } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\nconst isEmpty = (value: unknown): boolean => {\n  return value === null || value === undefined || typeof (value as object).toString !== 'function';\n};\n\nconst normalizeTextValue = (value: unknown): string => {\n  if (isEmpty(value)) {\n    return '';\n  }\n  return String(value);\n};\n\n/**\n  Concatenates the given arguments into a string.\n\n  Example:\n\n  ```handlebars\n  {{some-component name=(concat firstName \" \" lastName)}}\n\n  {{! would pass name=\"<first name value> <last name value>\" to the component}}\n  ```\n\n  or for angle bracket invocation, you actually don't need concat at all.\n\n  ```handlebars\n  <SomeComponent @name=\"{{firstName}} {{lastName}}\" />\n  ```\n\n  @public\n  @method concat\n*/\nexport const concat = internalHelper(({ positional }: CapturedArguments) => {\n  return createComputeRef(\n    () => reifyPositional(positional).map(normalizeTextValue).join(''),\n    null,\n    'concat'\n  );\n});\n","import type { CapturedArguments } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { check } from '@glimmer/debug';\nimport { createComputeRef, isInvokableRef, updateRef, valueForRef } from '@glimmer/reference';\nimport { buildUntouchableThis } from '@glimmer/util';\n\nimport { reifyPositional } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\nconst context = buildUntouchableThis('`fn` helper');\n\n/**\n  The `fn` helper allows you to ensure a function that you are passing off\n  to another component, helper, or modifier has access to arguments that are\n  available in the template.\n\n  For example, if you have an `each` helper looping over a number of items, you\n  may need to pass a function that expects to receive the item as an argument\n  to a component invoked within the loop. Here's how you could use the `fn`\n  helper to pass both the function and its arguments together:\n\n    ```app/templates/components/items-listing.hbs\n  {{#each @items as |item|}}\n    <DisplayItem @item=item @select={{fn this.handleSelected item}} />\n  {{/each}}\n  ```\n\n  ```app/components/items-list.js\n  import Component from '@glimmer/component';\n  import { action } from '@ember/object';\n\n  export default class ItemsList extends Component {\n    handleSelected = (item) => {\n      // ...snip...\n    }\n  }\n  ```\n\n  In this case the `display-item` component will receive a normal function\n  that it can invoke. When it invokes the function, the `handleSelected`\n  function will receive the `item` and any arguments passed, thanks to the\n  `fn` helper.\n\n  Let's take look at what that means in a couple circumstances:\n\n  - When invoked as `this.args.select()` the `handleSelected` function will\n    receive the `item` from the loop as its first and only argument.\n  - When invoked as `this.args.select('foo')` the `handleSelected` function\n    will receive the `item` from the loop as its first argument and the\n    string `'foo'` as its second argument.\n\n  In the example above, we used an arrow function to ensure that\n  `handleSelected` is properly bound to the `items-list`, but let's explore what\n  happens if we left out the arrow function:\n\n  ```app/components/items-list.js\n  import Component from '@glimmer/component';\n\n  export default class ItemsList extends Component {\n    handleSelected(item) {\n      // ...snip...\n    }\n  }\n  ```\n\n  In this example, when `handleSelected` is invoked inside the `display-item`\n  component, it will **not** have access to the component instance. In other\n  words, it will have no `this` context, so please make sure your functions\n  are bound (via an arrow function or other means) before passing into `fn`!\n\n  See also [partial application](https://en.wikipedia.org/wiki/Partial_application).\n\n  @method fn\n  @public\n*/\nexport const fn = internalHelper(({ positional }: CapturedArguments) => {\n  let callbackRef = check(positional[0], assertCallbackIsFn);\n\n  return createComputeRef(\n    () => {\n      return (...invocationArgs: unknown[]) => {\n        let [fn, ...args] = reifyPositional(positional);\n\n        if (import.meta.env.DEV) assertCallbackIsFn(callbackRef);\n\n        if (isInvokableRef(callbackRef)) {\n          let value = args.length > 0 ? args[0] : invocationArgs[0];\n          return updateRef(callbackRef, value);\n        } else {\n          return (fn as Function).call(context, ...args, ...invocationArgs);\n        }\n      };\n    },\n    null,\n    'fn'\n  );\n});\n\nfunction assertCallbackIsFn(callbackRef: Reference | undefined): asserts callbackRef is Reference {\n  if (\n    !(\n      callbackRef &&\n      (isInvokableRef(callbackRef) || typeof valueForRef(callbackRef) === 'function')\n    )\n  ) {\n    throw new Error(\n      `You must pass a function as the \\`fn\\` helper's first argument, you passed ${\n        callbackRef ? valueForRef(callbackRef) : callbackRef\n      }. While rendering:\\n\\n${callbackRef?.debugLabel}`\n    );\n  }\n}\n","import type { CapturedArguments } from '@glimmer/interfaces';\nimport { getPath, setPath } from '@glimmer/global-context';\nimport { createComputeRef, UNDEFINED_REFERENCE, valueForRef } from '@glimmer/reference';\nimport { isDict } from '@glimmer/util';\n\nimport { internalHelper } from './internal-helper';\n\n/**\n  Dynamically look up a property on an object. The second argument to `{{get}}`\n  should have a string value, although it can be bound.\n\n  For example, these two usages are equivalent:\n\n  ```app/components/developer-detail.js\n  import Component from '@glimmer/component';\n  import { tracked } from '@glimmer/tracking';\n\n  export default class extends Component {\n    @tracked developer = {\n      name: \"Sandi Metz\",\n      language: \"Ruby\"\n    }\n  }\n  ```\n\n  ```handlebars\n  {{this.developer.name}}\n  {{get this.developer \"name\"}}\n  ```\n\n  If there were several facts about a person, the `{{get}}` helper can dynamically\n  pick one:\n\n  ```app/templates/application.hbs\n  <DeveloperDetail @factName=\"language\" />\n  ```\n\n  ```handlebars\n  {{get this.developer @factName}}\n  ```\n\n  For a more complex example, this template would allow the user to switch\n  between showing the user's height and weight with a click:\n\n  ```app/components/developer-detail.js\n  import Component from '@glimmer/component';\n  import { tracked } from '@glimmer/tracking';\n\n  export default class extends Component {\n    @tracked developer = {\n      name: \"Sandi Metz\",\n      language: \"Ruby\"\n    }\n\n    @tracked currentFact = 'name'\n\n    showFact = (fact) => {\n      this.currentFact = fact;\n    }\n  }\n  ```\n\n  ```app/components/developer-detail.js\n  {{get this.developer this.currentFact}}\n\n  <button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n  <button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n  ```\n\n  The `{{get}}` helper can also respect mutable values itself. For example:\n\n  ```app/components/developer-detail.js\n  <Input @value={{mut (get this.person this.currentFact)}} />\n\n  <button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n  <button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n  ```\n\n  Would allow the user to swap what fact is being displayed, and also edit\n  that fact via a two-way mutable binding.\n\n  @public\n  @method get\n */\nexport const get = internalHelper(({ positional }: CapturedArguments) => {\n  let sourceRef = positional[0] ?? UNDEFINED_REFERENCE;\n  let pathRef = positional[1] ?? UNDEFINED_REFERENCE;\n\n  return createComputeRef(\n    () => {\n      let source = valueForRef(sourceRef);\n\n      if (isDict(source)) {\n        return getPath(source, String(valueForRef(pathRef)));\n      }\n    },\n    (value) => {\n      let source = valueForRef(sourceRef);\n\n      if (isDict(source)) {\n        return setPath(source, String(valueForRef(pathRef)), value);\n      }\n    },\n    'get'\n  );\n});\n","import type { CapturedArguments, Dict } from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { createComputeRef } from '@glimmer/reference';\n\nimport { reifyNamed } from '../vm/arguments';\nimport { internalHelper } from './internal-helper';\n\n/**\n   Use the `{{hash}}` helper to create a hash to pass as an option to your\n   components. This is specially useful for contextual components where you can\n   just yield a hash:\n\n   ```handlebars\n   {{yield (hash\n      name='Sarah'\n      title=office\n   )}}\n   ```\n\n   Would result in an object such as:\n\n   ```js\n   { name: 'Sarah', title: this.get('office') }\n   ```\n\n   Where the `title` is bound to updates of the `office` property.\n\n   Note that the hash is an empty object with no prototype chain, therefore\n   common methods like `toString` are not available in the resulting hash.\n   If you need to use such a method, you can use the `call` or `apply`\n   approach:\n\n   ```js\n   function toString(obj) {\n     return Object.prototype.toString.apply(obj);\n   }\n   ```\n\n   @method hash\n   @param {Object} options\n   @return {Object} Hash\n   @public\n */\nexport const hash = internalHelper(({ named }: CapturedArguments): Reference<Dict<unknown>> => {\n  let ref = createComputeRef(\n    () => {\n      return reifyNamed(named);\n    },\n    null,\n    'hash'\n  );\n\n  // Setup the children so that templates can bypass getting the value of\n  // the reference and treat children lazily\n  let children = new Map();\n\n  for (let name in named) {\n    children.set(name, named[name]);\n  }\n\n  ref.children = children;\n\n  return ref;\n});\n","import type { Arguments, InternalHelperManager } from '@glimmer/interfaces';\nimport type { Cache } from '@glimmer/validator';\nimport { associateDestroyableChild, isDestroyed, isDestroying } from '@glimmer/destroyable';\nimport { getInternalHelperManager, hasDestroyable, hasValue } from '@glimmer/manager';\nimport { getOwner } from '@glimmer/owner';\nimport { debugToString } from '@glimmer/util';\nimport { createCache, getValue } from '@glimmer/validator';\n\nimport { EMPTY_ARGS, EMPTY_NAMED, EMPTY_POSITIONAL } from '../vm/arguments';\n\nlet ARGS_CACHES = import.meta.env.DEV\n  ? new WeakMap<SimpleArgsProxy, Cache<Partial<Arguments>>>()\n  : undefined;\n\nfunction getArgs(proxy: SimpleArgsProxy): Partial<Arguments> {\n  return getValue(import.meta.env.DEV ? ARGS_CACHES!.get(proxy)! : proxy.argsCache!)!;\n}\n\nclass SimpleArgsProxy {\n  argsCache?: Cache<Partial<Arguments>>;\n\n  constructor(\n    context: object,\n    computeArgs: (context: object) => Partial<Arguments> = () => EMPTY_ARGS\n  ) {\n    let argsCache = createCache(() => computeArgs(context));\n\n    if (import.meta.env.DEV) {\n      ARGS_CACHES!.set(this, argsCache);\n      Object.freeze(this);\n    } else {\n      this.argsCache = argsCache;\n    }\n  }\n\n  get named() {\n    return getArgs(this).named || EMPTY_NAMED;\n  }\n\n  get positional() {\n    return getArgs(this).positional || EMPTY_POSITIONAL;\n  }\n}\n\n////////////\n\nexport function invokeHelper(\n  context: object,\n  definition: object,\n  computeArgs?: (context: object) => Partial<Arguments>\n): Cache<unknown> {\n  if (import.meta.env.DEV && (typeof context !== 'object' || context === null)) {\n    throw new Error(\n      `Expected a context object to be passed as the first parameter to invokeHelper, got ${context}`\n    );\n  }\n\n  const owner = getOwner(context);\n  const internalManager = getInternalHelperManager(definition)!;\n\n  // TODO: figure out why assert isn't using the TS assert thing\n  if (import.meta.env.DEV && !internalManager) {\n    throw new Error(\n      `Expected a helper definition to be passed as the second parameter to invokeHelper, but no helper manager was found. The definition value that was passed was \\`${debugToString!(\n        definition\n      )}\\`. Did you use setHelperManager to associate a helper manager with this value?`\n    );\n  }\n\n  if (import.meta.env.DEV && typeof internalManager === 'function') {\n    throw new Error(\n      'Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.'\n    );\n  }\n\n  const manager = (internalManager as InternalHelperManager<object>).getDelegateFor(owner);\n  let args = new SimpleArgsProxy(context, computeArgs);\n  let bucket = manager.createHelper(definition, args);\n\n  let cache: Cache<unknown>;\n\n  if (hasValue(manager)) {\n    cache = createCache(() => {\n      if (import.meta.env.DEV && (isDestroying(cache) || isDestroyed(cache))) {\n        throw new Error(\n          `You attempted to get the value of a helper after the helper was destroyed, which is not allowed`\n        );\n      }\n\n      return manager.getValue(bucket);\n    });\n\n    associateDestroyableChild(context, cache);\n  } else {\n    throw new Error('TODO: unreachable, to be implemented with hasScheduledEffect');\n  }\n\n  if (hasDestroyable(manager)) {\n    let destroyable = manager.getDestroyable(bucket);\n\n    associateDestroyableChild(cache, destroyable);\n  }\n\n  return cache;\n}\n","import type {\n  CapturedArguments,\n  InternalModifierManager,\n  Owner,\n  SimpleElement,\n  UpdatableTag,\n} from '@glimmer/interfaces';\nimport {\n  check,\n  CheckBoolean,\n  CheckFunction,\n  CheckOr,\n  CheckString,\n  CheckUndefined,\n} from '@glimmer/debug';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { setInternalModifierManager } from '@glimmer/manager';\nimport { valueForRef } from '@glimmer/reference';\nimport { assert, buildUntouchableThis } from '@glimmer/util';\nimport { createUpdatableTag } from '@glimmer/validator';\n\nimport { reifyNamed } from '../vm/arguments';\n\nconst untouchableContext = buildUntouchableThis('`on` modifier');\n\ninterface Listener {\n  eventName: string;\n  callback: EventListener;\n  userProvidedCallback: EventListener;\n  once: boolean | undefined;\n  passive: boolean | undefined;\n  capture: boolean | undefined;\n  options: AddEventListenerOptions | undefined;\n}\n\nexport class OnModifierState {\n  public tag = createUpdatableTag();\n  public element: Element;\n  public args: CapturedArguments;\n  public listener: Listener | null = null;\n\n  constructor(element: Element, args: CapturedArguments) {\n    this.element = element;\n    this.args = args;\n\n    registerDestructor(this, () => {\n      let { element, listener } = this;\n      if (listener) {\n        let { eventName, callback, options } = listener;\n        removeEventListener(element, eventName, callback, options);\n      }\n    });\n  }\n\n  // Update this.listener if needed\n  updateListener(): void {\n    let { element, args, listener } = this;\n\n    assert(\n      args.positional[0],\n      'You must pass a valid DOM event name as the first argument to the `on` modifier'\n    );\n\n    let eventName = check(\n      valueForRef(args.positional[0]),\n      CheckString,\n      () => 'You must pass a valid DOM event name as the first argument to the `on` modifier'\n    );\n\n    assert(\n      args.positional[1],\n      'You must pass a function as the second argument to the `on` modifier'\n    );\n\n    let userProvidedCallback = check(valueForRef(args.positional[1]), CheckFunction, (actual) => {\n      return `You must pass a function as the second argument to the \\`on\\` modifier; you passed ${\n        actual === null ? 'null' : typeof actual\n      }. While rendering:\\n\\n${args.positional[1]?.debugLabel ?? `{unlabeled value}`}`;\n    }) as EventListener;\n\n    if (import.meta.env.DEV && args.positional.length !== 2) {\n      throw new Error(\n        `You can only pass two positional arguments (event name and callback) to the \\`on\\` modifier, but you provided ${args.positional.length}. Consider using the \\`fn\\` helper to provide additional arguments to the \\`on\\` callback.`\n      );\n    }\n\n    let once: boolean | undefined = undefined;\n    let passive: boolean | undefined = undefined;\n    let capture: boolean | undefined = undefined;\n\n    if (import.meta.env.DEV) {\n      let { once: _once, passive: _passive, capture: _capture, ...extra } = reifyNamed(args.named);\n\n      once = check(_once, CheckOr(CheckBoolean, CheckUndefined), (actual) => {\n        return `You must pass a boolean or undefined as the \\`once\\` argument to the \\`on\\` modifier; you passed ${actual}. While rendering:\\n\\n${\n          args.named['once']!.debugLabel ?? `{unlabeled value}`\n        }`;\n      });\n\n      passive = check(_passive, CheckOr(CheckBoolean, CheckUndefined), (actual) => {\n        return `You must pass a boolean or undefined as the \\`passive\\` argument to the \\`on\\` modifier; you passed ${actual}. While rendering:\\n\\n${\n          args.named['passive']!.debugLabel ?? `{unlabeled value}`\n        }`;\n      });\n\n      capture = check(_capture, CheckOr(CheckBoolean, CheckUndefined), (actual) => {\n        return `You must pass a boolean or undefined as the \\`capture\\` argument to the \\`on\\` modifier; you passed ${actual}. While rendering:\\n\\n${\n          args.named['capture']!.debugLabel ?? `{unlabeled value}`\n        }`;\n      });\n\n      if (Object.keys(extra).length > 0) {\n        throw new Error(\n          `You can only \\`once\\`, \\`passive\\` or \\`capture\\` named arguments to the \\`on\\` modifier, but you provided ${Object.keys(\n            extra\n          ).join(', ')}.`\n        );\n      }\n    } else {\n      let { once: _once, passive: _passive, capture: _capture } = args.named;\n\n      if (_once) {\n        once = valueForRef(_once) as boolean | undefined;\n      }\n\n      if (_passive) {\n        passive = valueForRef(_passive) as boolean | undefined;\n      }\n\n      if (_capture) {\n        capture = valueForRef(_capture) as boolean | undefined;\n      }\n    }\n\n    let shouldUpdate = false;\n\n    if (listener === null) {\n      shouldUpdate = true;\n    } else {\n      shouldUpdate =\n        eventName !== listener.eventName ||\n        userProvidedCallback !== listener.userProvidedCallback ||\n        once !== listener.once ||\n        passive !== listener.passive ||\n        capture !== listener.capture;\n    }\n\n    let options: AddEventListenerOptions | undefined = undefined;\n\n    // we want to handle both `true` and `false` because both have a meaning:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=770208\n    if (shouldUpdate) {\n      if (once !== undefined || passive !== undefined || capture !== undefined) {\n        options = { once, passive, capture } as AddEventListenerOptions;\n      }\n    }\n\n    if (shouldUpdate) {\n      let callback = userProvidedCallback;\n\n      if (import.meta.env.DEV) {\n        callback = userProvidedCallback.bind(untouchableContext);\n\n        if (passive) {\n          let _callback = callback;\n\n          callback = (event) => {\n            event.preventDefault = () => {\n              throw new Error(\n                `You marked this listener as 'passive', meaning that you must not call 'event.preventDefault()': \\n\\n${\n                  userProvidedCallback.name ?? `{anonymous function}`\n                }`\n              );\n            };\n\n            return _callback(event);\n          };\n        }\n      }\n\n      this.listener = {\n        eventName,\n        callback,\n        userProvidedCallback,\n        once,\n        passive,\n        capture,\n        options,\n      };\n\n      if (listener) {\n        removeEventListener(element, listener.eventName, listener.callback, listener.options);\n      }\n\n      addEventListener(element, eventName, callback, options);\n    }\n  }\n}\n\nlet adds = 0;\nlet removes = 0;\n\nfunction removeEventListener(\n  element: Element,\n  eventName: string,\n  callback: EventListener,\n  options?: AddEventListenerOptions\n): void {\n  removes++;\n\n  element.removeEventListener(eventName, callback, options);\n}\n\nfunction addEventListener(\n  element: Element,\n  eventName: string,\n  callback: EventListener,\n  options?: AddEventListenerOptions\n): void {\n  adds++;\n  element.addEventListener(eventName, callback, options);\n}\n\n/**\n  The `{{on}}` modifier lets you easily add event listeners (it uses\n  [EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)\n  internally).\n\n  For example, if you'd like to run a function on your component when a `<button>`\n  in the components template is clicked you might do something like:\n\n  ```app/components/like-post.hbs\n  <button {{on 'click' this.saveLike}}>Like this post!</button>\n  ```\n\n  ```app/components/like-post.js\n  import Component from '@glimmer/component';\n  import { action } from '@ember/object';\n\n  export default class LikePostComponent extends Component {\n    saveLike = () => {\n      // someone likes your post!\n      // better send a request off to your server...\n    }\n  }\n  ```\n\n  ### Arguments\n\n  `{{on}}` accepts two positional arguments, and a few named arguments.\n\n  The positional arguments are:\n\n  - `event` -- the name to use when calling `addEventListener`\n  - `callback` -- the function to be passed to `addEventListener`\n\n  The named arguments are:\n\n  - capture -- a `true` value indicates that events of this type will be dispatched\n    to the registered listener before being dispatched to any EventTarget beneath it\n    in the DOM tree.\n  - once -- indicates that the listener should be invoked at most once after being\n    added. If true, the listener would be automatically removed when invoked.\n  - passive -- if `true`, indicates that the function specified by listener will never\n    call preventDefault(). If a passive listener does call preventDefault(), the user\n    agent will do nothing other than generate a console warning. See\n    [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)\n    to learn more.\n\n  The callback function passed to `{{on}}` will receive any arguments that are passed\n  to the event handler. Most commonly this would be the `event` itself.\n\n  If you would like to pass additional arguments to the function you should use\n  the `{{fn}}` helper.\n\n  For example, in our example case above if you'd like to pass in the post that\n  was being liked when the button is clicked you could do something like:\n\n  ```app/components/like-post.hbs\n  <button {{on 'click' (fn this.saveLike @post)}}>Like this post!</button>\n  ```\n\n  In this case, the `saveLike` function will receive two arguments: the click event\n  and the value of `@post`.\n\n  ### Function Context\n\n  In the example above, we used an arrow function to ensure that `likePost` is\n  properly bound to the `items-list`, but let's explore what happens if we\n  left out the arrow function:\n\n  ```app/components/like-post.js\n  import Component from '@glimmer/component';\n\n  export default class LikePostComponent extends Component {\n    saveLike() {\n      // ...snip...\n    }\n  }\n  ```\n\n  In this example, when the button is clicked `saveLike` will be invoked,\n  it will **not** have access to the component instance. In other\n  words, it will have no `this` context, so please make sure your functions\n  are bound (via an arrow function or other means) before passing into `on`!\n\n  @method on\n  @public\n*/\nclass OnModifierManager implements InternalModifierManager<OnModifierState, object> {\n  getDebugName(): string {\n    return 'on';\n  }\n\n  getDebugInstance(): unknown {\n    return null;\n  }\n\n  get counters(): { adds: number; removes: number } {\n    return { adds, removes };\n  }\n\n  create(\n    _owner: Owner,\n    element: SimpleElement | Element,\n    _state: object,\n    args: CapturedArguments\n  ): OnModifierState {\n    return new OnModifierState(element as Element, args);\n  }\n\n  getTag({ tag }: OnModifierState): UpdatableTag {\n    return tag;\n  }\n\n  install(state: OnModifierState): void {\n    state.updateListener();\n  }\n\n  update(state: OnModifierState): void {\n    state.updateListener();\n  }\n\n  getDestroyable(state: OnModifierState): OnModifierState {\n    return state;\n  }\n}\n\nexport const on = setInternalModifierManager(new OnModifierManager(), {});\n","import type { Nullable, RuntimeHeap, RuntimeOp, RuntimeProgram } from '@glimmer/interfaces';\nimport type { MachineRegister } from '@glimmer/vm';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { assert } from '@glimmer/util';\nimport { $fp, $pc, $ra, $sp, MachineOp } from '@glimmer/vm';\n\nimport type { VM } from './append';\n\nimport { APPEND_OPCODES } from '../opcodes';\n\nexport interface LowLevelRegisters {\n  [MachineRegister.pc]: number;\n  [MachineRegister.ra]: number;\n  [MachineRegister.sp]: number;\n  [MachineRegister.fp]: number;\n}\n\nexport function initializeRegisters(): LowLevelRegisters {\n  return [0, -1, 0, 0];\n}\n\nexport function initializeRegistersWithSP(sp: number): LowLevelRegisters {\n  return [0, -1, sp, 0];\n}\n\nexport function initializeRegistersWithPC(pc: number): LowLevelRegisters {\n  return [pc, -1, 0, 0];\n}\n\nexport interface Stack {\n  push(value: unknown): void;\n  get(position: number): number;\n  pop<T>(): T;\n}\n\nexport interface Externs {\n  debugBefore(opcode: RuntimeOp): unknown;\n  debugAfter(state: unknown): void;\n}\n\nexport class LowLevelVM {\n  public currentOpSize = 0;\n\n  constructor(\n    public stack: Stack,\n    public heap: RuntimeHeap,\n    public program: RuntimeProgram,\n    public externs: Externs,\n    readonly registers: LowLevelRegisters\n  ) {}\n\n  fetchRegister(register: MachineRegister): number {\n    return this.registers[register];\n  }\n\n  loadRegister(register: MachineRegister, value: number) {\n    this.registers[register] = value;\n  }\n\n  setPc(pc: number): void {\n    assert(typeof pc === 'number' && !isNaN(pc), 'pc is set to a number');\n    this.registers[$pc] = pc;\n  }\n\n  // Start a new frame and save $ra and $fp on the stack\n  pushFrame() {\n    this.stack.push(this.registers[$ra]);\n    this.stack.push(this.registers[$fp]);\n    this.registers[$fp] = this.registers[$sp] - 1;\n  }\n\n  // Restore $ra, $sp and $fp\n  popFrame() {\n    this.registers[$sp] = this.registers[$fp] - 1;\n    this.registers[$ra] = this.stack.get(0);\n    this.registers[$fp] = this.stack.get(1);\n  }\n\n  pushSmallFrame() {\n    this.stack.push(this.registers[$ra]);\n  }\n\n  popSmallFrame() {\n    this.registers[$ra] = this.stack.pop();\n  }\n\n  // Jump to an address in `program`\n  goto(offset: number) {\n    this.setPc(this.target(offset));\n  }\n\n  target(offset: number) {\n    return this.registers[$pc] + offset - this.currentOpSize;\n  }\n\n  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n  call(handle: number) {\n    assert(handle < 0xffffffff, `Jumping to placeholder address`);\n\n    this.registers[$ra] = this.registers[$pc];\n    this.setPc(this.heap.getaddr(handle));\n  }\n\n  // Put a specific `program` address in $ra\n  returnTo(offset: number) {\n    this.registers[$ra] = this.target(offset);\n  }\n\n  // Return to the `program` address stored in $ra\n  return() {\n    this.setPc(this.registers[$ra]);\n  }\n\n  nextStatement(): Nullable<RuntimeOp> {\n    let { registers, program } = this;\n\n    let pc = registers[$pc];\n\n    assert(typeof pc === 'number', 'pc is a number');\n\n    if (pc === -1) {\n      return null;\n    }\n\n    // We have to save off the current operations size so that\n    // when we do a jump we can calculate the correct offset\n    // to where we are going. We can't simply ask for the size\n    // in a jump because we have have already incremented the\n    // program counter to the next instruction prior to executing.\n    let opcode = program.opcode(pc);\n    let operationSize = (this.currentOpSize = opcode.size);\n    this.registers[$pc] += operationSize;\n\n    return opcode;\n  }\n\n  evaluateOuter(opcode: RuntimeOp, vm: VM) {\n    if (LOCAL_DEBUG) {\n      let {\n        externs: { debugBefore, debugAfter },\n      } = this;\n      let state = debugBefore(opcode);\n      this.evaluateInner(opcode, vm);\n      debugAfter(state);\n    } else {\n      this.evaluateInner(opcode, vm);\n    }\n  }\n\n  evaluateInner(opcode: RuntimeOp, vm: VM) {\n    if (opcode.isMachine) {\n      this.evaluateMachine(opcode);\n    } else {\n      this.evaluateSyscall(opcode, vm);\n    }\n  }\n\n  evaluateMachine(opcode: RuntimeOp) {\n    switch (opcode.type) {\n      case MachineOp.PushFrame:\n        return this.pushFrame();\n      case MachineOp.PopFrame:\n        return this.popFrame();\n      case MachineOp.InvokeStatic:\n        return this.call(opcode.op1);\n      case MachineOp.InvokeVirtual:\n        return this.call(this.stack.pop());\n      case MachineOp.Jump:\n        return this.goto(opcode.op1);\n      case MachineOp.Return:\n        return this.return();\n      case MachineOp.ReturnTo:\n        return this.returnTo(opcode.op1);\n    }\n  }\n\n  evaluateSyscall(opcode: RuntimeOp, vm: VM) {\n    APPEND_OPCODES.evaluate(vm, opcode, opcode.type);\n  }\n}\n","import type {\n  Bounds,\n  DynamicScope,\n  ElementBuilder,\n  Environment,\n  ExceptionHandler,\n  GlimmerTreeChanges,\n  LiveBlock,\n  Nullable,\n  RuntimeContext,\n  Scope,\n  SimpleComment,\n  UpdatableBlock,\n  UpdatingOpcode,\n  UpdatingVM as IUpdatingVM,\n} from '@glimmer/interfaces';\nimport type { OpaqueIterationItem, OpaqueIterator, Reference } from '@glimmer/reference';\nimport { associateDestroyableChild, destroy, destroyChildren } from '@glimmer/destroyable';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { updateRef, valueForRef } from '@glimmer/reference';\nimport { expect, logStep, Stack, unwrap } from '@glimmer/util';\nimport { debug, resetTracking } from '@glimmer/validator';\n\nimport type { InternalVM, VmInitCallback } from './append';\nimport type { LiveBlockList } from './element-builder';\n\nimport { clear, move as moveBounds } from '../bounds';\nimport { NewElementBuilder } from './element-builder';\n\nexport class UpdatingVM implements IUpdatingVM {\n  public env: Environment;\n  public dom: GlimmerTreeChanges;\n  public alwaysRevalidate: boolean;\n\n  private frameStack: Stack<UpdatingVMFrame> = new Stack<UpdatingVMFrame>();\n\n  constructor(env: Environment, { alwaysRevalidate = false }) {\n    this.env = env;\n    this.dom = env.getDOM();\n    this.alwaysRevalidate = alwaysRevalidate;\n  }\n\n  execute(opcodes: UpdatingOpcode[], handler: ExceptionHandler) {\n    if (import.meta.env.DEV) {\n      let hasErrored = true;\n      try {\n        debug.runInTrackingTransaction!(\n          () => this._execute(opcodes, handler),\n          '- While rendering:'\n        );\n\n        // using a boolean here to avoid breaking ergonomics of \"pause on uncaught exceptions\"\n        // which would happen with a `catch` + `throw`\n        hasErrored = false;\n      } finally {\n        if (hasErrored) {\n          // eslint-disable-next-line no-console\n          console.error(`\\n\\nError occurred:\\n\\n${resetTracking()}\\n\\n`);\n        }\n      }\n    } else {\n      this._execute(opcodes, handler);\n    }\n  }\n\n  private _execute(opcodes: UpdatingOpcode[], handler: ExceptionHandler) {\n    let { frameStack } = this;\n\n    this.try(opcodes, handler);\n\n    while (!frameStack.isEmpty()) {\n      let opcode = this.frame.nextStatement();\n\n      if (opcode === undefined) {\n        frameStack.pop();\n        continue;\n      }\n\n      opcode.evaluate(this);\n    }\n  }\n\n  private get frame() {\n    return expect(this.frameStack.current, 'bug: expected a frame');\n  }\n\n  goto(index: number) {\n    this.frame.goto(index);\n  }\n\n  try(ops: UpdatingOpcode[], handler: Nullable<ExceptionHandler>) {\n    this.frameStack.push(new UpdatingVMFrame(ops, handler));\n  }\n\n  throw() {\n    this.frame.handleException();\n    this.frameStack.pop();\n  }\n}\n\nexport interface VMState {\n  readonly pc: number;\n  readonly scope: Scope;\n  readonly dynamicScope: DynamicScope;\n  readonly stack: unknown[];\n}\n\nexport interface ResumableVMState {\n  resume(runtime: RuntimeContext, builder: ElementBuilder): InternalVM;\n}\n\nexport class ResumableVMStateImpl implements ResumableVMState {\n  constructor(\n    readonly state: VMState,\n    private resumeCallback: VmInitCallback\n  ) {}\n\n  resume(runtime: RuntimeContext, builder: ElementBuilder): InternalVM {\n    return this.resumeCallback(runtime, this.state, builder);\n  }\n}\n\nexport abstract class BlockOpcode implements UpdatingOpcode, Bounds {\n  public children: UpdatingOpcode[];\n\n  protected readonly bounds: LiveBlock;\n\n  constructor(\n    protected state: ResumableVMState,\n    protected runtime: RuntimeContext,\n    bounds: LiveBlock,\n    children: UpdatingOpcode[]\n  ) {\n    this.children = children;\n    this.bounds = bounds;\n  }\n\n  parentElement() {\n    return this.bounds.parentElement();\n  }\n\n  firstNode() {\n    return this.bounds.firstNode();\n  }\n\n  lastNode() {\n    return this.bounds.lastNode();\n  }\n\n  evaluate(vm: UpdatingVM) {\n    vm.try(this.children, null);\n  }\n}\n\nexport class TryOpcode extends BlockOpcode implements ExceptionHandler {\n  public type = 'try';\n\n  protected declare bounds: UpdatableBlock; // Hides property on base class\n\n  override evaluate(vm: UpdatingVM) {\n    vm.try(this.children, this);\n  }\n\n  handleException() {\n    let { state, bounds, runtime } = this;\n\n    destroyChildren(this);\n\n    let elementStack = NewElementBuilder.resume(runtime.env, bounds);\n    let vm = state.resume(runtime, elementStack);\n\n    let updating: UpdatingOpcode[] = [];\n    let children = (this.children = []);\n\n    let result = vm.execute((vm) => {\n      vm.pushUpdating(updating);\n      vm.updateWith(this);\n      vm.pushUpdating(children);\n    });\n\n    associateDestroyableChild(this, result.drop);\n  }\n}\n\nexport class ListItemOpcode extends TryOpcode {\n  public retained = false;\n  public index = -1;\n\n  constructor(\n    state: ResumableVMState,\n    runtime: RuntimeContext,\n    bounds: UpdatableBlock,\n    public key: unknown,\n    public memo: Reference,\n    public value: Reference\n  ) {\n    super(state, runtime, bounds, []);\n  }\n\n  updateReferences(item: OpaqueIterationItem) {\n    this.retained = true;\n    updateRef(this.value, item.value);\n    updateRef(this.memo, item.memo);\n  }\n\n  shouldRemove(): boolean {\n    return !this.retained;\n  }\n\n  reset() {\n    this.retained = false;\n  }\n}\n\nexport class ListBlockOpcode extends BlockOpcode {\n  public type = 'list-block';\n  public declare children: ListItemOpcode[];\n\n  private opcodeMap = new Map<unknown, ListItemOpcode>();\n  private marker: SimpleComment | null = null;\n  private lastIterator: OpaqueIterator;\n\n  protected declare readonly bounds: LiveBlockList;\n\n  constructor(\n    state: ResumableVMState,\n    runtime: RuntimeContext,\n    bounds: LiveBlockList,\n    children: ListItemOpcode[],\n    private iterableRef: Reference<OpaqueIterator>\n  ) {\n    super(state, runtime, bounds, children);\n    this.lastIterator = valueForRef(iterableRef);\n  }\n\n  initializeChild(opcode: ListItemOpcode) {\n    opcode.index = this.children.length - 1;\n    this.opcodeMap.set(opcode.key, opcode);\n  }\n\n  override evaluate(vm: UpdatingVM) {\n    let iterator = valueForRef(this.iterableRef);\n\n    if (this.lastIterator !== iterator) {\n      let { bounds } = this;\n      let { dom } = vm;\n\n      let marker = (this.marker = dom.createComment(''));\n      dom.insertAfter(\n        bounds.parentElement(),\n        marker,\n        expect(bounds.lastNode(), \"can't insert after an empty bounds\")\n      );\n\n      this.sync(iterator);\n\n      this.parentElement().removeChild(marker);\n      this.marker = null;\n      this.lastIterator = iterator;\n    }\n\n    // Run now-updated updating opcodes\n    super.evaluate(vm);\n  }\n\n  private sync(iterator: OpaqueIterator) {\n    let { opcodeMap: itemMap, children } = this;\n\n    let currentOpcodeIndex = 0;\n    let seenIndex = 0;\n\n    this.children = this.bounds.boundList = [];\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let item = iterator.next();\n\n      if (item === null) break;\n\n      let opcode = children[currentOpcodeIndex];\n      let { key } = item;\n\n      // Items that have already been found and moved will already be retained,\n      // we can continue until we find the next unretained item\n      while (opcode !== undefined && opcode.retained === true) {\n        opcode = children[++currentOpcodeIndex];\n      }\n\n      if (opcode !== undefined && opcode.key === key) {\n        this.retainItem(opcode, item);\n        currentOpcodeIndex++;\n      } else if (itemMap.has(key)) {\n        let itemOpcode = itemMap.get(key)!;\n\n        // The item opcode was seen already, so we should move it.\n        if (itemOpcode.index < seenIndex) {\n          this.moveItem(itemOpcode, item, opcode);\n        } else {\n          // Update the seen index, we are going to be moving this item around\n          // so any other items that come before it will likely need to move as\n          // well.\n          seenIndex = itemOpcode.index;\n\n          let seenUnretained = false;\n\n          // iterate through all of the opcodes between the current position and\n          // the position of the item's opcode, and determine if they are all\n          // retained.\n          for (let i = currentOpcodeIndex + 1; i < seenIndex; i++) {\n            if (unwrap(children[i]).retained === false) {\n              seenUnretained = true;\n              break;\n            }\n          }\n\n          // If we have seen only retained opcodes between this and the matching\n          // opcode, it means that all the opcodes in between have been moved\n          // already, and we can safely retain this item's opcode.\n          if (seenUnretained === false) {\n            this.retainItem(itemOpcode, item);\n            currentOpcodeIndex = seenIndex + 1;\n          } else {\n            this.moveItem(itemOpcode, item, opcode);\n            currentOpcodeIndex++;\n          }\n        }\n      } else {\n        this.insertItem(item, opcode);\n      }\n    }\n\n    for (const opcode of children) {\n      if (opcode.retained === false) {\n        this.deleteItem(opcode);\n      } else {\n        opcode.reset();\n      }\n    }\n  }\n\n  private retainItem(opcode: ListItemOpcode, item: OpaqueIterationItem) {\n    if (LOCAL_DEBUG) {\n      logStep!('list-updates', ['retain', item.key]);\n    }\n\n    let { children } = this;\n\n    updateRef(opcode.memo, item.memo);\n    updateRef(opcode.value, item.value);\n    opcode.retained = true;\n\n    opcode.index = children.length;\n    children.push(opcode);\n  }\n\n  private insertItem(item: OpaqueIterationItem, before: ListItemOpcode | undefined) {\n    if (LOCAL_DEBUG) {\n      logStep!('list-updates', ['insert', item.key]);\n    }\n\n    let { opcodeMap, bounds, state, runtime, children } = this;\n    let { key } = item;\n    let nextSibling = before === undefined ? this.marker : before.firstNode();\n\n    let elementStack = NewElementBuilder.forInitialRender(runtime.env, {\n      element: bounds.parentElement(),\n      nextSibling,\n    });\n\n    let vm = state.resume(runtime, elementStack);\n\n    vm.execute((vm) => {\n      vm.pushUpdating();\n      let opcode = vm.enterItem(item);\n\n      opcode.index = children.length;\n      children.push(opcode);\n      opcodeMap.set(key, opcode);\n      associateDestroyableChild(this, opcode);\n    });\n  }\n\n  private moveItem(\n    opcode: ListItemOpcode,\n    item: OpaqueIterationItem,\n    before: ListItemOpcode | undefined\n  ) {\n    let { children } = this;\n\n    updateRef(opcode.memo, item.memo);\n    updateRef(opcode.value, item.value);\n    opcode.retained = true;\n\n    let currentSibling, nextSibling;\n\n    if (before === undefined) {\n      moveBounds(opcode, this.marker);\n    } else {\n      currentSibling = opcode.lastNode().nextSibling;\n      nextSibling = before.firstNode();\n\n      // Items are moved throughout the algorithm, so there are cases where the\n      // the items already happen to be siblings (e.g. an item in between was\n      // moved before this move happened). Check to see if they are siblings\n      // first before doing the move.\n      if (currentSibling !== nextSibling) {\n        moveBounds(opcode, nextSibling);\n      }\n    }\n\n    opcode.index = children.length;\n    children.push(opcode);\n\n    if (LOCAL_DEBUG) {\n      let type = currentSibling && currentSibling === nextSibling ? 'move-retain' : 'move';\n      logStep!('list-updates', [type, item.key]);\n    }\n  }\n\n  private deleteItem(opcode: ListItemOpcode) {\n    if (LOCAL_DEBUG) {\n      logStep!('list-updates', ['delete', opcode.key]);\n    }\n\n    destroy(opcode);\n    clear(opcode);\n    this.opcodeMap.delete(opcode.key);\n  }\n}\n\nclass UpdatingVMFrame {\n  private current = 0;\n\n  constructor(\n    private ops: UpdatingOpcode[],\n    private exceptionHandler: Nullable<ExceptionHandler>\n  ) {}\n\n  goto(index: number) {\n    this.current = index;\n  }\n\n  nextStatement(): UpdatingOpcode | undefined {\n    return this.ops[this.current++];\n  }\n\n  handleException() {\n    if (this.exceptionHandler) {\n      this.exceptionHandler.handleException();\n    }\n  }\n}\n","import type {\n  Environment,\n  LiveBlock,\n  RenderResult,\n  SimpleElement,\n  SimpleNode,\n  UpdatingOpcode,\n} from '@glimmer/interfaces';\nimport { associateDestroyableChild, registerDestructor } from '@glimmer/destroyable';\n\nimport { clear } from '../bounds';\nimport { UpdatingVM } from './update';\n\nexport default class RenderResultImpl implements RenderResult {\n  constructor(\n    public env: Environment,\n    private updating: UpdatingOpcode[],\n    private bounds: LiveBlock,\n    readonly drop: object\n  ) {\n    associateDestroyableChild(this, drop);\n    registerDestructor(this, () => clear(this.bounds));\n  }\n\n  rerender({ alwaysRevalidate = false } = { alwaysRevalidate: false }) {\n    let { env, updating } = this;\n    let vm = new UpdatingVM(env, { alwaysRevalidate });\n    vm.execute(updating, this);\n  }\n\n  parentElement(): SimpleElement {\n    return this.bounds.parentElement();\n  }\n\n  firstNode(): SimpleNode {\n    return this.bounds.firstNode();\n  }\n\n  lastNode(): SimpleNode {\n    return this.bounds.lastNode();\n  }\n\n  handleException() {\n    throw 'this should never happen';\n  }\n}\n","import type { MachineRegister } from '@glimmer/vm';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { $fp, $sp } from '@glimmer/vm';\n\nimport type { LowLevelRegisters } from './low-level';\n\nimport { REGISTERS } from '../symbols';\nimport { initializeRegistersWithSP } from './low-level';\n\nexport interface EvaluationStack {\n  [REGISTERS]: LowLevelRegisters;\n\n  push(value: unknown): void;\n  dup(position?: MachineRegister): void;\n  copy(from: number, to: number): void;\n  pop<T>(n?: number): T;\n  peek<T>(offset?: number): T;\n  get<T>(offset: number, base?: number): T;\n  set(value: unknown, offset: number, base?: number): void;\n  slice<T = unknown>(start: number, end: number): T[];\n  capture(items: number): unknown[];\n  reset(): void;\n  toArray(): unknown[];\n}\n\nexport default class EvaluationStackImpl implements EvaluationStack {\n  static restore(snapshot: unknown[]): EvaluationStackImpl {\n    return new this(snapshot.slice(), initializeRegistersWithSP(snapshot.length - 1));\n  }\n\n  readonly [REGISTERS]: LowLevelRegisters;\n\n  // fp -> sp\n  constructor(\n    private stack: unknown[] = [],\n    registers: LowLevelRegisters\n  ) {\n    this[REGISTERS] = registers;\n\n    if (LOCAL_DEBUG) {\n      Object.seal(this);\n    }\n  }\n\n  push(value: unknown): void {\n    this.stack[++this[REGISTERS][$sp]] = value;\n  }\n\n  dup(position = this[REGISTERS][$sp]): void {\n    this.stack[++this[REGISTERS][$sp]] = this.stack[position];\n  }\n\n  copy(from: number, to: number): void {\n    this.stack[to] = this.stack[from];\n  }\n\n  pop<T>(n = 1): T {\n    let top = this.stack[this[REGISTERS][$sp]] as T;\n    this[REGISTERS][$sp] -= n;\n    return top;\n  }\n\n  peek<T>(offset = 0): T {\n    return this.stack[this[REGISTERS][$sp] - offset] as T;\n  }\n\n  get<T>(offset: number, base = this[REGISTERS][$fp]): T {\n    return this.stack[base + offset] as T;\n  }\n\n  set(value: unknown, offset: number, base = this[REGISTERS][$fp]) {\n    this.stack[base + offset] = value;\n  }\n\n  slice<T = unknown>(start: number, end: number): T[] {\n    return this.stack.slice(start, end) as T[];\n  }\n\n  capture(items: number): unknown[] {\n    let end = this[REGISTERS][$sp] + 1;\n    let start = end - items;\n    return this.stack.slice(start, end);\n  }\n\n  reset() {\n    this.stack.length = 0;\n  }\n\n  toArray() {\n    return this.stack.slice(this[REGISTERS][$fp], this[REGISTERS][$sp] + 1);\n  }\n}\n","import type {\n  CompilableTemplate,\n  CompileTimeCompilationContext,\n  Destroyable,\n  DynamicScope,\n  ElementBuilder,\n  Environment,\n  Nullable,\n  Owner,\n  PartialScope,\n  RenderResult,\n  ResolutionTimeConstants,\n  RichIteratorResult,\n  RuntimeConstants,\n  RuntimeContext,\n  RuntimeHeap,\n  RuntimeProgram,\n  Scope,\n  UpdatingOpcode,\n  VM as PublicVM,\n} from '@glimmer/interfaces';\nimport type { RuntimeOpImpl } from '@glimmer/program';\nimport type { OpaqueIterationItem, OpaqueIterator, Reference } from '@glimmer/reference';\nimport type { MachineRegister, Register, SyscallRegister } from '@glimmer/vm';\nimport { associateDestroyableChild } from '@glimmer/destroyable';\nimport { assertGlobalContextWasSet } from '@glimmer/global-context';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { createIteratorItemRef, UNDEFINED_REFERENCE } from '@glimmer/reference';\nimport { assert, expect, LOCAL_LOGGER, reverse, Stack, unwrapHandle } from '@glimmer/util';\nimport { beginTrackFrame, endTrackFrame, resetTracking } from '@glimmer/validator';\nimport { $fp, $pc, $s0, $s1, $sp, $t0, $t1, $v0, isLowLevelRegister } from '@glimmer/vm';\n\nimport type { DebugState } from '../opcodes';\nimport type { LiveBlockList } from './element-builder';\nimport type { EvaluationStack } from './stack';\nimport type { BlockOpcode, ResumableVMState, VMState } from './update';\n\nimport {\n  BeginTrackFrameOpcode,\n  EndTrackFrameOpcode,\n  JumpIfNotModifiedOpcode,\n} from '../compiled/opcodes/vm';\nimport { APPEND_OPCODES } from '../opcodes';\nimport { PartialScopeImpl } from '../scope';\nimport { ARGS, CONSTANTS, DESTROYABLE_STACK, HEAP, INNER_VM, REGISTERS, STACKS } from '../symbols';\nimport { VMArgumentsImpl } from './arguments';\nimport { LowLevelVM } from './low-level';\nimport RenderResultImpl from './render-result';\nimport EvaluationStackImpl from './stack';\nimport { ListBlockOpcode, ListItemOpcode, ResumableVMStateImpl, TryOpcode } from './update';\n\n/**\n * This interface is used by internal opcodes, and is more stable than\n * the implementation of the Append VM itself.\n */\nexport interface InternalVM {\n  readonly [CONSTANTS]: RuntimeConstants & ResolutionTimeConstants;\n  readonly [ARGS]: VMArgumentsImpl;\n\n  readonly env: Environment;\n  readonly stack: EvaluationStack;\n  readonly runtime: RuntimeContext;\n  readonly context: CompileTimeCompilationContext;\n\n  loadValue(register: MachineRegister, value: number): void;\n  loadValue(register: Register, value: unknown): void;\n  loadValue(register: Register | MachineRegister, value: unknown): void;\n\n  fetchValue(register: MachineRegister.ra | MachineRegister.pc): number;\n  // TODO: Something better than a type assertion?\n  fetchValue<T>(register: Register): T;\n  fetchValue(register: Register): unknown;\n\n  load(register: Register): void;\n  fetch(register: Register): void;\n\n  compile(block: CompilableTemplate): number;\n\n  scope(): Scope;\n  elements(): ElementBuilder;\n\n  getOwner(): Owner;\n  getSelf(): Reference;\n\n  updateWith(opcode: UpdatingOpcode): void;\n\n  associateDestroyable(d: Destroyable): void;\n\n  beginCacheGroup(name?: string): void;\n  commitCacheGroup(): void;\n\n  /// Iteration ///\n\n  enterList(iterableRef: Reference<OpaqueIterator>, offset: number): void;\n  exitList(): void;\n  enterItem(item: OpaqueIterationItem): ListItemOpcode;\n  registerItem(item: ListItemOpcode): void;\n\n  pushRootScope(size: number, owner: Owner): PartialScope;\n  pushChildScope(): void;\n  popScope(): void;\n  pushScope(scope: Scope): void;\n\n  dynamicScope(): DynamicScope;\n  bindDynamicScope(names: string[]): void;\n  pushDynamicScope(): void;\n  popDynamicScope(): void;\n\n  enter(args: number): void;\n  exit(): void;\n\n  goto(pc: number): void;\n  call(handle: number): void;\n  pushFrame(): void;\n\n  referenceForSymbol(symbol: number): Reference;\n\n  execute(initialize?: (vm: this) => void): RenderResult;\n  pushUpdating(list?: UpdatingOpcode[]): void;\n  next(): RichIteratorResult<null, RenderResult>;\n}\n\nclass Stacks {\n  readonly scope = new Stack<Scope>();\n  readonly dynamicScope = new Stack<DynamicScope>();\n  readonly updating = new Stack<UpdatingOpcode[]>();\n  readonly cache = new Stack<JumpIfNotModifiedOpcode>();\n  readonly list = new Stack<ListBlockOpcode>();\n}\n\nexport class VM implements PublicVM, InternalVM {\n  private readonly [STACKS] = new Stacks();\n  private readonly [HEAP]: RuntimeHeap;\n  private readonly destructor: object;\n  private readonly [DESTROYABLE_STACK] = new Stack<object>();\n  readonly [CONSTANTS]: RuntimeConstants & ResolutionTimeConstants;\n  readonly [ARGS]: VMArgumentsImpl;\n  readonly [INNER_VM]: LowLevelVM;\n\n  get stack(): EvaluationStack {\n    return this[INNER_VM].stack as EvaluationStack;\n  }\n\n  /* Registers */\n\n  get pc(): number {\n    return this[INNER_VM].fetchRegister($pc);\n  }\n\n  public s0: unknown = null;\n  public s1: unknown = null;\n  public t0: unknown = null;\n  public t1: unknown = null;\n  public v0: unknown = null;\n\n  // Fetch a value from a register onto the stack\n  fetch(register: SyscallRegister): void {\n    let value = this.fetchValue(register);\n\n    this.stack.push(value);\n  }\n\n  // Load a value from the stack into a register\n  load(register: SyscallRegister) {\n    let value = this.stack.pop();\n\n    this.loadValue(register, value);\n  }\n\n  // Fetch a value from a register\n  fetchValue(register: MachineRegister): number;\n  fetchValue<T>(register: Register): T;\n  fetchValue(register: Register | MachineRegister): unknown {\n    if (isLowLevelRegister(register)) {\n      return this[INNER_VM].fetchRegister(register);\n    }\n\n    switch (register) {\n      case $s0:\n        return this.s0;\n      case $s1:\n        return this.s1;\n      case $t0:\n        return this.t0;\n      case $t1:\n        return this.t1;\n      case $v0:\n        return this.v0;\n    }\n  }\n\n  // Load a value into a register\n\n  loadValue<T>(register: Register | MachineRegister, value: T): void {\n    if (isLowLevelRegister(register)) {\n      this[INNER_VM].loadRegister(register, value as any as number);\n    }\n\n    switch (register) {\n      case $s0:\n        this.s0 = value;\n        break;\n      case $s1:\n        this.s1 = value;\n        break;\n      case $t0:\n        this.t0 = value;\n        break;\n      case $t1:\n        this.t1 = value;\n        break;\n      case $v0:\n        this.v0 = value;\n        break;\n    }\n  }\n\n  /**\n   * Migrated to Inner\n   */\n\n  // Start a new frame and save $ra and $fp on the stack\n  pushFrame() {\n    this[INNER_VM].pushFrame();\n  }\n\n  // Restore $ra, $sp and $fp\n  popFrame() {\n    this[INNER_VM].popFrame();\n  }\n\n  // Jump to an address in `program`\n  goto(offset: number) {\n    this[INNER_VM].goto(offset);\n  }\n\n  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n  call(handle: number) {\n    this[INNER_VM].call(handle);\n  }\n\n  // Put a specific `program` address in $ra\n  returnTo(offset: number) {\n    this[INNER_VM].returnTo(offset);\n  }\n\n  // Return to the `program` address stored in $ra\n  return() {\n    this[INNER_VM].return();\n  }\n\n  /**\n   * End of migrated.\n   */\n\n  constructor(\n    readonly runtime: RuntimeContext,\n    { pc, scope, dynamicScope, stack }: VMState,\n    private readonly elementStack: ElementBuilder,\n    readonly context: CompileTimeCompilationContext\n  ) {\n    if (import.meta.env.DEV) {\n      assertGlobalContextWasSet!();\n    }\n\n    this.resume = initVM(context);\n    let evalStack = EvaluationStackImpl.restore(stack);\n\n    assert(typeof pc === 'number', 'pc is a number');\n\n    evalStack[REGISTERS][$pc] = pc;\n    evalStack[REGISTERS][$sp] = stack.length - 1;\n    evalStack[REGISTERS][$fp] = -1;\n\n    this[HEAP] = this.program.heap;\n    this[CONSTANTS] = this.program.constants;\n    this.elementStack = elementStack;\n    this[STACKS].scope.push(scope);\n    this[STACKS].dynamicScope.push(dynamicScope);\n    this[ARGS] = new VMArgumentsImpl();\n    this[INNER_VM] = new LowLevelVM(\n      evalStack,\n      this[HEAP],\n      runtime.program,\n      {\n        debugBefore: (opcode: RuntimeOpImpl): DebugState => {\n          return APPEND_OPCODES.debugBefore(this, opcode);\n        },\n\n        debugAfter: (state: DebugState): void => {\n          APPEND_OPCODES.debugAfter(this, state);\n        },\n      },\n      evalStack[REGISTERS]\n    );\n\n    this.destructor = {};\n    this[DESTROYABLE_STACK].push(this.destructor);\n  }\n\n  static initial(\n    runtime: RuntimeContext,\n    context: CompileTimeCompilationContext,\n    { handle, self, dynamicScope, treeBuilder, numSymbols, owner }: InitOptions\n  ) {\n    let scope = PartialScopeImpl.root(self, numSymbols, owner);\n    let state = vmState(runtime.program.heap.getaddr(handle), scope, dynamicScope);\n    let vm = initVM(context)(runtime, state, treeBuilder);\n    vm.pushUpdating();\n    return vm;\n  }\n\n  static empty(\n    runtime: RuntimeContext,\n    { handle, treeBuilder, dynamicScope, owner }: MinimalInitOptions,\n    context: CompileTimeCompilationContext\n  ) {\n    let vm = initVM(context)(\n      runtime,\n      vmState(\n        runtime.program.heap.getaddr(handle),\n        PartialScopeImpl.root(UNDEFINED_REFERENCE, 0, owner),\n        dynamicScope\n      ),\n      treeBuilder\n    );\n    vm.pushUpdating();\n    return vm;\n  }\n\n  private resume: VmInitCallback;\n\n  compile(block: CompilableTemplate): number {\n    let handle = unwrapHandle(block.compile(this.context));\n\n    return handle;\n  }\n\n  get program(): RuntimeProgram {\n    return this.runtime.program;\n  }\n\n  get env(): Environment {\n    return this.runtime.env;\n  }\n\n  captureState(args: number, pc = this[INNER_VM].fetchRegister($pc)): VMState {\n    return {\n      pc,\n      scope: this.scope(),\n      dynamicScope: this.dynamicScope(),\n      stack: this.stack.capture(args),\n    };\n  }\n\n  capture(args: number, pc = this[INNER_VM].fetchRegister($pc)): ResumableVMState {\n    return new ResumableVMStateImpl(this.captureState(args, pc), this.resume);\n  }\n\n  beginCacheGroup(name?: string) {\n    let opcodes = this.updating();\n    let guard = new JumpIfNotModifiedOpcode();\n\n    opcodes.push(guard);\n    opcodes.push(new BeginTrackFrameOpcode(name));\n    this[STACKS].cache.push(guard);\n\n    beginTrackFrame(name);\n  }\n\n  commitCacheGroup() {\n    let opcodes = this.updating();\n    let guard = expect(this[STACKS].cache.pop(), 'VM BUG: Expected a cache group');\n\n    let tag = endTrackFrame();\n    opcodes.push(new EndTrackFrameOpcode(guard));\n\n    guard.finalize(tag, opcodes.length);\n  }\n\n  enter(args: number) {\n    let updating: UpdatingOpcode[] = [];\n\n    let state = this.capture(args);\n    let block = this.elements().pushUpdatableBlock();\n\n    let tryOpcode = new TryOpcode(state, this.runtime, block, updating);\n\n    this.didEnter(tryOpcode);\n  }\n\n  enterItem({ key, value, memo }: OpaqueIterationItem): ListItemOpcode {\n    let { stack } = this;\n\n    let valueRef = createIteratorItemRef(value);\n    let memoRef = createIteratorItemRef(memo);\n\n    stack.push(valueRef);\n    stack.push(memoRef);\n\n    let state = this.capture(2);\n    let block = this.elements().pushUpdatableBlock();\n\n    let opcode = new ListItemOpcode(state, this.runtime, block, key, memoRef, valueRef);\n    this.didEnter(opcode);\n\n    return opcode;\n  }\n\n  registerItem(opcode: ListItemOpcode) {\n    this.listBlock().initializeChild(opcode);\n  }\n\n  enterList(iterableRef: Reference<OpaqueIterator>, offset: number) {\n    let updating: ListItemOpcode[] = [];\n\n    let addr = this[INNER_VM].target(offset);\n    let state = this.capture(0, addr);\n    let list = this.elements().pushBlockList(updating) as LiveBlockList;\n\n    let opcode = new ListBlockOpcode(state, this.runtime, list, updating, iterableRef);\n\n    this[STACKS].list.push(opcode);\n\n    this.didEnter(opcode);\n  }\n\n  private didEnter(opcode: BlockOpcode) {\n    this.associateDestroyable(opcode);\n    this[DESTROYABLE_STACK].push(opcode);\n    this.updateWith(opcode);\n    this.pushUpdating(opcode.children);\n  }\n\n  exit() {\n    this[DESTROYABLE_STACK].pop();\n    this.elements().popBlock();\n    this.popUpdating();\n  }\n\n  exitList() {\n    this.exit();\n    this[STACKS].list.pop();\n  }\n\n  pushUpdating(list: UpdatingOpcode[] = []): void {\n    this[STACKS].updating.push(list);\n  }\n\n  popUpdating(): UpdatingOpcode[] {\n    return expect(this[STACKS].updating.pop(), \"can't pop an empty stack\");\n  }\n\n  updateWith(opcode: UpdatingOpcode) {\n    this.updating().push(opcode);\n  }\n\n  listBlock(): ListBlockOpcode {\n    return expect(this[STACKS].list.current, 'expected a list block');\n  }\n\n  associateDestroyable(child: Destroyable): void {\n    let parent = expect(this[DESTROYABLE_STACK].current, 'Expected destructor parent');\n    associateDestroyableChild(parent, child);\n  }\n\n  tryUpdating(): Nullable<UpdatingOpcode[]> {\n    return this[STACKS].updating.current;\n  }\n\n  updating(): UpdatingOpcode[] {\n    return expect(\n      this[STACKS].updating.current,\n      'expected updating opcode on the updating opcode stack'\n    );\n  }\n\n  elements(): ElementBuilder {\n    return this.elementStack;\n  }\n\n  scope(): Scope {\n    return expect(this[STACKS].scope.current, 'expected scope on the scope stack');\n  }\n\n  dynamicScope(): DynamicScope {\n    return expect(\n      this[STACKS].dynamicScope.current,\n      'expected dynamic scope on the dynamic scope stack'\n    );\n  }\n\n  pushChildScope() {\n    this[STACKS].scope.push(this.scope().child());\n  }\n\n  pushDynamicScope(): DynamicScope {\n    let child = this.dynamicScope().child();\n    this[STACKS].dynamicScope.push(child);\n    return child;\n  }\n\n  pushRootScope(size: number, owner: Owner): PartialScope {\n    let scope = PartialScopeImpl.sized(size, owner);\n    this[STACKS].scope.push(scope);\n    return scope;\n  }\n\n  pushScope(scope: Scope) {\n    this[STACKS].scope.push(scope);\n  }\n\n  popScope() {\n    this[STACKS].scope.pop();\n  }\n\n  popDynamicScope() {\n    this[STACKS].dynamicScope.pop();\n  }\n\n  /// SCOPE HELPERS\n\n  getOwner(): Owner {\n    return this.scope().owner;\n  }\n\n  getSelf(): Reference<any> {\n    return this.scope().getSelf();\n  }\n\n  referenceForSymbol(symbol: number): Reference {\n    return this.scope().getSymbol(symbol);\n  }\n\n  /// EXECUTION\n\n  execute(initialize?: (vm: this) => void): RenderResult {\n    if (import.meta.env.DEV) {\n      let hasErrored = true;\n      try {\n        let value = this._execute(initialize);\n\n        // using a boolean here to avoid breaking ergonomics of \"pause on uncaught exceptions\"\n        // which would happen with a `catch` + `throw`\n        hasErrored = false;\n\n        return value;\n      } finally {\n        if (hasErrored) {\n          // If any existing blocks are open, due to an error or something like\n          // that, we need to close them all and clean things up properly.\n          let elements = this.elements();\n\n          while (elements.hasBlocks) {\n            elements.popBlock();\n          }\n\n          // eslint-disable-next-line no-console\n          console.error(`\\n\\nError occurred:\\n\\n${resetTracking()}\\n\\n`);\n        }\n      }\n    } else {\n      return this._execute(initialize);\n    }\n  }\n\n  private _execute(initialize?: (vm: this) => void): RenderResult {\n    if (LOCAL_SHOULD_LOG) {\n      LOCAL_LOGGER.log(`EXECUTING FROM ${this[INNER_VM].fetchRegister($pc)}`);\n    }\n\n    if (initialize) initialize(this);\n\n    let result: RichIteratorResult<null, RenderResult>;\n\n    do result = this.next();\n    while (!result.done);\n\n    return result.value;\n  }\n\n  next(): RichIteratorResult<null, RenderResult> {\n    let { env, elementStack } = this;\n    let opcode = this[INNER_VM].nextStatement();\n    let result: RichIteratorResult<null, RenderResult>;\n    if (opcode !== null) {\n      this[INNER_VM].evaluateOuter(opcode, this);\n      result = { done: false, value: null };\n    } else {\n      // Unload the stack\n      this.stack.reset();\n\n      result = {\n        done: true,\n        value: new RenderResultImpl(\n          env,\n          this.popUpdating(),\n          elementStack.popBlock(),\n          this.destructor\n        ),\n      };\n    }\n    return result;\n  }\n\n  bindDynamicScope(names: string[]) {\n    let scope = this.dynamicScope();\n\n    for (const name of reverse(names)) {\n      scope.set(name, this.stack.pop<Reference<unknown>>());\n    }\n  }\n}\n\nfunction vmState(pc: number, scope: Scope, dynamicScope: DynamicScope) {\n  return {\n    pc,\n    scope,\n    dynamicScope,\n    stack: [],\n  };\n}\n\nexport interface MinimalInitOptions {\n  handle: number;\n  treeBuilder: ElementBuilder;\n  dynamicScope: DynamicScope;\n  owner: Owner;\n}\n\nexport interface InitOptions extends MinimalInitOptions {\n  self: Reference;\n  numSymbols: number;\n}\n\nexport type VmInitCallback = (\n  this: void,\n  runtime: RuntimeContext,\n  state: VMState,\n  builder: ElementBuilder\n) => InternalVM;\n\nfunction initVM(context: CompileTimeCompilationContext): VmInitCallback {\n  return (runtime, state, builder) => new VM(runtime, state, builder, context);\n}\n","import type {\n  CompilableProgram,\n  CompileTimeCompilationContext,\n  ComponentDefinitionState,\n  DynamicScope,\n  ElementBuilder,\n  Environment,\n  Owner,\n  RenderResult,\n  RichIteratorResult,\n  RuntimeContext,\n  TemplateIterator,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { childRefFor, createConstRef } from '@glimmer/reference';\nimport { expect, unwrapHandle } from '@glimmer/util';\nimport { debug } from '@glimmer/validator';\n\nimport type { InternalVM } from './vm/append';\n\nimport { inTransaction } from './environment';\nimport { DynamicScopeImpl } from './scope';\nimport { ARGS, CONSTANTS } from './symbols';\nimport { VM } from './vm/append';\n\nclass TemplateIteratorImpl implements TemplateIterator {\n  constructor(private vm: InternalVM) {}\n  next(): RichIteratorResult<null, RenderResult> {\n    return this.vm.next();\n  }\n\n  sync(): RenderResult {\n    if (import.meta.env.DEV) {\n      return debug.runInTrackingTransaction!(() => this.vm.execute(), '- While rendering:');\n    } else {\n      return this.vm.execute();\n    }\n  }\n}\n\nexport function renderSync(env: Environment, iterator: TemplateIterator): RenderResult {\n  let result: RenderResult;\n\n  inTransaction(env, () => (result = iterator.sync()));\n\n  return result!;\n}\n\nexport function renderMain(\n  runtime: RuntimeContext,\n  context: CompileTimeCompilationContext,\n  owner: Owner,\n  self: Reference,\n  treeBuilder: ElementBuilder,\n  layout: CompilableProgram,\n  dynamicScope: DynamicScope = new DynamicScopeImpl()\n): TemplateIterator {\n  let handle = unwrapHandle(layout.compile(context));\n  let numSymbols = layout.symbolTable.symbols.length;\n  let vm = VM.initial(runtime, context, {\n    self,\n    dynamicScope,\n    treeBuilder,\n    handle,\n    numSymbols,\n    owner,\n  });\n  return new TemplateIteratorImpl(vm);\n}\n\nfunction renderInvocation(\n  vm: InternalVM,\n  context: CompileTimeCompilationContext,\n  owner: Owner,\n  definition: ComponentDefinitionState,\n  args: Record<string, Reference>\n): TemplateIterator {\n  // Get a list of tuples of argument names and references, like\n  // [['title', reference], ['name', reference]]\n  const argList = Object.keys(args).map((key) => [key, args[key]] as const);\n\n  const blockNames = ['main', 'else', 'attrs'];\n  // Prefix argument names with `@` symbol\n  const argNames = argList.map(([name]) => `@${name}`);\n\n  let reified = vm[CONSTANTS].component(definition, owner);\n\n  vm.pushFrame();\n\n  // Push blocks on to the stack, three stack values per block\n  for (let i = 0; i < 3 * blockNames.length; i++) {\n    vm.stack.push(null);\n  }\n\n  vm.stack.push(null);\n\n  // For each argument, push its backing reference on to the stack\n  argList.forEach(([, reference]) => {\n    vm.stack.push(reference);\n  });\n\n  // Configure VM based on blocks and args just pushed on to the stack.\n  vm[ARGS].setup(vm.stack, argNames, blockNames, 0, true);\n\n  const compilable = expect(\n    reified.compilable,\n    'BUG: Expected the root component rendered with renderComponent to have an associated template, set with setComponentTemplate'\n  );\n  const layoutHandle = unwrapHandle(compilable.compile(context));\n  const invocation = { handle: layoutHandle, symbolTable: compilable.symbolTable };\n\n  // Needed for the Op.Main opcode: arguments, component invocation object, and\n  // component definition.\n  vm.stack.push(vm[ARGS]);\n  vm.stack.push(invocation);\n  vm.stack.push(reified);\n\n  return new TemplateIteratorImpl(vm);\n}\n\nexport function renderComponent(\n  runtime: RuntimeContext,\n  treeBuilder: ElementBuilder,\n  context: CompileTimeCompilationContext,\n  owner: Owner,\n  definition: ComponentDefinitionState,\n  args: Record<string, unknown> = {},\n  dynamicScope: DynamicScope = new DynamicScopeImpl()\n): TemplateIterator {\n  let vm = VM.empty(\n    runtime,\n    { treeBuilder, handle: context.stdlib.main, dynamicScope, owner },\n    context\n  );\n  return renderInvocation(vm, context, owner, definition, recordToReference(args));\n}\n\nfunction recordToReference(record: Record<string, unknown>): Record<string, Reference> {\n  const root = createConstRef(record, 'args');\n\n  return Object.keys(record).reduce(\n    (acc, key) => {\n      acc[key] = childRefFor(root, key);\n      return acc;\n    },\n    {} as Record<string, Reference>\n  );\n}\n","import type {\n  AttrNamespace,\n  Bounds,\n  ElementBuilder,\n  Environment,\n  Maybe,\n  Nullable,\n  SimpleAttr,\n  SimpleComment,\n  SimpleElement,\n  SimpleNode,\n  SimpleText,\n} from '@glimmer/interfaces';\nimport type { Stack } from '@glimmer/util';\nimport { assert, castToBrowser, castToSimple, COMMENT_NODE, expect, NS_SVG } from '@glimmer/util';\n\nimport { ConcreteBounds, CursorImpl } from '../bounds';\nimport { CURSOR_STACK, NewElementBuilder, RemoteLiveBlock } from './element-builder';\n\nexport const SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';\n\nexport function isSerializationFirstNode(node: SimpleNode): boolean {\n  return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;\n}\n\nexport class RehydratingCursor extends CursorImpl {\n  candidate: Nullable<SimpleNode> = null;\n  openBlockDepth: number;\n  injectedOmittedNode = false;\n  constructor(\n    element: SimpleElement,\n    nextSibling: Nullable<SimpleNode>,\n    public readonly startingBlockDepth: number\n  ) {\n    super(element, nextSibling);\n    this.openBlockDepth = startingBlockDepth - 1;\n  }\n}\n\nexport class RehydrateBuilder extends NewElementBuilder implements ElementBuilder {\n  private unmatchedAttributes: Nullable<SimpleAttr[]> = null;\n  declare [CURSOR_STACK]: Stack<RehydratingCursor>; // Hides property on base class\n  blockDepth = 0;\n  startingBlockOffset: number;\n\n  constructor(env: Environment, parentNode: SimpleElement, nextSibling: Nullable<SimpleNode>) {\n    super(env, parentNode, nextSibling);\n    if (nextSibling) throw new Error('Rehydration with nextSibling not supported');\n\n    let node = this.currentCursor!.element.firstChild;\n\n    while (node !== null) {\n      if (isOpenBlock(node)) {\n        break;\n      }\n      node = node.nextSibling;\n    }\n\n    assert(node, 'Must have opening comment for rehydration.');\n    this.candidate = node;\n    const startingBlockOffset = getBlockDepth(node);\n    if (startingBlockOffset !== 0) {\n      // We are rehydrating from a partial tree and not the root component\n      // We need to add an extra block before the first block to rehydrate correctly\n      // The extra block is needed since the renderComponent API creates a synthetic component invocation which generates the extra block\n      const newBlockDepth = startingBlockOffset - 1;\n      const newCandidate = this.dom.createComment(`%+b:${newBlockDepth}%`);\n\n      node.parentNode!.insertBefore(newCandidate, this.candidate);\n      let closingNode = node.nextSibling;\n      while (closingNode !== null) {\n        if (isCloseBlock(closingNode) && getBlockDepth(closingNode) === startingBlockOffset) {\n          break;\n        }\n        closingNode = closingNode.nextSibling;\n      }\n\n      assert(closingNode, 'Must have closing comment for starting block comment');\n      const newClosingBlock = this.dom.createComment(`%-b:${newBlockDepth}%`);\n      node.parentNode!.insertBefore(newClosingBlock, closingNode.nextSibling);\n      this.candidate = newCandidate;\n      this.startingBlockOffset = newBlockDepth;\n    } else {\n      this.startingBlockOffset = 0;\n    }\n  }\n\n  get currentCursor(): Nullable<RehydratingCursor> {\n    return this[CURSOR_STACK].current;\n  }\n\n  get candidate(): Nullable<SimpleNode> {\n    if (this.currentCursor) {\n      return this.currentCursor.candidate!;\n    }\n\n    return null;\n  }\n\n  set candidate(node: Nullable<SimpleNode>) {\n    const currentCursor = this.currentCursor!;\n\n    currentCursor.candidate = node;\n  }\n\n  disableRehydration(nextSibling: Nullable<SimpleNode>) {\n    const currentCursor = this.currentCursor!;\n\n    // rehydration will be disabled until we either:\n    // * hit popElement (and return to using the parent elements cursor)\n    // * hit closeBlock and the next sibling is a close block comment\n    //   matching the expected openBlockDepth\n    currentCursor.candidate = null;\n    currentCursor.nextSibling = nextSibling;\n  }\n\n  enableRehydration(candidate: Nullable<SimpleNode>) {\n    const currentCursor = this.currentCursor!;\n\n    currentCursor.candidate = candidate;\n    currentCursor.nextSibling = null;\n  }\n\n  override pushElement(\n    /** called from parent constructor before we initialize this */\n    this:\n      | RehydrateBuilder\n      | (NewElementBuilder & Partial<Pick<RehydrateBuilder, 'blockDepth' | 'candidate'>>),\n    element: SimpleElement,\n    nextSibling: Maybe<SimpleNode> = null\n  ) {\n    const cursor = new RehydratingCursor(element, nextSibling, this.blockDepth || 0);\n\n    /**\n     * <div>   <---------------  currentCursor.element\n     *   <!--%+b:1%--> <-------  would have been removed during openBlock\n     *   <div> <---------------  currentCursor.candidate -> cursor.element\n     *     <!--%+b:2%--> <-----  currentCursor.candidate.firstChild -> cursor.candidate\n     *     Foo\n     *     <!--%-b:2%-->\n     *   </div>\n     *   <!--%-b:1%-->  <------  becomes currentCursor.candidate\n     */\n    if (this.candidate !== null) {\n      cursor.candidate = element.firstChild;\n      this.candidate = element.nextSibling;\n    }\n\n    this[CURSOR_STACK].push(cursor);\n  }\n\n  // clears until the end of the current container\n  // either the current open block or higher\n  private clearMismatch(candidate: SimpleNode) {\n    let current: Nullable<SimpleNode> = candidate;\n    const currentCursor = this.currentCursor;\n    if (currentCursor !== null) {\n      const openBlockDepth = currentCursor.openBlockDepth;\n      if (openBlockDepth >= currentCursor.startingBlockDepth) {\n        while (current) {\n          if (isCloseBlock(current)) {\n            const closeBlockDepth = getBlockDepthWithOffset(current, this.startingBlockOffset);\n            if (openBlockDepth >= closeBlockDepth) {\n              break;\n            }\n          }\n          current = this.remove(current);\n        }\n      } else {\n        while (current !== null) {\n          current = this.remove(current);\n        }\n      }\n      // current cursor parentNode should be openCandidate if element\n      // or openCandidate.parentNode if comment\n      this.disableRehydration(current);\n    }\n  }\n\n  override __openBlock(): void {\n    const { currentCursor } = this;\n    if (currentCursor === null) return;\n\n    const blockDepth = this.blockDepth;\n\n    this.blockDepth++;\n\n    const { candidate } = currentCursor;\n    if (candidate === null) return;\n\n    const { tagName } = currentCursor.element;\n\n    if (\n      isOpenBlock(candidate) &&\n      getBlockDepthWithOffset(candidate, this.startingBlockOffset) === blockDepth\n    ) {\n      this.candidate = this.remove(candidate);\n      currentCursor.openBlockDepth = blockDepth;\n    } else if (tagName !== 'TITLE' && tagName !== 'SCRIPT' && tagName !== 'STYLE') {\n      this.clearMismatch(candidate);\n    }\n  }\n\n  override __closeBlock(): void {\n    const { currentCursor } = this;\n    if (currentCursor === null) return;\n\n    // openBlock is the last rehydrated open block\n    const openBlockDepth = currentCursor.openBlockDepth;\n\n    // this currently is the expected next open block depth\n    this.blockDepth--;\n\n    const { candidate } = currentCursor;\n\n    let isRehydrating = false;\n\n    if (candidate !== null) {\n      isRehydrating = true;\n      //assert(\n      //  openBlockDepth === this.blockDepth,\n      //  'when rehydrating, openBlockDepth should match this.blockDepth here'\n      //);\n\n      if (\n        isCloseBlock(candidate) &&\n        getBlockDepthWithOffset(candidate, this.startingBlockOffset) === openBlockDepth\n      ) {\n        const nextSibling = this.remove(candidate);\n        this.candidate = nextSibling;\n        currentCursor.openBlockDepth--;\n      } else {\n        // close the block and clear mismatch in parent container\n        // we will be either at the end of the element\n        // or at the end of our containing block\n        this.clearMismatch(candidate);\n        isRehydrating = false;\n      }\n    }\n\n    if (isRehydrating === false) {\n      // check if nextSibling matches our expected close block\n      // if so, we remove the close block comment and\n      // restore rehydration after clearMismatch disabled\n      const nextSibling = currentCursor.nextSibling;\n      if (\n        nextSibling !== null &&\n        isCloseBlock(nextSibling) &&\n        getBlockDepthWithOffset(nextSibling, this.startingBlockOffset) === this.blockDepth\n      ) {\n        // restore rehydration state\n        const candidate = this.remove(nextSibling);\n        this.enableRehydration(candidate);\n\n        currentCursor.openBlockDepth--;\n      }\n    }\n  }\n\n  override __appendNode(node: SimpleNode): SimpleNode {\n    const { candidate } = this;\n\n    // This code path is only used when inserting precisely one node. It needs more\n    // comparison logic, but we can probably lean on the cases where this code path\n    // is actually used.\n    if (candidate) {\n      return candidate;\n    } else {\n      return super.__appendNode(node);\n    }\n  }\n\n  override __appendHTML(html: string): Bounds {\n    const candidateBounds = this.markerBounds();\n\n    if (candidateBounds) {\n      const first = candidateBounds.firstNode()!;\n      const last = candidateBounds.lastNode()!;\n\n      const newBounds = new ConcreteBounds(this.element, first.nextSibling!, last.previousSibling!);\n\n      const possibleEmptyMarker = this.remove(first);\n      this.remove(last);\n\n      if (possibleEmptyMarker !== null && isEmpty(possibleEmptyMarker)) {\n        this.candidate = this.remove(possibleEmptyMarker);\n\n        if (this.candidate !== null) {\n          this.clearMismatch(this.candidate);\n        }\n      }\n\n      return newBounds;\n    } else {\n      return super.__appendHTML(html);\n    }\n  }\n\n  protected remove(node: SimpleNode): Nullable<SimpleNode> {\n    const element = expect(node.parentNode, `cannot remove a detached node`) as SimpleElement;\n    const next = node.nextSibling;\n    element.removeChild(node);\n    return next;\n  }\n\n  private markerBounds(): Nullable<Bounds> {\n    const _candidate = this.candidate;\n\n    if (_candidate && isMarker(_candidate)) {\n      const first = _candidate;\n      let last = expect(first.nextSibling, `BUG: serialization markers must be paired`);\n\n      while (last && !isMarker(last)) {\n        last = expect(last.nextSibling, `BUG: serialization markers must be paired`);\n      }\n\n      return new ConcreteBounds(this.element, first, last);\n    } else {\n      return null;\n    }\n  }\n\n  override __appendText(string: string): SimpleText {\n    const { candidate } = this;\n\n    if (candidate) {\n      if (isTextNode(candidate)) {\n        if (candidate.nodeValue !== string) {\n          candidate.nodeValue = string;\n        }\n        this.candidate = candidate.nextSibling;\n\n        return candidate;\n      } else if (isSeparator(candidate)) {\n        this.candidate = this.remove(candidate);\n\n        return this.__appendText(string);\n      } else if (isEmpty(candidate) && string === '') {\n        this.candidate = this.remove(candidate);\n\n        return this.__appendText(string);\n      } else {\n        this.clearMismatch(candidate);\n\n        return super.__appendText(string);\n      }\n    } else {\n      return super.__appendText(string);\n    }\n  }\n\n  override __appendComment(string: string): SimpleComment {\n    const _candidate = this.candidate;\n    if (_candidate && isComment(_candidate)) {\n      if (_candidate.nodeValue !== string) {\n        _candidate.nodeValue = string;\n      }\n\n      this.candidate = _candidate.nextSibling;\n      return _candidate;\n    } else if (_candidate) {\n      this.clearMismatch(_candidate);\n    }\n\n    return super.__appendComment(string);\n  }\n\n  override __openElement(tag: string): SimpleElement {\n    const _candidate = this.candidate;\n\n    if (_candidate && isElement(_candidate) && isSameNodeType(_candidate, tag)) {\n      this.unmatchedAttributes = [].slice.call(_candidate.attributes);\n      return _candidate;\n    } else if (_candidate) {\n      if (isElement(_candidate) && _candidate.tagName === 'TBODY') {\n        this.pushElement(_candidate, null);\n        this.currentCursor!.injectedOmittedNode = true;\n        return this.__openElement(tag);\n      }\n      this.clearMismatch(_candidate);\n    }\n\n    return super.__openElement(tag);\n  }\n\n  override __setAttribute(name: string, value: string, namespace: Nullable<AttrNamespace>): void {\n    const unmatched = this.unmatchedAttributes;\n\n    if (unmatched) {\n      const attr = findByName(unmatched, name);\n      if (attr) {\n        if (attr.value !== value) {\n          attr.value = value;\n        }\n        unmatched.splice(unmatched.indexOf(attr), 1);\n        return;\n      }\n    }\n\n    return super.__setAttribute(name, value, namespace);\n  }\n\n  override __setProperty(name: string, value: string): void {\n    const unmatched = this.unmatchedAttributes;\n\n    if (unmatched) {\n      const attr = findByName(unmatched, name);\n      if (attr) {\n        if (attr.value !== value) {\n          attr.value = value;\n        }\n        unmatched.splice(unmatched.indexOf(attr), 1);\n        return;\n      }\n    }\n\n    return super.__setProperty(name, value);\n  }\n\n  override __flushElement(parent: SimpleElement, constructing: SimpleElement): void {\n    const { unmatchedAttributes: unmatched } = this;\n    if (unmatched) {\n      for (const attr of unmatched) {\n        this.constructing!.removeAttribute(attr.name);\n      }\n      this.unmatchedAttributes = null;\n    } else {\n      super.__flushElement(parent, constructing);\n    }\n  }\n\n  override willCloseElement() {\n    const { candidate, currentCursor } = this;\n\n    if (candidate !== null) {\n      this.clearMismatch(candidate);\n    }\n\n    if (currentCursor && currentCursor.injectedOmittedNode) {\n      this.popElement();\n    }\n\n    super.willCloseElement();\n  }\n\n  getMarker(element: HTMLElement, guid: string): Nullable<SimpleNode> {\n    const marker = element.querySelector(`script[glmr=\"${guid}\"]`);\n    if (marker) {\n      return castToSimple(marker);\n    }\n    return null;\n  }\n\n  override __pushRemoteElement(\n    element: SimpleElement,\n    cursorId: string,\n    insertBefore: Maybe<SimpleNode>\n  ): RemoteLiveBlock {\n    const marker = this.getMarker(castToBrowser(element, 'HTML'), cursorId);\n\n    assert(\n      !marker || marker.parentNode === element,\n      `expected remote element marker's parent node to match remote element`\n    );\n\n    // when insertBefore is not present, we clear the element\n    if (insertBefore === undefined) {\n      while (element.firstChild !== null && element.firstChild !== marker) {\n        this.remove(element.firstChild);\n      }\n      insertBefore = null;\n    }\n\n    const cursor = new RehydratingCursor(element, null, this.blockDepth);\n    this[CURSOR_STACK].push(cursor);\n\n    if (marker === null) {\n      this.disableRehydration(insertBefore);\n    } else {\n      this.candidate = this.remove(marker);\n    }\n\n    const block = new RemoteLiveBlock(element);\n    return this.pushLiveBlock(block, true);\n  }\n\n  override didAppendBounds(bounds: Bounds): Bounds {\n    super.didAppendBounds(bounds);\n    if (this.candidate) {\n      const last = bounds.lastNode();\n      this.candidate = last && last.nextSibling;\n    }\n    return bounds;\n  }\n}\n\nfunction isTextNode(node: SimpleNode): node is SimpleText {\n  return node.nodeType === 3;\n}\n\nfunction isComment(node: SimpleNode): node is SimpleComment {\n  return node.nodeType === 8;\n}\n\nfunction isOpenBlock(node: SimpleNode): node is SimpleComment {\n  return node.nodeType === COMMENT_NODE && node.nodeValue.lastIndexOf('%+b:', 0) === 0;\n}\n\nfunction isCloseBlock(node: SimpleNode): node is SimpleComment {\n  return node.nodeType === COMMENT_NODE && node.nodeValue.lastIndexOf('%-b:', 0) === 0;\n}\n\nfunction getBlockDepth(node: SimpleComment): number {\n  return parseInt(node.nodeValue.slice(4), 10);\n}\n\nfunction getBlockDepthWithOffset(node: SimpleComment, offset: number): number {\n  return getBlockDepth(node) - offset;\n}\n\nfunction isElement(node: SimpleNode): node is SimpleElement {\n  return node.nodeType === 1;\n}\n\nfunction isMarker(node: SimpleNode): boolean {\n  return node.nodeType === 8 && node.nodeValue === '%glmr%';\n}\n\nfunction isSeparator(node: SimpleNode): boolean {\n  return node.nodeType === 8 && node.nodeValue === '%|%';\n}\n\nfunction isEmpty(node: SimpleNode): boolean {\n  return node.nodeType === 8 && node.nodeValue === '% %';\n}\n\nfunction isSameNodeType(candidate: SimpleElement, tag: string) {\n  if (candidate.namespaceURI === NS_SVG) {\n    return candidate.tagName === tag;\n  }\n  return candidate.tagName === tag.toUpperCase();\n}\n\nfunction findByName(array: SimpleAttr[], name: string): SimpleAttr | undefined {\n  for (const attr of array) {\n    if (attr.name === name) return attr;\n  }\n\n  return undefined;\n}\n\nexport function rehydrationBuilder(env: Environment, cursor: CursorImpl): ElementBuilder {\n  return RehydrateBuilder.forInitialRender(env, cursor);\n}\n"],"names":["Array","Op","Size","fill","DynamicScopeImpl","bucket","constructor","this","assign","get","key","unwrap","set","reference","child","PartialScopeImpl","root","self","size","owner","refs","UNDEFINED_REFERENCE","init","sized","slots","callerScope","evalScope","partialMap","getSelf","getSymbol","symbol","getBlock","block","getEvalScope","getPartialMap","bind","value","bindSelf","bindSymbol","bindBlock","bindEvalScope","map","bindPartialMap","bindCallerScope","scope","getCallerScope","slice","index","length","RangeError","INNER_VM","Symbol","DESTROYABLE_STACK","STACKS","REGISTERS","HEAP","CONSTANTS","ARGS","CursorImpl","element","nextSibling","ConcreteBounds","parentNode","first","last","parentElement","firstNode","lastNode","move","bounds","parent","current","next","insertBefore","expect","clear","removeChild","normalizeStringValue","isEmpty","String","toString","isSafeString","toHTML","isNode","nodeType","isString","normalizeProperty","slotName","type","normalized","lower","toLowerCase","tagName","propName","tag","ATTR_OVERRIDES","toUpperCase","preferAttr","INPUT","form","autocorrect","list","SELECT","OPTION","TEXTAREA","LABEL","FIELDSET","LEGEND","OBJECT","OUTPUT","BUTTON","badProtocols","badTags","badTagsForDataURI","badAttributes","badAttributesForDataURI","has","array","item","indexOf","checkURI","attribute","checkDataURI","requiresSanitization","_protocolForUrlImplementation","sanitizeAttributeValue","str","protocol","url","URL","parse","nodeURL","_url","error","Error","findProtocolForURL","dynamicAttribute","attr","namespace","isTrusting","namespaceURI","name","NS_SVG","buildDynamicAttribute","SafeDynamicProperty","isUserInputValue","InputValueDynamicAttribute","isOptionSelected","OptionSelectedDynamicAttribute","DefaultDynamicProperty","buildDynamicProperty","SafeDynamicAttribute","SimpleDynamicAttribute","DynamicAttribute","dom","_env","normalizedValue","normalizeValue","__setAttribute","update","removeAttribute","setAttribute","normalizedName","super","__setProperty","removeAttributeNS","env","sanitized","input","castToBrowser","currentValue","selected","First","node","Last","CURSOR_STACK","NewElementBuilder","updateOperations","constructing","operations","Stack","modifierStack","blockStack","forInitialRender","cursor","initialize","resume","stack","reset","pushLiveBlock","pushElement","getAppendOperations","getDOM","pushSimpleBlock","debugBlocks","toArray","hasBlocks","popElement","pop","SimpleLiveBlock","pushUpdatableBlock","UpdatableBlockImpl","pushBlockList","LiveBlockList","isRemote","didAppendBounds","__openBlock","push","popBlock","finalize","__closeBlock","openElement","__openElement","createElement","flushElement","modifiers","__flushElement","pushModifiers","didOpenElement","closeElement","willCloseElement","popModifiers","pushRemoteElement","guid","__pushRemoteElement","_guid","undefined","lastChild","RemoteLiveBlock","popRemoteElement","assert","didAppendNode","appendText","string","__appendText","text","createTextNode","__appendNode","__appendFragment","fragment","firstChild","ret","comment","__appendComment","__appendHTML","html","insertHTMLBefore","appendDynamicHTML","trustedContent","appendDynamicText","untrustedContent","appendDynamicFragment","appendDynamicNode","appendComment","createComment","setStaticAttribute","setDynamicAttribute","trusting","nesting","registerDestructor","destroy","boundList","_element","_node","_bounds","_stack","clientBuilder","APPEND_OPCODES","evaluateOpcode","add","evaluate","kind","syscall","debugBefore","vm","opcode","sp","pc","fetchValue","$pc","opName","params","isMachine","state","debugAfter","pre","operation","TYPE","INNER","OWNER","RESOLVED","CURRIED_VALUES","WeakSet","isCurriedValue","isCurriedType","CurriedValue","inner","args","resolved","resolveCurriedValue","curriedValue","positional","named","definition","currentWrapper","curriedArgs","curriedNamed","curriedPositional","concat","unshift","curry","spec","hasCustomDebugRenderTreeLifecycle","manager","ChildScope","pushChildScope","PopScope","popScope","PushDynamicScope","pushDynamicScope","PopDynamicScope","popDynamicScope","Constant","op1","other","getValue","decodeHandle","ConstantReference","createConstRef","Primitive","primitive","isHandle","decodeImmediate","PrimitiveReference","ref","NULL_REFERENCE","TRUE_REFERENCE","FALSE_REFERENCE","createPrimitiveRef","Dup","register","op2","offset","position","dup","Pop","count","Load","load","Fetch","fetch","BindDynamicScope","_names","names","getArray","bindDynamicScope","Enter","enter","Exit","exit","PushSymbolTable","_table","PushBlockScope","CompileBlock","compile","InvokeYield","handle","table","isArray","parameters","pushFrame","pushScope","invokingScope","locals","localsCount","i","at","call","JumpIf","target","Boolean","valueForRef","isConstRef","goto","updateWith","Assert","JumpUnless","JumpEq","comparison","peek","AssertSame","ToBoolean","valueRef","createComputeRef","toBool","throw","AssertFilter","filter","JumpIfNotModifiedOpcode","CONSTANT_TAG","lastRevision","INITIAL","didModify","alwaysRevalidate","validateTag","consumeTag","valueForTag","BeginTrackFrameOpcode","debugLabel","beginTrackFrame","EndTrackFrameOpcode","endTrackFrame","Text","elements","Comment","OpenElement","OpenDynamicElement","PushRemoteElement","elementRef","insertBeforeRef","guidRef","associateDestroyable","debugRenderTree","createCapturedArgs","create","instance","willDestroy","PopRemoteElement","didRender","FlushElement","$t0","flush","loadValue","CloseElement","forEach","modifier","scheduleInstallModifier","d","getDestroyable","Modifier","isInteractive","getOwner","capturedArgs","capture","addModifier","getTag","UpdateModifierOpcode","DynamicModifier","outerPositional","outerNamed","initialOwner","instanceRef","hostDefinition","isObject","CurriedTypes","resolvedDefinition","curriedOwner","Object","getInternalModifierManager","resolvedName","UpdateDynamicModifierOpcode","lastUpdated","scheduleUpdateModifier","CURRENT_TAG","newInstance","destroyable","associateDestroyableChild","StaticAttr","_name","_value","op3","_namespace","DynamicAttr","_trusting","UpdateDynamicAttributeOpcode","updateRef","initialized","PushComponentDefinition","capabilities","lookup","ResolveDynamicComponent","_isStrict","component","constants","$t1","resolver","lookupComponent","resolvedComponent","resolveComponent","runtime","ResolveCurriedComponent","PushDynamicComponentInstance","PushArgs","_blockNames","flags","positionalCount","atNames","blockNames","EMPTY_STRING_ARRAY","setup","PushEmptyArgs","empty","CaptureArgs","PrepareArgs","_state","Component","resolvedValue","merge","realloc","prepend","managerHasCapability","InternalComponentCapabilities","prepareArgs","blocks","values","preparedArgs","keys","CreateComponent","createInstance","dynamicScope","hasDefaultBlock","createArgs","createCaller","updateHook","UpdateComponentOpcode","RegisterComponentDestructor","BeginComponentTransaction","beginCacheGroup","PutComponentOperations","ComponentElementOperations","ComponentAttr","StaticComponentAttr","attributes","dict","classes","deferred","getDebugName","getDebugInstance","DebugRenderTreeUpdateOpcode","DebugRenderTreeDidRenderOpcode","setDeferredAttr","mergeClasses","every","c","allStringClasses","join","symbolName","blockName","symbols","DidCreateElement","didCreateElement","GetComponentSelf","selfRef","moduleName","compilable","dynamicLayout","getDynamicLayout","getDebugCustomRenderTree","template","GetComponentTagName","getTagName","GetComponentLayout","wrapped","unwrapTemplate","defaultTemplate","asWrappedLayout","asLayout","context","symbolTable","Main","invocation","PopulateLayout","VirtualRootScope","hasSubOwner","pushRootScope","SetupForEval","hasEval","SetNamedVariables","callerNames","atName","SetBlocks","enumerate","symbolNames","InvokeComponentLayout","DidRenderLayout","EMPTY_ARGS","reverse","didRenderLayout","didCreate","DidUpdateLayoutOpcode","CommitComponentTransaction","commitCacheGroup","_vm","didUpdateLayout","didUpdate","VMArgumentsImpl","PositionalArgumentsImpl","NamedArgumentsImpl","BlockArgumentsImpl","base","$sp","namedCount","namedBase","positionalBase","blocksCount","blocksBase","pos","newBase","copy","EMPTY_POSITIONAL","EMPTY_NAMED","EMPTY_REFERENCES","emptyArray","_references","references","additions","_atNames","toSyntheticName","toAtName","idx","newNames","toSymbolName","EMPTY_BLOCK_VALUES","internalValues","_symbolNames","internalTag","CapturedBlockArgumentsImpl","reifyNamed","reified","entries","reifyPositional","reifyArgs","ARGUMENT_ERROR","isArgumentError","arg","ArgumentErrorImpl","reifyArgsDebug","e","reifyNamedDebug","p","freeze","castToString","resolveHelper","helper","managerOrHelper","getInternalHelperManager","getHelper","isUndefinedReference","Curry","$v0","isStrict","lastValue","curriedDefinition","createCurryRef","DynamicHelper","helperRef","helperInstanceRef","Helper","resolvedDef","_hasDestroyableChildren","helperValueRef","GetVariable","expr","referenceForSymbol","SetVariable","SetBlock","ResolveMaybeLocal","childRefFor","RootScope","GetProperty","_key","GetBlock","_block","SpreadBlock","handleOrCompilable","HasBlock","HasBlockParams","hasBlockParams","Concat","out","partsRefs","parts","IfInline","condition","truthy","falsy","Not","GetDynamicVar","nameRef","Log","console","log","DynamicTextContent","nodeValue","toContentType","shouldCoerce","ContentType","CurriedType","hasInternalComponentManager","hasInternalHelperManager","SafeString","isFragment","Fragment","Node","toDynamicContentType","debugCallback","info","DynamicContentType","AppendHTML","rawValue","AppendSafeHTML","AppendText","AppendDocumentFragment","AppendNode","callback","setDebuggerCallback","cb","resetDebuggerCallback","ScopeInspector","debugInfo","slot","path","split","head","tail","reduce","r","part","Debugger","_symbols","_debugInfo","inspector","EnterList","relativeStart","elseTarget","listRef","keyRef","keyValue","iteratorRef","createIteratorRef","iterator","enterList","ExitList","exitList","Iterate","breaks","registerItem","enterItem","CAPABILITIES","dynamicTag","attributeHook","elementHook","TemplateOnlyComponentManager","getCapabilities","TEMPLATE_ONLY_COMPONENT_MANAGER","TemplateOnlyComponentDefinition","templateOnlyComponent","setInternalComponentManager","prototype","SVG_INTEGRATION_POINTS","foreignObject","desc","title","BLACKLIST_TABLE","DOMOperations","document","setupUselessElement","uselessElement","isElementInSVGNamespace","isHTMLIntegrationPoint","createElementNS","prev","previousSibling","insertAdjacentHTML","INSERT_BEFORE_END","HTMLElement","INSERT_BEFORE_BEGIN","data","applySVGInnerHTMLFix","DOMClass","svgNamespace","svg","childNodes","shouldApplyFix","div","source","wrappedHtml","clearElement","INSERT_AFTER_BEGIN","moveNodesBefore","fixSVG","applyTextNodeMergingFix","mergingTextDiv","appendChild","uselessComment","didSetUselessComment","nextPrevious","doc","castToSimple","appliedTreeConstruction","setAttributeNS","DOMTreeConstruction","WHITESPACE","isWhitespace","test","DOMChangesImpl","insertAfter","DOMChanges","GUID","Ref","id","release","label","DebugRenderTreeImpl","WeakMap","roots","Set","nodes","begin","internalNode","nodeFor","commit","captureRefs","delete","captured","captureNode","captureTemplate","captureBounds","children","TRANSACTION","TransactionImpl","scheduledInstallModifiers","scheduledUpdateModifiers","createdComponents","updatedComponents","modifierTag","track","install","updateTag","EnvironmentImpl","isArgumentCaptureError","options","delegate","enableDebugTooling","DebugRenderTree","appendOperations","transaction","onTransactionCommit","runtimeContext","artifacts","program","RuntimeProgramImpl","heap","inTransaction","internalHelper","setInternalHelperManager","normalizeTextValue","buildUntouchableThis","fn","callbackRef","invocationArgs","isInvokableRef","sourceRef","pathRef","isDict","getPath","setPath","hash","Map","getArgs","proxy","argsCache","SimpleArgsProxy","computeArgs","createCache","invokeHelper","getDelegateFor","cache","createHelper","hasValue","hasDestroyable","OnModifierState","createUpdatableTag","listener","eventName","removeEventListener","updateListener","once","passive","userProvidedCallback","_once","_passive","_capture","shouldUpdate","adds","addEventListener","removes","on","setInternalModifierManager","counters","_owner","LowLevelVM","currentOpSize","externs","registers","fetchRegister","loadRegister","setPc","isNaN","$ra","$fp","popFrame","pushSmallFrame","popSmallFrame","getaddr","returnTo","return","nextStatement","operationSize","evaluateOuter","evaluateInner","evaluateMachine","evaluateSyscall","MachineOp","PushFrame","PopFrame","InvokeStatic","InvokeVirtual","Jump","Return","ReturnTo","UpdatingVM","frameStack","execute","opcodes","handler","_execute","try","frame","ops","UpdatingVMFrame","handleException","ResumableVMStateImpl","resumeCallback","builder","BlockOpcode","TryOpcode","destroyChildren","elementStack","updating","result","pushUpdating","drop","ListItemOpcode","retained","memo","updateReferences","shouldRemove","ListBlockOpcode","opcodeMap","marker","lastIterator","iterableRef","initializeChild","sync","itemMap","currentOpcodeIndex","seenIndex","retainItem","itemOpcode","moveItem","seenUnretained","insertItem","deleteItem","before","currentSibling","moveBounds","exceptionHandler","RenderResultImpl","rerender","EvaluationStackImpl","restore","snapshot","from","to","n","top","start","end","items","Stacks","VM","destructor","ARGS$1","s0","s1","t0","t1","v0","isLowLevelRegister","$s0","$s1","initVM","evalStack","initial","treeBuilder","numSymbols","vmState","unwrapHandle","captureState","guard","tryOpcode","didEnter","createIteratorItemRef","memoRef","listBlock","addr","popUpdating","tryUpdating","done","TemplateIteratorImpl","renderSync","renderMain","layout","renderComponent","argList","argNames","renderInvocation","stdlib","main","record","acc","recordToReference","SERIALIZATION_FIRST_NODE_STRING","isSerializationFirstNode","RehydratingCursor","candidate","openBlockDepth","injectedOmittedNode","startingBlockDepth","RehydrateBuilder","unmatchedAttributes","blockDepth","startingBlockOffset","currentCursor","isOpenBlock","getBlockDepth","newBlockDepth","newCandidate","closingNode","isCloseBlock","newClosingBlock","disableRehydration","enableRehydration","clearMismatch","getBlockDepthWithOffset","remove","isRehydrating","candidateBounds","markerBounds","newBounds","possibleEmptyMarker","_candidate","isMarker","isElement","isSameNodeType","unmatched","findByName","splice","getMarker","querySelector","cursorId","COMMENT_NODE","lastIndexOf","parseInt","rehydrationBuilder"],"mappings":"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"}