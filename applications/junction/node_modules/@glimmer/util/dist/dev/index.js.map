{"version":3,"file":"index.js","sources":["../../lib/array-utils.ts","../../lib/object-utils.ts"],"sourcesContent":["export const EMPTY_ARRAY: readonly unknown[] = Object.freeze([]) as readonly unknown[];\n\nexport function emptyArray<T>(): T[] {\n  return EMPTY_ARRAY as T[];\n}\n\nexport const EMPTY_STRING_ARRAY = emptyArray<string>();\nexport const EMPTY_NUMBER_ARRAY = emptyArray<number>();\n\n/**\n * This function returns `true` if the input array is the special empty array sentinel,\n * which is sometimes used for optimizations.\n */\nexport function isEmptyArray(input: unknown[] | readonly unknown[]): boolean {\n  return input === EMPTY_ARRAY;\n}\n\nexport function* reverse<T>(input: T[]): IterableIterator<T> {\n  for (let i = input.length - 1; i >= 0; i--) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    yield input[i]!;\n  }\n}\n\nexport function* enumerate<T>(input: Iterable<T>): IterableIterator<[number, T]> {\n  let i = 0;\n  for (const item of input) {\n    yield [i++, item];\n  }\n}\n\ntype ZipEntry<T extends readonly unknown[]> = {\n  [P in keyof T]: P extends `${infer N extends number}` ? [N, T[P], T[P]] : never;\n}[keyof T & number];\n\n/**\n * Zip two tuples with the same type and number of elements.\n */\nexport function* zipTuples<T extends readonly unknown[]>(\n  left: T,\n  right: T\n): IterableIterator<ZipEntry<T>> {\n  for (let i = 0; i < left.length; i++) {\n    yield [i, left[i], right[i]] as ZipEntry<T>;\n  }\n}\n\nexport function* zipArrays<T>(\n  left: T[],\n  right: T[]\n): IterableIterator<\n  ['retain', number, T, T] | ['pop', number, T, undefined] | ['push', number, undefined, T]\n> {\n  for (let i = 0; i < left.length; i++) {\n    const perform = i < right.length ? 'retain' : 'pop';\n    yield [perform, i, left[i], right[i]] as\n      | ['retain', number, T, T]\n      | ['pop', number, T, undefined];\n  }\n\n  for (let i = left.length; i < right.length; i++) {\n    yield ['push', i, undefined, right[i]] as ['push', number, undefined, T];\n  }\n}\n","export const assign = Object.assign;\n\nexport function values<T>(obj: { [s: string]: T }): T[] {\n  return Object.values(obj);\n}\n\nexport type ObjectEntry<D extends object> = { [P in keyof D]: [P, D[P]] }[keyof D];\n\nexport function entries<D extends object>(dict: D): ObjectEntry<D>[] {\n  return Object.entries(dict) as ObjectEntry<D>[];\n}\n\nexport function keys<T extends object>(obj: T): (keyof T)[] {\n  return Object.keys(obj) as (keyof T)[];\n}\n"],"names":["EMPTY_ARRAY","Object","freeze","assign"],"mappings":"MAAAA,cAAAC,OAAAC,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAAC,MAAAA,SAAAF,OAAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}