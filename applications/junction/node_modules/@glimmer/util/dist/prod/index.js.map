{"version":3,"file":"index.js","sources":["../../lib/array-utils.ts","../../../debug-util/lib/present.ts","../../lib/collections.ts","../../lib/debug-steps.ts","../../lib/dom.ts","../../lib/intern.ts","../../lib/is-serialization-first-node.ts","../../lib/object-utils.ts","../../lib/string.ts","../../index.ts"],"sourcesContent":["export const EMPTY_ARRAY: readonly unknown[] = Object.freeze([]) as readonly unknown[];\n\nexport function emptyArray<T>(): T[] {\n  return EMPTY_ARRAY as T[];\n}\n\nexport const EMPTY_STRING_ARRAY = emptyArray<string>();\nexport const EMPTY_NUMBER_ARRAY = emptyArray<number>();\n\n/**\n * This function returns `true` if the input array is the special empty array sentinel,\n * which is sometimes used for optimizations.\n */\nexport function isEmptyArray(input: unknown[] | readonly unknown[]): boolean {\n  return input === EMPTY_ARRAY;\n}\n\nexport function* reverse<T>(input: T[]): IterableIterator<T> {\n  for (let i = input.length - 1; i >= 0; i--) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    yield input[i]!;\n  }\n}\n\nexport function* enumerate<T>(input: Iterable<T>): IterableIterator<[number, T]> {\n  let i = 0;\n  for (const item of input) {\n    yield [i++, item];\n  }\n}\n\ntype ZipEntry<T extends readonly unknown[]> = {\n  [P in keyof T]: P extends `${infer N extends number}` ? [N, T[P], T[P]] : never;\n}[keyof T & number];\n\n/**\n * Zip two tuples with the same type and number of elements.\n */\nexport function* zipTuples<T extends readonly unknown[]>(\n  left: T,\n  right: T\n): IterableIterator<ZipEntry<T>> {\n  for (let i = 0; i < left.length; i++) {\n    yield [i, left[i], right[i]] as ZipEntry<T>;\n  }\n}\n\nexport function* zipArrays<T>(\n  left: T[],\n  right: T[]\n): IterableIterator<\n  ['retain', number, T, T] | ['pop', number, T, undefined] | ['push', number, undefined, T]\n> {\n  for (let i = 0; i < left.length; i++) {\n    const perform = i < right.length ? 'retain' : 'pop';\n    yield [perform, i, left[i], right[i]] as\n      | ['retain', number, T, T]\n      | ['pop', number, T, undefined];\n  }\n\n  for (let i = left.length; i < right.length; i++) {\n    yield ['push', i, undefined, right[i]] as ['push', number, undefined, T];\n  }\n}\n","import type { Nullable, Present, PresentArray } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nexport function isPresent<T>(value: T): value is Present<T> {\n  return value !== null && value !== undefined;\n}\n\nexport function assertPresent<T extends string>(value: T): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message: string): asserts value is Present<T>;\nexport function assertPresent<T>(value: T, message?: string): asserts value is Present<T> {\n  if (LOCAL_DEBUG && !isPresent(value)) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    throw new Error(`Expected present, got ${typeof value === 'string' ? value : message!}`);\n  }\n}\n\nexport function isPresentArray<T>(list?: readonly T[]): list is PresentArray<T> {\n  return list ? list.length > 0 : false;\n}\n\nexport function ifPresent<T, U, V>(\n  list: T[],\n  ifPresent: (input: PresentArray<T>) => U,\n  otherwise: () => V\n): U | V {\n  if (isPresentArray(list)) {\n    return ifPresent(list);\n  } else {\n    return otherwise();\n  }\n}\n\nexport function arrayToOption<T>(list: T[]): Nullable<PresentArray<T>> {\n  if (isPresentArray(list)) {\n    return list;\n  } else {\n    return null;\n  }\n}\n\nexport function assertPresentArray<T>(\n  list: T[],\n  message = `unexpected empty list`\n): asserts list is PresentArray<T> {\n  if (LOCAL_DEBUG && !isPresentArray(list)) {\n    throw new Error(message);\n  }\n}\n\nexport function asPresentArray<T>(list: T[], message = `unexpected empty list`): PresentArray<T> {\n  assertPresentArray(list, message);\n  return list;\n}\n\nexport function getLast<T>(list: PresentArray<T>): T;\nexport function getLast<T>(list: T[]): T | undefined;\nexport function getLast<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[list.length - 1] as T);\n}\n\nexport function getFirst<T>(list: PresentArray<T>): T;\nexport function getFirst<T>(list: T[]): T | undefined;\nexport function getFirst<T>(list: T[]): T | undefined {\n  return list.length === 0 ? undefined : (list[0] as T);\n}\n\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T>,\n  mapper: (input: T) => U\n): PresentArray<U>;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null;\nexport function mapPresentArray<T, U>(\n  list: PresentArray<T> | null,\n  mapper: (input: T) => U\n): PresentArray<U> | null {\n  if (list === null) {\n    return null;\n  }\n  let out: U[] = [];\n\n  for (let item of list) {\n    out.push(mapper(item));\n  }\n\n  return out as PresentArray<U>;\n}\n","import type { Dict, Nullable, Stack } from '@glimmer/interfaces';\nimport { getLast, unwrap } from '@glimmer/debug-util';\n\nexport function dict<T = unknown>(): Dict<T> {\n  return Object.create(null) as Dict<T>;\n}\n\nexport function isDict<T>(u: T): u is Dict & T {\n  return u !== null && u !== undefined;\n}\n\nexport function isIndexable<T>(u: T): u is object & T {\n  return typeof u === 'function' || (typeof u === 'object' && u !== null);\n}\n\nexport class StackImpl<T> implements Stack<T> {\n  private stack: T[];\n  public current: Nullable<T> = null;\n\n  constructor(values: T[] = []) {\n    this.stack = values;\n  }\n\n  public get size() {\n    return this.stack.length;\n  }\n\n  push(item: T) {\n    this.current = item;\n    this.stack.push(item);\n  }\n\n  pop(): Nullable<T> {\n    let item = this.stack.pop();\n    this.current = getLast(this.stack) ?? null;\n\n    return item === undefined ? null : item;\n  }\n\n  nth(from: number): Nullable<T> {\n    let len = this.stack.length;\n    return len < from ? null : unwrap(this.stack[len - from]);\n  }\n\n  isEmpty(): boolean {\n    return this.stack.length === 0;\n  }\n\n  snapshot(): T[] {\n    return [...this.stack];\n  }\n\n  toArray(): T[] {\n    return this.stack;\n  }\n}\n","/// <reference types=\"qunit\" />\n\nimport { expect, localAssert } from '@glimmer/debug-util';\nimport { LOCAL_DEBUG, LOCAL_TRACE_LOGGING } from '@glimmer/local-debug-flags';\n\nimport { LOCAL_LOGGER } from '../index';\n\nexport let beginTestSteps: (() => void) | undefined;\nexport let endTestSteps: (() => void) | undefined;\n\nexport let verifySteps:\n  | ((type: string, steps: unknown[] | ((steps: unknown[]) => void), message?: string) => void)\n  | undefined;\nexport let logStep: ((type: string, steps: unknown) => void) | undefined;\n\nif (LOCAL_DEBUG) {\n  let LOGGED_STEPS: Record<string, unknown[]> | null = null;\n\n  beginTestSteps = () => {\n    localAssert(LOGGED_STEPS === null, 'attempted to start steps, but it already began');\n\n    LOGGED_STEPS = {};\n  };\n\n  endTestSteps = () => {\n    localAssert(LOGGED_STEPS, 'attempted to end steps, but they were not started');\n\n    LOGGED_STEPS = null;\n  };\n\n  logStep = (type: string, step: unknown) => {\n    if (LOCAL_TRACE_LOGGING) {\n      LOCAL_LOGGER.log('STEP', type, step);\n    }\n\n    if (LOGGED_STEPS === null) return;\n\n    let steps = LOGGED_STEPS[type];\n    if (!steps) steps = LOGGED_STEPS[type] = [];\n\n    steps.push(step);\n  };\n\n  verifySteps = (\n    type: string,\n    expectedSteps: unknown[] | ((steps: unknown[]) => void),\n    message?: string\n  ) => {\n    let loggedSteps = expect(LOGGED_STEPS, 'attempetd to verify steps, but steps were not started');\n\n    let steps = loggedSteps[type] || [];\n\n    loggedSteps[type] = [];\n\n    if (Array.isArray(expectedSteps)) {\n      getCurrent().assert.deepEqual(steps, expectedSteps, message);\n    } else {\n      expectedSteps(steps);\n    }\n  };\n\n  function getCurrent(): QUnit {\n    return QUnit.config.current as QUnit;\n  }\n}\n","import type { Nullable, SimpleElement, SimpleNode } from '@glimmer/interfaces';\n\nexport function clearElement(parent: SimpleElement) {\n  let current: Nullable<SimpleNode> = parent.firstChild;\n\n  while (current) {\n    let next = current.nextSibling;\n    parent.removeChild(current);\n    current = next;\n  }\n}\n","/**\n  Strongly hint runtimes to intern the provided string.\n\n  When do I need to use this function?\n\n  For the most part, never. Pre-mature optimization is bad, and often the\n  runtime does exactly what you need it to, and more often the trade-off isn't\n  worth it.\n\n  Why?\n\n  Runtimes store strings in at least 2 different representations:\n  Ropes and Symbols (interned strings). The Rope provides a memory efficient\n  data-structure for strings created from concatenation or some other string\n  manipulation like splitting.\n\n  Unfortunately checking equality of different ropes can be quite costly as\n  runtimes must resort to clever string comparison algorithms. These\n  algorithms typically cost in proportion to the length of the string.\n  Luckily, this is where the Symbols (interned strings) shine. As Symbols are\n  unique by their string content, equality checks can be done by pointer\n  comparison.\n\n  How do I know if my string is a rope or symbol?\n\n  Typically (warning general sweeping statement, but truthy in runtimes at\n  present) static strings created as part of the JS source are interned.\n  Strings often used for comparisons can be interned at runtime if some\n  criteria are met.  One of these criteria can be the size of the entire rope.\n  For example, in chrome 38 a rope longer then 12 characters will not\n  intern, nor will segments of that rope.\n\n  Some numbers: http://jsperf.com/eval-vs-keys/8\n\n  Known Trickâ„¢\n\n  @private\n  @return {String} interned version of the provided string\n*/\nexport default function intern(str: string): string {\n  let obj: Record<string, number> = {};\n  obj[str] = 1;\n  for (let key in obj) {\n    if (key === str) {\n      return key;\n    }\n  }\n  return str;\n}\n","import type { SimpleNode } from '@glimmer/interfaces';\n\nexport const SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';\n\nexport function isSerializationFirstNode(node: SimpleNode): boolean {\n  return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;\n}\n","export const assign = Object.assign;\n\nexport function values<T>(obj: { [s: string]: T }): T[] {\n  return Object.values(obj);\n}\n\nexport type ObjectEntry<D extends object> = { [P in keyof D]: [P, D[P]] }[keyof D];\n\nexport function entries<D extends object>(dict: D): ObjectEntry<D>[] {\n  return Object.entries(dict) as ObjectEntry<D>[];\n}\n\nexport function keys<T extends object>(obj: T): (keyof T)[] {\n  return Object.keys(obj) as (keyof T)[];\n}\n","import { getFirst, getLast, isPresentArray } from '@glimmer/debug-util';\n\nimport { enumerate } from './array-utils';\n\nexport function strip(strings: TemplateStringsArray, ...args: unknown[]) {\n  let out = '';\n  for (const [i, string] of enumerate(strings)) {\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n    let dynamic = args[i] !== undefined ? String(args[i]) : '';\n\n    out += `${string}${dynamic}`;\n  }\n\n  let lines = out.split('\\n');\n\n  while (isPresentArray(lines) && /^\\s*$/u.test(getFirst(lines))) {\n    lines.shift();\n  }\n\n  while (isPresentArray(lines) && /^\\s*$/u.test(getLast(lines))) {\n    lines.pop();\n  }\n\n  let min = Infinity;\n\n  for (let line of lines) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    let leading = /^\\s*/u.exec(line)![0].length;\n\n    min = Math.min(min, leading);\n  }\n\n  let stripped = [];\n\n  for (let line of lines) {\n    stripped.push(line.slice(min));\n  }\n\n  return stripped.join('\\n');\n}\n","export * from './lib/array-utils';\nexport { dict, isDict, isIndexable, StackImpl as Stack } from './lib/collections';\nexport { beginTestSteps, endTestSteps, logStep, verifySteps } from './lib/debug-steps';\nexport * from './lib/dom';\nexport { default as intern } from './lib/intern';\nexport {\n  isSerializationFirstNode,\n  SERIALIZATION_FIRST_NODE_STRING,\n} from './lib/is-serialization-first-node';\nexport { assign, entries, keys, values } from './lib/object-utils';\nexport * from './lib/string';\n\nexport type FIXME<T, S extends string> = (T & S) | T;\n\n/**\n * This constant exists to make it easier to differentiate normal logs from\n * errant console.logs. LOCAL_LOGGER should only be used inside a\n * LOCAL_TRACE_LOGGING check.\n *\n * It does not alleviate the need to check LOCAL_TRACE_LOGGING, which is used\n * for stripping.\n */\nexport const LOCAL_LOGGER = console;\n\n/**\n * This constant exists to make it easier to differentiate normal logs from\n * errant console.logs. LOGGER can be used outside of LOCAL_TRACE_LOGGING checks,\n * and is meant to be used in the rare situation where a console.* call is\n * actually appropriate.\n */\nexport const LOGGER = console;\n\nexport function assertNever(value: never, desc = 'unexpected unreachable branch'): never {\n  LOGGER.log('unreachable', value);\n  LOGGER.log(`${desc} :: ${JSON.stringify(value)} (${value})`);\n\n  throw new Error(`code reached unreachable`);\n}\n"],"names":["EMPTY_ARRAY","Object","freeze","emptyArray","EMPTY_STRING_ARRAY","EMPTY_NUMBER_ARRAY","isEmptyArray","input","reverse","i","length","enumerate","item","zipTuples","left","right","zipArrays","perform","undefined","isPresentArray","list","getLast","dict","create","isDict","u","isIndexable","StackImpl","constructor","values","current","this","stack","size","push","pop","nth","from","len","isEmpty","snapshot","toArray","beginTestSteps","endTestSteps","verifySteps","logStep","clearElement","parent","firstChild","next","nextSibling","removeChild","intern","str","obj","key","SERIALIZATION_FIRST_NODE_STRING","isSerializationFirstNode","node","nodeValue","assign","entries","keys","strip","strings","args","out","string","String","lines","split","test","shift","min","Infinity","line","leading","exec","Math","stripped","slice","join","LOCAL_LOGGER","console","LOGGER","assertNever","value","desc","log","JSON","stringify","Error"],"mappings":"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"}