import { _ as _applyDecoratedDescriptor, a as _defineProperty, b as _initializerDefineProperty, F as FileSource } from '../rate-6e913d98.js';
import Component from '@glimmer/component';
import * as s from '@ember/service';
import { getOwner } from '@ember/application';
import { D as DataTransferWrapper } from '../data-transfer-wrapper-59b09dd4.js';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { D as DEFAULT_QUEUE, U as UploadFile } from '../file-queue-0c24ea61.js';
import Modifier from 'ember-modifier';
import { assert } from '@ember/debug';
import { cancel, next } from '@ember/runloop';
import { registerDestructor } from '@ember/destroyable';
import { precompileTemplate } from '@ember/template-compilation';
import { setComponentTemplate } from '@ember/component';

var _class$1;
let DragListener = (_class$1 = class DragListener {
  constructor(dropzone) {
    _defineProperty(this, "_dropzone", void 0);
    _defineProperty(this, "_listeners", []);
    _defineProperty(this, "_stack", []);
    _defineProperty(this, "_listener", null);
    // Keep a stack of deferred actions to take
    // on listeners to provide sane events.
    // `dragleave` / `dragenter` are called on the
    // same element back to back, which isn't what
    // we want to provide as an API.
    _defineProperty(this, "_events", []);
    _defineProperty(this, "_handlers", {});
    _defineProperty(this, "_handlersAttached", false);
    _defineProperty(this, "_scheduled", null);
    this._dropzone = dropzone;
  }
  beginListening() {
    if (!this._dropzone) return;
    this._dropzone.addEventListener('dragenter', this.dragenter, {
      passive: true
    });
    this._dropzone.addEventListener('dragleave', this.dragleave, {
      passive: true
    });
    this._dropzone.addEventListener('dragover', this.dragover, {
      passive: false
    });
    this._dropzone.addEventListener('drop', this.drop, {
      passive: false
    });
    this._handlersAttached = true;
  }
  endListening() {
    if (!this._dropzone) return;
    if (!this._handlersAttached) return;
    this._dropzone.removeEventListener('dragenter', this.dragenter);
    this._dropzone.removeEventListener('dragleave', this.dragleave);
    this._dropzone.removeEventListener('dragover', this.dragover);
    this._dropzone.removeEventListener('drop', this.drop);
  }
  addEventListeners(handlers) {
    if (!this._dropzone) return;
    if (this._listeners.length === 0) {
      this.beginListening();
    }

    // Listeners are ordered by most specific to least specific
    let insertAt = this._listeners.length;
    for (let i = 0, len = this._listeners.length; i < len; i++) {
      const listener = this._listeners[i];
      if (listener) {
        assert(`Cannot add multiple listeners for the same element ${this._dropzone}, ${listener.element}`, this._dropzone !== listener.element);
        if (listener.element.contains(this._dropzone)) {
          insertAt = i;
        }
      }
    }
    this._listeners.splice(insertAt, 0, {
      element: this._dropzone,
      handlers
    });
  }
  removeEventListeners() {
    this._listeners = this._listeners.filter(listener => listener.element !== this._dropzone);
    if (this._listeners.length === 0) {
      this.endListening();
    }
  }
  findListener(evt) {
    return this._listeners.find(({
      element
    }) => {
      return element === evt.target || element.contains(evt.target);
    });
  }
  getEventSource(evt) {
    const types = evt.dataTransfer?.types ?? [];
    let areSomeTypesFiles = false;
    for (let i = 0, len = types.length; i < len; i++) {
      if (types[i] === 'Files' || types[i] === 'application/x-moz-file') {
        areSomeTypesFiles = true;
        break;
      }
    }
    return areSomeTypesFiles ? 'os' : 'web';
  }
  getDataTransferItemDetails(evt) {
    const itemDetails = [];
    if (evt.dataTransfer?.items) {
      for (let i = 0; i < evt.dataTransfer.items.length; i++) {
        const item = evt.dataTransfer.items[i];
        if (item) {
          itemDetails.push({
            kind: item.kind,
            type: item.type
          });
        }
      }
    }
    return itemDetails;
  }
  dragenter(evt) {
    const event = evt;
    const listener = this.findListener(event);
    const lastListener = this._stack[this._stack.length - 1];

    // Trigger dragleave on the previous listener
    if (lastListener) {
      this.scheduleEvent('dragleave', lastListener, event);
    }
    if (listener) {
      this.scheduleEvent('dragenter', listener, {
        ...event,
        source: this.getEventSource(event),
        dataTransfer: event.dataTransfer,
        itemDetails: this.getDataTransferItemDetails(event)
      });
    }
    this._listener = listener ?? null;
  }
  dragleave(evt) {
    const event = evt;
    // Trigger a dragleave if the file leaves the browser
    if (this._stack[0]) {
      this.scheduleEvent('dragleave', this._stack[0], event);
      this._listener = null;
    }
  }
  dragover(evt) {
    const event = evt;
    event.preventDefault();
    event.stopPropagation();
    const listener = this.findListener(event);
    if (listener) {
      if (this._listener) {
        this.scheduleEvent('dragleave', this._listener, event);
      }
      this.scheduleEvent('dragenter', listener, {
        ...event,
        source: this.getEventSource(event),
        dataTransfer: event.dataTransfer,
        itemDetails: this.getDataTransferItemDetails(event)
      });
      if (this._stack.includes(listener)) {
        listener.handlers?.dragover?.(event);
      }
    }
    this._listener = listener ?? null;
  }
  scheduleEvent(eventName, listener, event) {
    const isDuplicate = this._events.find(queuedEvent => {
      return queuedEvent.eventName === eventName && queuedEvent.listener === listener;
    });
    const cancelledEvent = this._events.find(queuedEvent => {
      return queuedEvent.listener === listener && queuedEvent.eventName === 'dragleave' && eventName === 'dragenter' || queuedEvent.eventName === 'dragenter' && eventName === 'dragleave';
    });
    if (cancelledEvent) {
      // Remove cancelled event
      this._events = this._events.filter(queuedEvent => {
        return queuedEvent.listener !== cancelledEvent.listener && queuedEvent.eventName !== cancelledEvent.eventName && queuedEvent.event !== cancelledEvent.event;
      });
      if (this._events.length === 0) {
        if (this._scheduled) {
          cancel(this._scheduled);
        }
        this._scheduled = null;
      }
    } else if (!isDuplicate) {
      this._events.push({
        eventName,
        listener,
        event
      });
      if (!this._scheduled) {
        this._scheduled = next(this, this.sendEvents);
      }
    }
  }
  sendEvents() {
    this._events.forEach(({
      eventName,
      listener,
      event
    }) => {
      if (eventName === 'dragenter') {
        this._stack.push(listener);
      } else if (eventName === 'dragleave') {
        this._stack.pop();
      }
      listener.handlers[eventName]?.(event);
    });
    this._events = [];
    this._scheduled = null;
  }
  drop(evt) {
    const event = evt;
    this._stack = [];
    this._events = [];
    this._scheduled = null;
    this._listener = null;
    evt.preventDefault();
    evt.stopPropagation();
    const listener = this.findListener(event);
    listener?.handlers?.drop?.(event);
  }
}, _applyDecoratedDescriptor(_class$1.prototype, "dragenter", [action], Object.getOwnPropertyDescriptor(_class$1.prototype, "dragenter"), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, "dragleave", [action], Object.getOwnPropertyDescriptor(_class$1.prototype, "dragleave"), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, "dragover", [action], Object.getOwnPropertyDescriptor(_class$1.prototype, "dragover"), _class$1.prototype), _applyDecoratedDescriptor(_class$1.prototype, "drop", [action], Object.getOwnPropertyDescriptor(_class$1.prototype, "drop"), _class$1.prototype), _class$1);

function cleanup(instance) {
  if (!instance.listener) return;
  instance.listener.removeEventListeners();
}
class DragListenerModifier extends Modifier {
  constructor(owner, args) {
    super(owner, args);
    _defineProperty(this, "listener", void 0);
    registerDestructor(this, cleanup);
  }
  modify(dropzone, _, {
    dragenter,
    dragleave,
    dragover,
    drop
  }) {
    this.listener = new DragListener(dropzone);
    this.listener.removeEventListeners();
    this.listener.addEventListeners({
      dragenter,
      dragleave,
      dragover,
      drop
    });
  }
}

var TEMPLATE = precompileTemplate("<div\n  ...attributes\n  {{this.dragListener\n    dragenter=this.didEnterDropzone\n    dragleave=this.didLeaveDropzone\n    dragover=this.didDragOver\n    drop=this.didDrop\n  }}\n>\n  {{yield\n    (hash supported=this.supported active=this.active)\n    this.queue\n  }}\n</div>\n");

var _class, _descriptor, _descriptor2, _descriptor3;
const service = s.service ?? s.inject;

/**
  `FileDropzone` is a component that will allow users to upload files by
   drag and drop.

  ```hbs
  <FileDropzone @queue={{queue}} as |dropzone|>
    {{#if dropzone.active}}
      Drop to upload
    {{else if queue.files.length}}
      Uploading {{queue.files.length}} files. ({{queue.progress}}%)
    {{else}}
      <h4>Upload Images</h4>
      <p>
        {{#if dropzone.supported}}
          Drag and drop images onto this area to upload them or
        {{/if}}
      </p>
    {{/if}}
  </FileDropzone>
  ```

  @class FileDropzoneComponent
  @type Ember.Component
  @yield {Hash} dropzone
  @yield {boolean} dropzone.supported
  @yield {boolean} dropzone.active
  @yield {Queue} queue
 */
let FileDropzoneComponent = (_class = class FileDropzoneComponent extends Component {
  constructor(...args) {
    super(...args);
    _initializerDefineProperty(this, "fileQueue", _descriptor, this);
    _initializerDefineProperty(this, "active", _descriptor2, this);
    _initializerDefineProperty(this, "dataTransferWrapper", _descriptor3, this);
    _defineProperty(this, "supported", (() => typeof window !== 'undefined' && window.document && 'draggable' in document.createElement('span'))());
    _defineProperty(this, "dragListener", DragListenerModifier);
  }
  get queue() {
    if (this.args.queue) {
      return this.args.queue;
    }
    return this.fileQueue.findOrCreate(DEFAULT_QUEUE);
  }
  get multiple() {
    return this.args.multiple ?? true;
  }
  get files() {
    const files = this.dataTransferWrapper?.files ?? [];
    if (this.multiple) return files;
    return files.slice(0, 1);
  }
  get isAllowed() {
    const {
      environment
    } =
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    getOwner(this).resolveRegistration('config:environment');
    return environment === 'test' || this.dataTransferWrapper && this.dataTransferWrapper.source === 'os' || this.args.allowUploadsFromWebsites;
  }
  get cursor() {
    return this.args.cursor ?? 'copy';
  }
  didEnterDropzone(event) {
    this.dataTransferWrapper = new DataTransferWrapper(event);
    if (this.isAllowed) {
      event.dataTransfer.dropEffect = this.cursor;
      this.active = true;
      this.args.onDragEnter?.(this.files, this.dataTransferWrapper);
    }
  }
  didLeaveDropzone(event) {
    if (this.dataTransferWrapper) {
      this.dataTransferWrapper.dataTransfer = event.dataTransfer;
    }
    if (this.dataTransferWrapper && this.isAllowed) {
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = this.cursor;
      }
      this.args.onDragLeave?.(this.files, this.dataTransferWrapper);
      this.dataTransferWrapper = undefined;
      if (this.isDestroyed) {
        return;
      }
      this.active = false;
    }
  }
  didDragOver(event) {
    if (this.dataTransferWrapper) {
      this.dataTransferWrapper.dataTransfer = event.dataTransfer;
    }
    if (this.isAllowed) {
      event.dataTransfer.dropEffect = this.cursor;
    }
  }
  didDrop(event) {
    if (this.dataTransferWrapper) {
      this.dataTransferWrapper.dataTransfer = event.dataTransfer;
    }
    if (!this.isAllowed) {
      event.dataTransfer.dropEffect = this.cursor;
      this.dataTransferWrapper = undefined;
      return;
    }

    // @TODO - add tests for these or remove them
    // // Testing support for dragging and dropping images
    // // from other browser windows
    // let url;

    // // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // // @ts-ignore
    // const html = this.dataTransferWrapper.getData('text/html');
    // if (html) {
    //   const parsedHtml = parseHTML(html);
    //   // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //   // @ts-ignore
    //   const img = parsedHtml.getElementsByTagName('img')[0];
    //   if (img) {
    //     url = img.src;
    //   }
    // }

    // if (url == null) {
    //   // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //   // @ts-ignore
    //   url = this.dataTransferWrapper.getData('text/uri-list');
    // }

    // if (url) {
    //   const image = new Image();
    //   const [filename] = url.split('/').slice(-1);
    //   image.crossOrigin = 'anonymous';
    //   image.onload = () => {
    //     const canvas = document.createElement('canvas');
    //     canvas.width = image.width;
    //     canvas.height = image.height;

    //     const ctx = canvas.getContext('2d');
    //     ctx?.drawImage(image, 0, 0);

    //     if (canvas.toBlob) {
    //       canvas.toBlob((blob) => {
    //         // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //         // @ts-ignore
    //         const [file] = this.addFiles([blob], FileSource.web);
    //         // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //         // @ts-ignore
    //         file.name = filename;
    //       });
    //     } else {
    //       const binStr = atob(canvas.toDataURL().split(',')[1]);
    //       const len = binStr.length;
    //       const arr = new Uint8Array(len);

    //       for (let i = 0; i < len; i++) {
    //         arr[i] = binStr.charCodeAt(i);
    //       }
    //       const blob = new Blob([arr], { type: 'image/png' });
    //       // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //       // @ts-ignore
    //       blob.name = filename;
    //       // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //       // @ts-ignore
    //       const [file] = this.addFiles([blob], FileSource.web);
    //       // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //       // @ts-ignore
    //       file.name = filename;
    //     }
    //   };
    //   /* eslint-disable no-console */
    //   image.onerror = function (e) {
    //     console.log(e);
    //   };
    //   /* eslint-enable no-console */
    //   image.src = url;
    // }

    if (this.dataTransferWrapper) {
      const addedFiles = this.addFiles(this.files);
      this.args.onDrop?.(addedFiles, this.dataTransferWrapper);
      this.active = false;
      this.dataTransferWrapper = undefined;
    }
  }
  addFiles(files) {
    const addedFiles = [];
    for (const file of files) {
      if (file instanceof File) {
        const uploadFile = new UploadFile(file, FileSource.DragAndDrop);
        if (this.args.filter && !this.args.filter(file, files, files.indexOf(file))) {
          continue;
        }
        this.queue.add(uploadFile);
        addedFiles.push(uploadFile);
      }
    }
    return addedFiles;
  }
}, _descriptor = _applyDecoratedDescriptor(_class.prototype, "fileQueue", [service], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "active", [tracked], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "dataTransferWrapper", [tracked], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _applyDecoratedDescriptor(_class.prototype, "didEnterDropzone", [action], Object.getOwnPropertyDescriptor(_class.prototype, "didEnterDropzone"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "didLeaveDropzone", [action], Object.getOwnPropertyDescriptor(_class.prototype, "didLeaveDropzone"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "didDragOver", [action], Object.getOwnPropertyDescriptor(_class.prototype, "didDragOver"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "didDrop", [action], Object.getOwnPropertyDescriptor(_class.prototype, "didDrop"), _class.prototype), _class);
setComponentTemplate(TEMPLATE, FileDropzoneComponent);

export { FileDropzoneComponent as default };
//# sourceMappingURL=file-dropzone.js.map
