declare module '@ember/-internals/glimmer/lib/component-managers/route-template' {
  import type { InternalOwner } from '@ember/-internals/owner';
  import type {
    CapturedArguments,
    CompilableProgram,
    ComponentDefinition,
    CustomRenderNode,
    Destroyable,
    InternalComponentCapabilities,
    Template,
    VMArguments,
    WithCreateInstance,
    WithCustomDebugRenderTree,
  } from '@glimmer/interfaces';
  import type { Nullable } from '@ember/-internals/utility-types';
  import type { Reference } from '@glimmer/reference';
  import { type CurriedValue } from '@glimmer/runtime';
  interface RouteTemplateInstanceState {
    self: Reference;
    controller: unknown;
  }
  export interface RouteTemplateDefinitionState {
    name: string;
    templateName: string;
  }
  class RouteTemplateManager
    implements
      WithCreateInstance<RouteTemplateInstanceState, RouteTemplateDefinitionState>,
      WithCustomDebugRenderTree<RouteTemplateInstanceState, RouteTemplateDefinitionState>
  {
    create(
      _owner: InternalOwner,
      _definition: RouteTemplateDefinitionState,
      args: VMArguments
    ): RouteTemplateInstanceState;
    getSelf({ self }: RouteTemplateInstanceState): Reference;
    getDebugName({ name }: RouteTemplateDefinitionState): string;
    getDebugCustomRenderTree(
      { name, templateName }: RouteTemplateDefinitionState,
      state: RouteTemplateInstanceState,
      args: CapturedArguments
    ): CustomRenderNode[];
    getCapabilities(): InternalComponentCapabilities;
    didRenderLayout(): void;
    didUpdateLayout(): void;
    didCreate(): void;
    didUpdate(): void;
    getDestroyable(): Nullable<Destroyable>;
  }
  /**
   * This "upgrades" a route template into a invocable component. Conceptually
   * it can be 1:1 for each unique `Template`, but it's also cheap to construct,
   * so unless the stability is desirable for other reasons, it's probably not
   * worth caching this.
   */
  export class RouteTemplate
    implements
      ComponentDefinition<
        RouteTemplateDefinitionState,
        RouteTemplateInstanceState,
        RouteTemplateManager
      >
  {
    handle: number;
    resolvedName: string;
    state: RouteTemplateDefinitionState;
    manager: RouteTemplateManager;
    capabilities: import('@glimmer/interfaces').CapabilityMask;
    compilable: CompilableProgram;
    constructor(name: string, template: Template);
  }
  export function makeRouteTemplate(
    owner: InternalOwner,
    name: string,
    template: Template
  ): CurriedValue;
  export {};
}
